(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("luma.gl"), require("path"), require("assert"), require("gl-matrix"), require("earcut"), require("lodash.flattendeep"), require("geojson-normalize"), require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["luma.gl", "path", "assert", "gl-matrix", "earcut", "lodash.flattendeep", "geojson-normalize", "react"], factory);
	else if(typeof exports === 'object')
		exports["deck.gl"] = factory(require("luma.gl"), require("path"), require("assert"), require("gl-matrix"), require("earcut"), require("lodash.flattendeep"), require("geojson-normalize"), require("react"));
	else
		root["deck.gl"] = factory(root["luma.gl"], root["path"], root["assert"], root["gl-matrix"], root["earcut"], root["lodash.flattendeep"], root["geojson-normalize"], root["react"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_14__, __WEBPACK_EXTERNAL_MODULE_15__, __WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_23__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 64);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* exports used: Model, Geometry, GL, Framebuffer, addEvents, createGLContext, glGetDebugInfo, FramebufferObject, glContextWithState, Matrix4, glArrayFromType */
/*!**************************!*\
  !*** external "luma.gl" ***!
  \**************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_0__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImx1bWEuZ2xcIj9lNWFiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsdW1hLmdsXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIj81YjJhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJwYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* exports provided: COORDINATE_SYSTEM, Layer, AttributeManager, LayerManager, isPlainObject */
/* exports used: COORDINATE_SYSTEM, Layer, AttributeManager, LayerManager, isPlainObject */
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__init__ = __webpack_require__(/*! ./init */ 49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(/*! ./constants */ 19);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_1__constants__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer__ = __webpack_require__(/*! ./layer */ 20);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_2__layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__attribute_manager__ = __webpack_require__(/*! ./attribute-manager */ 18);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_3__attribute_manager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__layer_manager__ = __webpack_require__(/*! ./layer-manager */ 50);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_4__layer_manager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_object_iterator__ = __webpack_require__(/*! ./utils/object-iterator */ 21);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_5__utils_object_iterator__[\"a\"]; });\n// Set up deck.gl global state\n\n\n\n\n// Export core objects\n\n\n\n\n// Object iteration helper\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL2luZGV4LmpzP2U2NGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2V0IHVwIGRlY2suZ2wgZ2xvYmFsIHN0YXRlXG5pbXBvcnQgJy4vaW5pdCc7XG5cbmV4cG9ydCB7IENPT1JESU5BVEVfU1lTVEVNIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vLyBFeHBvcnQgY29yZSBvYmplY3RzXG5leHBvcnQgeyBkZWZhdWx0IGFzIExheWVyIH0gZnJvbSAnLi9sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF0dHJpYnV0ZU1hbmFnZXIgfSBmcm9tICcuL2F0dHJpYnV0ZS1tYW5hZ2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5ZXJNYW5hZ2VyIH0gZnJvbSAnLi9sYXllci1tYW5hZ2VyJztcblxuLy8gT2JqZWN0IGl0ZXJhdGlvbiBoZWxwZXJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvb2JqZWN0LWl0ZXJhdG9yJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* exports provided: checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/* exports used: checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/*!***********************************!*\
  !*** ./src/shader-utils/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__ = __webpack_require__(/*! ./assemble-shaders */ 58);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__[\"a\"]; });\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__[\"b\"]; });\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__[\"c\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvc2hhZGVyLXV0aWxzL2luZGV4LmpzPzg3ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9hc3NlbWJsZS1zaGFkZXJzJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NoYWRlci11dGlscy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* exports provided: fp64ify */
/* exports used: fp64ify */
/*!*******************************!*\
  !*** ./src/lib/utils/fp64.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ exports[\"a\"] = fp64ify;\n// TODO - move to shaderlib utilities\nfunction fp64ify(a) {\n  var hiPart = Math.fround(a);\n  var loPart = a - Math.fround(a);\n  return [hiPart, loPart];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL3V0aWxzL2ZwNjQuanM/OTMwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPIC0gbW92ZSB0byBzaGFkZXJsaWIgdXRpbGl0aWVzXG5leHBvcnQgZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gTWF0aC5mcm91bmQoYSk7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3V0aWxzL2ZwNjQuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/* unknown exports provided */
/* exports used: default */
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_5__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiPzFlNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzc2VydFwiXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/* unknown exports provided */
/* exports used: vec2, mat4, vec4, vec3 */
/*!****************************!*\
  !*** external "gl-matrix" ***!
  \****************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImdsLW1hdHJpeFwiP2I5NWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImdsLW1hdHJpeFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/* exports provided: isPlainObject, log, compareProps, areEqualShallow, fp64ify */
/* exports used: log, compareProps */
/*!********************************!*\
  !*** ./src/lib/utils/index.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__object_iterator__ = __webpack_require__(/*! ./object-iterator */ 21);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__compare_objects__ = __webpack_require__(/*! ./compare-objects */ 51);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_1__compare_objects__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__log__ = __webpack_require__(/*! ./log */ 52);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_2__log__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__fp64__ = __webpack_require__(/*! ./fp64 */ 4);\n/* unused harmony namespace reexport */\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL3V0aWxzL2luZGV4LmpzPzc4ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9vYmplY3QtaXRlcmF0b3InO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wYXJlLW9iamVjdHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsb2cgfSBmcm9tICcuL2xvZyc7XG5leHBvcnQgKiBmcm9tICcuL2ZwNjQnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3V0aWxzL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/* exports provided: default, createMat4 */
/* exports used: default, createMat4 */
/*!***************************************!*\
  !*** ./src/lib/viewports/viewport.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_matrix__);\n/* harmony export (immutable) */ exports[\"b\"] = createMat4;\n// eslint-disable\n// View and Projection Matrix management\n\n// gl-matrix is a large dependency for a small module.\n// However since it is used by mapbox etc, it should already be present\n// in most target application bundles.\n\n\nvar IDENTITY = createMat4();\n\nvar Viewport = function Viewport(ref) {\n  if ( ref === void 0 ) ref = {};\n  var width = ref.width; if ( width === void 0 ) width = 1;\n  var height = ref.height; if ( height === void 0 ) height = 1;\n  var viewMatrix = ref.viewMatrix; if ( viewMatrix === void 0 ) viewMatrix = IDENTITY;\n  var projectionMatrix = ref.projectionMatrix; if ( projectionMatrix === void 0 ) projectionMatrix = IDENTITY;\n\n  // Silently allow apps to send in 0,0\n  this.width = width || 1;\n  this.height = height || 1;\n  this.scale = 1;\n\n  this.viewMatrix = viewMatrix;\n  this.projectionMatrix = projectionMatrix;\n\n  // Note: As usual, matrix operations should be applied in \"reverse\" order\n  // since vectors will be multiplied in from the right during transformation\n  var vpm = createMat4();\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(vpm, vpm, this.projectionMatrix);\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(vpm, vpm, this.viewMatrix);\n  this.viewProjectionMatrix = vpm;\n\n  // Calculate matrices and scales needed for projection\n  /**\n   * Builds matrices that converts preprojected lngLats to screen pixels\n   * and vice versa.\n   * Note: Currently returns bottom-left coordinates!\n   * Note: Starts with the GL projection matrix and adds steps to the\n   *     scale and translate that matrix onto the window.\n   * Note: WebGL controls clip space to screen projection with gl.viewport\n   *     and does not need this step.\n   */\n  var m = createMat4();\n\n  // Scale with viewport window's width and height in pixels\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].scale(m, m, [this.width, this.height, 1]);\n  // Convert to (0, 1)\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].translate(m, m, [0.5, 0.5, 0]);\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].scale(m, m, [0.5, 0.5, 1]);\n  // Project to clip space (-1, 1)\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(m, m, this.viewProjectionMatrix);\n\n  var mInverse = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].invert(createMat4(), m);\n  if (!mInverse) {\n    throw new Error('Pixel project matrix not invertible');\n  }\n\n  this.pixelProjectionMatrix = m;\n  this.pixelUnprojectionMatrix = mInverse;\n\n  this.project = this.project.bind(this);\n  this.unproject = this.unproject.bind(this);\n  this.projectFlat = this.projectFlat.bind(this);\n  this.unprojectFlat = this.unprojectFlat.bind(this);\n  this.getMatrices = this.getMatrices.bind(this);\n};\n/* eslint-enable complexity */\n\n// Two viewports are equal if width and height are identical, and if\n// their view and projection matrices are (approximately) equal.\nViewport.prototype.equals = function equals (viewport) {\n  if (!(viewport instanceof Viewport)) {\n    return false;\n  }\n\n  return viewport.width === this.width && viewport.height === this.height && __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].equals(viewport.projectionMatrix, this.projectionMatrix) && __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].equals(viewport.viewMatrix, this.viewMatrix);\n};\n\n/**\n * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n * using viewport projection parameters\n * - [longitude, latitude] to [x, y]\n * - [longitude, latitude, Z] => [x, y, z]\n * Note: By default, returns top-left coordinates for canvas/SVG type render\n *\n * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n * @param {Object} opts - options\n * @param {Object} opts.topLeft=true - Whether projected coords are top left\n * @return {Array} - [x, y] or [x, y, z] in top left coords\n */\nViewport.prototype.project = function project (xyz, ref) {\n    if ( ref === void 0 ) ref = {};\n    var topLeft = ref.topLeft; if ( topLeft === void 0 ) topLeft = false;\n\n  var Z = xyz[2] || 0;\n  // console.error('projecting non-linear', xyz);\n  var ref$1 = this.projectFlat(xyz);\n    var X = ref$1[0];\n    var Y = ref$1[1];\n  var v = [X, Y, Z, 1];\n  // console.error('projecting linear', v);\n  // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].transformMat4(v, v, this.pixelProjectionMatrix);\n  // Divide by w\n  var scale = 1 / v[3];\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].multiply(v, v, [scale, scale, scale, scale]);\n  // console.error('projected', v);\n  var x = v[0];\n    var z = v[2];\n  var y = topLeft ? this.height - v[1] : v[1];\n  return xyz.length === 2 ? [x, y] : [x, y, z];\n};\n\n/**\n * Unproject pixel coordinates on screen onto world coordinates,\n * (possibly [lon, lat]) on map.\n * - [x, y] => [lng, lat]\n * - [x, y, z] => [lng, lat, Z]\n * @param {Array} xyz -\n * @return {Array} - [lng, lat, Z] or [X, Y, Z]\n */\nViewport.prototype.unproject = function unproject (xyz, ref) {\n    if ( ref === void 0 ) ref = {};\n    var topLeft = ref.topLeft; if ( topLeft === void 0 ) topLeft = false;\n\n  // console.error('unprojecting linear', xyz);\n  var x = xyz[0]; if ( x === void 0 ) x = 0;\n    var y = xyz[1]; if ( y === void 0 ) y = 0;\n    var z = xyz[2]; if ( z === void 0 ) z = 0;\n  // const y2 = topLeft ? this.height - 1 - y : y;\n  var y2 = topLeft ? this.height - y : y;\n  var v = [x, y2, z, 1];\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].transformMat4(v, v, this.pixelUnprojectionMatrix);\n  var scale = 1 / v[3];\n  __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].multiply(v, v, [scale, scale, scale, scale]);\n  // console.error('unprojecting non-linear', v);\n  var ref$1 = this.unprojectFlat(v);\n    var x0 = ref$1[0];\n    var y0 = ref$1[1];\n  // console.error('unprojected', [x0, y0]);\n  var z0 = v[2];\n  return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];\n};\n\n// NON_LINEAR PROJECTION HOOKS\n// Used for web meractor projection\n\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n * @param {Array} lngLat - [lng, lat] coordinates\n * Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\nViewport.prototype.projectFlat = function projectFlat (ref, scale) {\n    var x = ref[0];\n    var y = ref[1];\n    if ( scale === void 0 ) scale = this.scale;\n\n  return (ref$1 = this)._projectFlat.apply(ref$1, arguments);\n    var ref$1;\n};\n\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n * @param {object|Vector} xy - object with {x,y} members\n *representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n * Has toArray method if you need a GeoJSON Array.\n * Per cartographic tradition, lat and lon are specified as degrees.\n */\nViewport.prototype.unprojectFlat = function unprojectFlat (xyz, scale) {\n    if ( scale === void 0 ) scale = this.scale;\n\n  return (ref = this)._unprojectFlat.apply(ref, arguments);\n    var ref;\n};\n\n// _projectFlat(xyz, scale = this.scale) {\n// return xyz;\n// }\n\n// _unprojectFlat(xyz, scale = this.scale) {\n// return xyz;\n// }\n\nViewport.prototype.getMatrices = function getMatrices (ref) {\n    if ( ref === void 0 ) ref = {};\n    var modelMatrix = ref.modelMatrix; if ( modelMatrix === void 0 ) modelMatrix = null;\n\n  var modelViewProjectionMatrix = this.viewProjectionMatrix;\n  var pixelProjectionMatrix = this.pixelProjectionMatrix;\n  var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;\n\n  if (modelMatrix) {\n    modelViewProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply([], this.viewProjectionMatrix, modelMatrix);\n    pixelProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply([], this.pixelProjectionMatrix, modelMatrix);\n    pixelUnprojectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].invert([], pixelProjectionMatrix);\n  }\n\n  var matrices = Object.assign({\n    modelViewProjectionMatrix: modelViewProjectionMatrix,\n    viewProjectionMatrix: this.viewProjectionMatrix,\n    viewMatrix: this.viewMatrix,\n    projectionMatrix: this.projectionMatrix,\n\n    // project/unproject between pixels and world\n    pixelProjectionMatrix: pixelProjectionMatrix,\n    pixelUnprojectionMatrix: pixelUnprojectionMatrix,\n\n    width: this.width,\n    height: this.height,\n    scale: this.scale\n  },\n\n  // Subclass can add additional params\n  // TODO - Fragile: better to make base Viewport class aware of all params\n  this._getParams());\n\n  return matrices;\n};\n\n// INTERNAL METHODS\n\n// Can be subclassed to add additional fields to `getMatrices`\nViewport.prototype._getParams = function _getParams () {\n  return {};\n};\n\n/* harmony default export */ exports[\"a\"] = Viewport;\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL3ZpZXdwb3J0cy92aWV3cG9ydC5qcz9iODkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlXG4vLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBtYW5hZ2VtZW50XG5cbi8vIGdsLW1hdHJpeCBpcyBhIGxhcmdlIGRlcGVuZGVuY3kgZm9yIGEgc21hbGwgbW9kdWxlLlxuLy8gSG93ZXZlciBzaW5jZSBpdCBpcyB1c2VkIGJ5IG1hcGJveCBldGMsIGl0IHNob3VsZCBhbHJlYWR5IGJlIHByZXNlbnRcbi8vIGluIG1vc3QgdGFyZ2V0IGFwcGxpY2F0aW9uIGJ1bmRsZXMuXG5pbXBvcnQgeyBtYXQ0LCB2ZWM0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgSURFTlRJVFkgPSBjcmVhdGVNYXQ0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogTWFuYWdlcyBjb29yZGluYXRlIHN5c3RlbSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGRlY2suZ2wuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBXaW5kb3cgd2lkdGgvaGVpZ2h0IGluIHBpeGVscyAoZm9yIHBpeGVsIHByb2plY3Rpb24pXG4gICAgd2lkdGggPSAxLFxuICAgIGhlaWdodCA9IDEsXG4gICAgLy8gRGVzY1xuICAgIHZpZXdNYXRyaXggPSBJREVOVElUWSxcbiAgICBwcm9qZWN0aW9uTWF0cml4ID0gSURFTlRJVFlcbiAgfSA9IHt9KSB7XG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMFxuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXggPSB2aWV3TWF0cml4O1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgaW4gXCJyZXZlcnNlXCIgb3JkZXJcbiAgICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBpbiBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuXG4gICAgLy8gU2NhbGUgd2l0aCB2aWV3cG9ydCB3aW5kb3cncyB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAxXSk7XG4gICAgLy8gQ29udmVydCB0byAoMCwgMSlcbiAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMC41LCAwLjUsIDBdKTtcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFswLjUsIDAuNSwgMV0pO1xuICAgIC8vIFByb2plY3QgdG8gY2xpcCBzcGFjZSAoLTEsIDEpXG4gICAgbWF0NC5tdWx0aXBseShtLCBtLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgIGNvbnN0IG1JbnZlcnNlID0gbWF0NC5pbnZlcnQoY3JlYXRlTWF0NCgpLCBtKTtcbiAgICBpZiAoIW1JbnZlcnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGVsIHByb2plY3QgbWF0cml4IG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtSW52ZXJzZTtcblxuICAgIHRoaXMucHJvamVjdCA9IHRoaXMucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0ID0gdGhpcy51bnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3RGbGF0ID0gdGhpcy5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0RmxhdCA9IHRoaXMudW5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0TWF0cmljZXMgPSB0aGlzLmdldE1hdHJpY2VzLmJpbmQodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLy8gVHdvIHZpZXdwb3J0cyBhcmUgZXF1YWwgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgaWRlbnRpY2FsLCBhbmQgaWZcbiAgLy8gdGhlaXIgdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaWNlcyBhcmUgKGFwcHJveGltYXRlbHkpIGVxdWFsLlxuICBlcXVhbHModmlld3BvcnQpIHtcbiAgICBpZiAoISh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3cG9ydC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJiB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCkgJiYgbWF0NC5lcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyB4eXogKHBvc3NpYmx5IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpIHRvIHBpeGVsIGNvb3JkaW5hdGVzIGluIHdpbmRvd1xuICAgKiB1c2luZyB2aWV3cG9ydCBwcm9qZWN0aW9uIHBhcmFtZXRlcnNcbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gW3gsIHldXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIFpdID0+IFt4LCB5LCB6XVxuICAgKiBOb3RlOiBCeSBkZWZhdWx0LCByZXR1cm5zIHRvcC1sZWZ0IGNvb3JkaW5hdGVzIGZvciBjYW52YXMvU1ZHIHR5cGUgcmVuZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdFogLSBbbG5nLCBsYXRdIG9yIFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gW3gsIHldIG9yIFt4LCB5LCB6XSBpbiB0b3AgbGVmdCBjb29yZHNcbiAgICovXG4gIHByb2plY3QoeHl6LCB7IHRvcExlZnQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBaID0geHl6WzJdIHx8IDA7XG4gICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGluZyBub24tbGluZWFyJywgeHl6KTtcbiAgICBjb25zdCBbWCwgWV0gPSB0aGlzLnByb2plY3RGbGF0KHh5eik7XG4gICAgY29uc3QgdiA9IFtYLCBZLCBaLCAxXTtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdwcm9qZWN0aW5nIGxpbmVhcicsIHYpO1xuICAgIC8vIHZlYzQuc3ViKHYsIHYsIFt0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgMCwgMF0pO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2LCB2LCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgLy8gRGl2aWRlIGJ5IHdcbiAgICBjb25zdCBzY2FsZSA9IDEgLyB2WzNdO1xuICAgIHZlYzQubXVsdGlwbHkodiwgdiwgW3NjYWxlLCBzY2FsZSwgc2NhbGUsIHNjYWxlXSk7XG4gICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGVkJywgdik7XG4gICAgY29uc3QgW3gsLCB6XSA9IHY7XG4gICAgY29uc3QgeSA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHZbMV0gOiB2WzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gsIHldIDogW3gsIHksIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCBwaXhlbCBjb29yZGluYXRlcyBvbiBzY3JlZW4gb250byB3b3JsZCBjb29yZGluYXRlcyxcbiAgICogKHBvc3NpYmx5IFtsb24sIGxhdF0pIG9uIG1hcC5cbiAgICogLSBbeCwgeV0gPT4gW2xuZywgbGF0XVxuICAgKiAtIFt4LCB5LCB6XSA9PiBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFtsbmcsIGxhdCwgWl0gb3IgW1gsIFksIFpdXG4gICAqL1xuICB1bnByb2plY3QoeHl6LCB7IHRvcExlZnQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCd1bnByb2plY3RpbmcgbGluZWFyJywgeHl6KTtcbiAgICBjb25zdCBbeCA9IDAsIHkgPSAwLCB6ID0gMF0gPSB4eXo7XG4gICAgLy8gY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSAxIC0geSA6IHk7XG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB5IDogeTtcbiAgICBjb25zdCB2ID0gW3gsIHkyLCB6LCAxXTtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodiwgdiwgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gdlszXTtcbiAgICB2ZWM0Lm11bHRpcGx5KHYsIHYsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3VucHJvamVjdGluZyBub24tbGluZWFyJywgdik7XG4gICAgY29uc3QgW3gwLCB5MF0gPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgLy8gY29uc29sZS5lcnJvcigndW5wcm9qZWN0ZWQnLCBbeDAsIHkwXSk7XG4gICAgY29uc3QgWywsIHowXSA9IHY7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeDAsIHkwXSA6IFt4MCwgeTAsIHowXTtcbiAgfVxuXG4gIC8vIE5PTl9MSU5FQVIgUFJPSkVDVElPTiBIT09LU1xuICAvLyBVc2VkIGZvciB3ZWIgbWVyYWN0b3IgcHJvamVjdGlvblxuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb2plY3RGbGF0KFt4LCB5XSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2plY3RGbGF0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gICAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gICAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAgICovXG4gIHVucHJvamVjdEZsYXQoeHl6LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdW5wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gX3Byb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gIC8vICAgcmV0dXJuIHh5ejtcbiAgLy8gfVxuXG4gIC8vIF91bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gIC8vICAgcmV0dXJuIHh5ejtcbiAgLy8gfVxuXG4gIGdldE1hdHJpY2VzKHsgbW9kZWxNYXRyaXggPSBudWxsIH0gPSB7fSkge1xuICAgIGxldCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXg7XG4gICAgbGV0IHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeDtcblxuICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBtb2RlbE1hdHJpeCk7XG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1hdDQuaW52ZXJ0KFtdLCBwaXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdHJpY2VzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXg6IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3TWF0cml4OiB0aGlzLnZpZXdNYXRyaXgsXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIC8vIHByb2plY3QvdW5wcm9qZWN0IGJldHdlZW4gcGl4ZWxzIGFuZCB3b3JsZFxuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgfSxcblxuICAgIC8vIFN1YmNsYXNzIGNhbiBhZGQgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAvLyBUT0RPIC0gRnJhZ2lsZTogYmV0dGVyIHRvIG1ha2UgYmFzZSBWaWV3cG9ydCBjbGFzcyBhd2FyZSBvZiBhbGwgcGFyYW1zXG4gICAgdGhpcy5fZ2V0UGFyYW1zKCkpO1xuXG4gICAgcmV0dXJuIG1hdHJpY2VzO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIENhbiBiZSBzdWJjbGFzc2VkIHRvIGFkZCBhZGRpdGlvbmFsIGZpZWxkcyB0byBgZ2V0TWF0cmljZXNgXG4gIF9nZXRQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8vIEhlbHBlciwgYXZvaWRzIGxvdy1wcmVjaXNpb24gMzIgYml0IG1hdHJpY2VzIGZyb20gZ2wtbWF0cml4IG1hdDQuY3JlYXRlKClcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXQ0KCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3ZpZXdwb3J0cy92aWV3cG9ydC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQ0E7QUFMQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/* exports provided: Effect, EffectManager */
/* exports used: EffectManager, Effect */
/*!***************************************!*\
  !*** ./src/experimental/lib/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__effect__ = __webpack_require__(/*! ./effect */ 37);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__effect__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effect_manager__ = __webpack_require__(/*! ./effect-manager */ 36);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_1__effect_manager__[\"a\"]; });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvZXhwZXJpbWVudGFsL2xpYi9pbmRleC5qcz8zZGU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgRWZmZWN0IH0gZnJvbSAnLi9lZmZlY3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFZmZlY3RNYW5hZ2VyIH0gZnJvbSAnLi9lZmZlY3QtbWFuYWdlcic7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9leHBlcmltZW50YWwvbGliL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/* exports provided: default */
/* exports used: default */
/*!*******************************!*\
  !*** ./src/react/autobind.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ exports[\"a\"] = autobind;\nvar PREDEFINED = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];\n\n/**\n * Binds the \"this\" argument of all functions on a class instance to the instance\n * @param {Object} obj - class instance (typically a react component)\n */\nfunction autobind(obj) {\n  var proto = Object.getPrototypeOf(obj);\n  var propNames = Object.getOwnPropertyNames(proto);\n  var loop = function () {\n    var key = list[i];\n\n    if (typeof obj[key] === 'function') {\n      if (!PREDEFINED.find(function (name) { return key === name; })) {\n        obj[key] = obj[key].bind(obj);\n      }\n    }\n  };\n\n  for (var i = 0, list = propNames; i < list.length; i += 1) loop();\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3JlYWN0L2F1dG9iaW5kLmpzPzA5OTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUFJFREVGSU5FRCA9IFsnY29uc3RydWN0b3InLCAncmVuZGVyJywgJ2NvbXBvbmVudFdpbGxNb3VudCcsICdjb21wb25lbnREaWRNb3VudCcsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsICdjb21wb25lbnRXaWxsVXBkYXRlJywgJ2NvbXBvbmVudERpZFVwZGF0ZScsICdjb21wb25lbnRXaWxsVW5tb3VudCddO1xuXG4vKipcbiAqIEJpbmRzIHRoZSBcInRoaXNcIiBhcmd1bWVudCBvZiBhbGwgZnVuY3Rpb25zIG9uIGEgY2xhc3MgaW5zdGFuY2UgdG8gdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gY2xhc3MgaW5zdGFuY2UgKHR5cGljYWxseSBhIHJlYWN0IGNvbXBvbmVudClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2JpbmQob2JqKSB7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGNvbnN0IHByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgcHJvcE5hbWVzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCFQUkVERUZJTkVELmZpbmQobmFtZSA9PiBrZXkgPT09IG5hbWUpKSB7XG4gICAgICAgIG9ialtrZXldID0gb2JqW2tleV0uYmluZChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVhY3QvYXV0b2JpbmQuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/* exports provided: default */
/* exports used: default */
/*!*****************************!*\
  !*** ./src/react/deckgl.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__autobind__ = __webpack_require__(/*! ./autobind */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_renderer__ = __webpack_require__(/*! ./webgl-renderer */ 57);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib__ = __webpack_require__(/*! ../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__experimental__ = __webpack_require__(/*! ../experimental */ 35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_viewports__ = __webpack_require__(/*! ../lib/viewports */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_utils__ = __webpack_require__(/*! ../lib/utils */ 7);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n// import {Viewport, WebMercatorViewport} from 'viewport-mercator-project';\n\n\n\nfunction noop() {}\n\nvar propTypes = {\n  id: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].string,\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  layers: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_3__lib__[\"b\" /* Layer */])).isRequired,\n  effects: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_4__experimental__[\"a\" /* Effect */])),\n  gl: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  debug: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].bool,\n  viewport: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_6__lib_viewports__[\"b\" /* Viewport */]),\n  onWebGLInitialized: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onLayerClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onLayerHover: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nvar defaultProps = {\n  id: 'deckgl-overlay',\n  debug: false,\n  gl: null,\n  effects: [],\n  onWebGLInitialized: noop,\n  onLayerClick: noop,\n  onLayerHover: noop\n};\n\nvar DeckGL = (function (superclass) {\n  function DeckGL(props) {\n    superclass.call(this, props);\n    this.state = {};\n    this.needsRedraw = true;\n    this.layerManager = null;\n    this.effectManager = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__autobind__[\"a\" /* default */])(this);\n  }\n\n  if ( superclass ) DeckGL.__proto__ = superclass;\n  DeckGL.prototype = Object.create( superclass && superclass.prototype );\n  DeckGL.prototype.constructor = DeckGL;\n\n  DeckGL.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {\n    this._updateLayers(nextProps);\n  };\n\n  DeckGL.prototype._updateLayers = function _updateLayers (nextProps) {\n    var width = nextProps.width;\n    var height = nextProps.height;\n    var latitude = nextProps.latitude;\n    var longitude = nextProps.longitude;\n    var zoom = nextProps.zoom;\n    var pitch = nextProps.pitch;\n    var bearing = nextProps.bearing;\n    var altitude = nextProps.altitude;\n    var viewport = nextProps.viewport;\n\n    // If Viewport is not supplied, create one from mercator props\n    viewport = viewport || new __WEBPACK_IMPORTED_MODULE_6__lib_viewports__[\"a\" /* WebMercatorViewport */]({\n      width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing, altitude: altitude\n    });\n\n    if (this.layerManager) {\n      this.layerManager.setViewport(viewport).updateLayers({ newLayers: nextProps.layers });\n    }\n  };\n\n  DeckGL.prototype._onRendererInitialized = function _onRendererInitialized (ref) {\n    var this$1 = this;\n    var gl = ref.gl;\n    var canvas = ref.canvas;\n\n    gl.enable(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].BLEND);\n    gl.blendFunc(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].SRC_ALPHA, __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].ONE_MINUS_SRC_ALPHA);\n\n    this.props.onWebGLInitialized(gl);\n\n    // Note: avoid React setState due GL animation loop / setState timing issue\n    this.layerManager = new __WEBPACK_IMPORTED_MODULE_3__lib__[\"d\" /* LayerManager */]({ gl: gl });\n    this.effectManager = new __WEBPACK_IMPORTED_MODULE_4__experimental__[\"b\" /* EffectManager */]({ gl: gl, layerManager: this.layerManager });\n    for (var i = 0, list = this$1.props.effects; i < list.length; i += 1) {\n      var effect = list[i];\n\n      this$1.effectManager.addEffect(effect);\n    }\n    this._updateLayers(this.props);\n\n    // Check if a mouse event has been specified and that at least one of the layers is pickable\n    var hasEvent = this.props.onLayerClick !== noop || this.props.onLayerHover !== noop;\n    var hasPickableLayer = this.layerManager.layers.map(function (l) { return l.props.pickable; }).includes(true);\n    if (hasEvent && !hasPickableLayer) {\n      __WEBPACK_IMPORTED_MODULE_7__lib_utils__[\"a\" /* log */].once(0, 'You have supplied a mouse event handler but none of your layers got the `pickable` flag.');\n    }\n\n    this.events = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"addEvents\"])(canvas, {\n      cacheSize: false,\n      cachePosition: false,\n      centerOrigin: false,\n      onClick: this._onClick,\n      onMouseMove: this._onMouseMove\n    });\n  };\n\n  // Route events to layers\n  DeckGL.prototype._onClick = function _onClick (event) {\n    var x = event.x;\n    var y = event.y;\n    var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, mode: 'click' });\n    var firstInfo = selectedInfos.find(function (info) { return info.index >= 0; });\n    // Event.event holds the original MouseEvent object\n    this.props.onLayerClick(firstInfo, selectedInfos, event.event);\n  };\n\n  // Route events to layers\n  DeckGL.prototype._onMouseMove = function _onMouseMove (event) {\n    var x = event.x;\n    var y = event.y;\n    var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, mode: 'hover' });\n    var firstInfo = selectedInfos.find(function (info) { return info.index >= 0; });\n    // Event.event holds the original MouseEvent object\n    this.props.onLayerHover(firstInfo, selectedInfos, event.event);\n  };\n\n  DeckGL.prototype._onRenderFrame = function _onRenderFrame (ref) {\n    var gl = ref.gl;\n\n    if (!this.layerManager.needsRedraw({ clearRedrawFlags: true })) {\n      return;\n    }\n    // clear depth and color buffers\n    gl.clear(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n\n    this.effectManager.preDraw();\n\n    this.layerManager.drawLayers();\n\n    this.effectManager.draw();\n  };\n\n  DeckGL.prototype.render = function render () {\n    var ref = this.props;\n    var width = ref.width;\n    var height = ref.height;\n    var gl = ref.gl;\n    var debug = ref.debug;\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"])(__WEBPACK_IMPORTED_MODULE_2__webgl_renderer__[\"a\" /* default */], Object.assign({}, this.props, {\n      width: width,\n      height: height,\n      gl: gl,\n      debug: debug,\n      viewport: { x: 0, y: 0, width: width, height: height },\n      onRendererInitialized: this._onRendererInitialized,\n      onNeedRedraw: this._onNeedRedraw,\n      onRenderFrame: this._onRenderFrame,\n      onMouseMove: this._onMouseMove,\n      onClick: this._onClick\n    }));\n  };\n\n  return DeckGL;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));\n\n/* harmony default export */ exports[\"a\"] = DeckGL;\n\nDeckGL.propTypes = propTypes;\nDeckGL.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3JlYWN0L2RlY2tnbC5qcz9hMWM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5pbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vYXV0b2JpbmQnO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi93ZWJnbC1yZW5kZXJlcic7XG5pbXBvcnQgeyBMYXllck1hbmFnZXIsIExheWVyIH0gZnJvbSAnLi4vbGliJztcbmltcG9ydCB7IEVmZmVjdE1hbmFnZXIsIEVmZmVjdCB9IGZyb20gJy4uL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBHTCwgYWRkRXZlbnRzIH0gZnJvbSAnbHVtYS5nbCc7XG4vLyBpbXBvcnQge1ZpZXdwb3J0LCBXZWJNZXJjYXRvclZpZXdwb3J0fSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IFZpZXdwb3J0LCBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAnLi4vbGliL3ZpZXdwb3J0cyc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi9saWIvdXRpbHMnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxheWVyczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoTGF5ZXIpKS5pc1JlcXVpcmVkLFxuICBlZmZlY3RzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuaW5zdGFuY2VPZihFZmZlY3QpKSxcbiAgZ2w6IFByb3BUeXBlcy5vYmplY3QsXG4gIGRlYnVnOiBQcm9wVHlwZXMuYm9vbCxcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKFZpZXdwb3J0KSxcbiAgb25XZWJHTEluaXRpYWxpemVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckhvdmVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBpZDogJ2RlY2tnbC1vdmVybGF5JyxcbiAgZGVidWc6IGZhbHNlLFxuICBnbDogbnVsbCxcbiAgZWZmZWN0czogW10sXG4gIG9uV2ViR0xJbml0aWFsaXplZDogbm9vcCxcbiAgb25MYXllckNsaWNrOiBub29wLFxuICBvbkxheWVySG92ZXI6IG5vb3Bcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY2tHTCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmxheWVyTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbnVsbDtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJzKG5leHRQcm9wcyk7XG4gIH1cblxuICBfdXBkYXRlTGF5ZXJzKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgcGl0Y2gsIGJlYXJpbmcsIGFsdGl0dWRlIH0gPSBuZXh0UHJvcHM7XG4gICAgbGV0IHsgdmlld3BvcnQgfSA9IG5leHRQcm9wcztcblxuICAgIC8vIElmIFZpZXdwb3J0IGlzIG5vdCBzdXBwbGllZCwgY3JlYXRlIG9uZSBmcm9tIG1lcmNhdG9yIHByb3BzXG4gICAgdmlld3BvcnQgPSB2aWV3cG9ydCB8fCBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgICB3aWR0aCwgaGVpZ2h0LCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCwgYmVhcmluZywgYWx0aXR1ZGVcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXIuc2V0Vmlld3BvcnQodmlld3BvcnQpLnVwZGF0ZUxheWVycyh7IG5ld0xheWVyczogbmV4dFByb3BzLmxheWVycyB9KTtcbiAgICB9XG4gIH1cblxuICBfb25SZW5kZXJlckluaXRpYWxpemVkKHsgZ2wsIGNhbnZhcyB9KSB7XG4gICAgZ2wuZW5hYmxlKEdMLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmMoR0wuU1JDX0FMUEhBLCBHTC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIHRoaXMucHJvcHMub25XZWJHTEluaXRpYWxpemVkKGdsKTtcblxuICAgIC8vIE5vdGU6IGF2b2lkIFJlYWN0IHNldFN0YXRlIGR1ZSBHTCBhbmltYXRpb24gbG9vcCAvIHNldFN0YXRlIHRpbWluZyBpc3N1ZVxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyID0gbmV3IExheWVyTWFuYWdlcih7IGdsIH0pO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlciA9IG5ldyBFZmZlY3RNYW5hZ2VyKHsgZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXIgfSk7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5wcm9wcy5lZmZlY3RzKSB7XG4gICAgICB0aGlzLmVmZmVjdE1hbmFnZXIuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUxheWVycyh0aGlzLnByb3BzKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbW91c2UgZXZlbnQgaGFzIGJlZW4gc3BlY2lmaWVkIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgbGF5ZXJzIGlzIHBpY2thYmxlXG4gICAgY29uc3QgaGFzRXZlbnQgPSB0aGlzLnByb3BzLm9uTGF5ZXJDbGljayAhPT0gbm9vcCB8fCB0aGlzLnByb3BzLm9uTGF5ZXJIb3ZlciAhPT0gbm9vcDtcbiAgICBjb25zdCBoYXNQaWNrYWJsZUxheWVyID0gdGhpcy5sYXllck1hbmFnZXIubGF5ZXJzLm1hcChsID0+IGwucHJvcHMucGlja2FibGUpLmluY2x1ZGVzKHRydWUpO1xuICAgIGlmIChoYXNFdmVudCAmJiAhaGFzUGlja2FibGVMYXllcikge1xuICAgICAgbG9nLm9uY2UoMCwgJ1lvdSBoYXZlIHN1cHBsaWVkIGEgbW91c2UgZXZlbnQgaGFuZGxlciBidXQgbm9uZSBvZiB5b3VyIGxheWVycyBnb3QgdGhlIGBwaWNrYWJsZWAgZmxhZy4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50cyA9IGFkZEV2ZW50cyhjYW52YXMsIHtcbiAgICAgIGNhY2hlU2l6ZTogZmFsc2UsXG4gICAgICBjYWNoZVBvc2l0aW9uOiBmYWxzZSxcbiAgICAgIGNlbnRlck9yaWdpbjogZmFsc2UsXG4gICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrLFxuICAgICAgb25Nb3VzZU1vdmU6IHRoaXMuX29uTW91c2VNb3ZlXG4gICAgfSk7XG4gIH1cblxuICAvLyBSb3V0ZSBldmVudHMgdG8gbGF5ZXJzXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBldmVudDtcbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5sYXllck1hbmFnZXIucGlja0xheWVyKHsgeCwgeSwgbW9kZTogJ2NsaWNrJyB9KTtcbiAgICBjb25zdCBmaXJzdEluZm8gPSBzZWxlY3RlZEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmluZGV4ID49IDApO1xuICAgIC8vIEV2ZW50LmV2ZW50IGhvbGRzIHRoZSBvcmlnaW5hbCBNb3VzZUV2ZW50IG9iamVjdFxuICAgIHRoaXMucHJvcHMub25MYXllckNsaWNrKGZpcnN0SW5mbywgc2VsZWN0ZWRJbmZvcywgZXZlbnQuZXZlbnQpO1xuICB9XG5cbiAgLy8gUm91dGUgZXZlbnRzIHRvIGxheWVyc1xuICBfb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHNlbGVjdGVkSW5mb3MgPSB0aGlzLmxheWVyTWFuYWdlci5waWNrTGF5ZXIoeyB4LCB5LCBtb2RlOiAnaG92ZXInIH0pO1xuICAgIGNvbnN0IGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChpbmZvID0+IGluZm8uaW5kZXggPj0gMCk7XG4gICAgLy8gRXZlbnQuZXZlbnQgaG9sZHMgdGhlIG9yaWdpbmFsIE1vdXNlRXZlbnQgb2JqZWN0XG4gICAgdGhpcy5wcm9wcy5vbkxheWVySG92ZXIoZmlyc3RJbmZvLCBzZWxlY3RlZEluZm9zLCBldmVudC5ldmVudCk7XG4gIH1cblxuICBfb25SZW5kZXJGcmFtZSh7IGdsIH0pIHtcbiAgICBpZiAoIXRoaXMubGF5ZXJNYW5hZ2VyLm5lZWRzUmVkcmF3KHsgY2xlYXJSZWRyYXdGbGFnczogdHJ1ZSB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjbGVhciBkZXB0aCBhbmQgY29sb3IgYnVmZmVyc1xuICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgIHRoaXMuZWZmZWN0TWFuYWdlci5wcmVEcmF3KCk7XG5cbiAgICB0aGlzLmxheWVyTWFuYWdlci5kcmF3TGF5ZXJzKCk7XG5cbiAgICB0aGlzLmVmZmVjdE1hbmFnZXIuZHJhdygpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZ2wsIGRlYnVnIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV2ViR0xSZW5kZXJlciwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBnbCxcbiAgICAgIGRlYnVnLFxuICAgICAgdmlld3BvcnQ6IHsgeDogMCwgeTogMCwgd2lkdGgsIGhlaWdodCB9LFxuICAgICAgb25SZW5kZXJlckluaXRpYWxpemVkOiB0aGlzLl9vblJlbmRlcmVySW5pdGlhbGl6ZWQsXG4gICAgICBvbk5lZWRSZWRyYXc6IHRoaXMuX29uTmVlZFJlZHJhdyxcbiAgICAgIG9uUmVuZGVyRnJhbWU6IHRoaXMuX29uUmVuZGVyRnJhbWUsXG4gICAgICBvbk1vdXNlTW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICBvbkNsaWNrOiB0aGlzLl9vbkNsaWNrXG4gICAgfSkpO1xuICB9XG59XG5cbkRlY2tHTC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5EZWNrR0wuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcmVhY3QvZGVja2dsLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFHQTtBQUNBO0FBeUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 12 */
/* unknown exports provided */
/*!********************************************!*\
  !*** ./src/lib/viewports/flat-viewport.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable */\n\n\nvar PI = Math.PI;\nvar pow = Math.pow;\nvar tan = Math.tan;\nvar log = Math.log;\nvar atan = Math.atan;\nvar exp = Math.exp;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nfunction radians(value) {\n  return value * DEGREES_TO_RADIANS;\n}\nfunction degrees(value) {\n  return value * RADIANS_TO_DEGREES;\n}\n// see: https://en.wikipedia.org/wiki/Web_Mercator\nfunction ViewportMercator(opts) {\n  if ( opts === void 0 ) opts = {};\n\n  var scale = (opts.tileSize || 512) * 0.5 / PI * pow(2, opts.zoom);\n  var lamda = radians(opts.longitude);\n  var phi = radians(opts.latitude);\n  var x = scale * (lamda + PI);\n  var y = scale * (PI - log(tan(PI * 0.25 + phi * 0.5)));\n  var offsetX = opts.width * 0.5 - x;\n  var offsetY = opts.height * 0.5 - y;\n\n  function project(lnglat2) {\n    var lamda2 = lnglat2[0] * DEGREES_TO_RADIANS;\n    var phi2 = lnglat2[1] * DEGREES_TO_RADIANS;\n    var x2 = scale * (lamda2 + PI);\n    var y2 = scale * (PI - log(tan(PI * 0.25 + phi2 * 0.5)));\n    return [x2 + offsetX, y2 + offsetY];\n  }\n\n  function unproject(xy) {\n    var x2 = xy[0] - offsetX;\n    var y2 = xy[1] - offsetY;\n    var lamda2 = x2 / scale - PI;\n    var phi2 = 2 * (atan(exp(PI - y2 / scale)) - PI * 0.25);\n    return [degrees(lamda2), degrees(phi2)];\n  }\n\n  function contains(lnglat2) {\n    var xy = project(lnglat2);\n    var x = xy[0];\n    var y = xy[1];\n    return x >= 0 && x <= opts.width && y >= 0 && y <= opts.height;\n  }\n\n  return { project: project, unproject: unproject, contains: contains };\n}\n\nmodule.exports = ViewportMercator;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi92aWV3cG9ydHMvZmxhdC12aWV3cG9ydC5qcz8wMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIHRhbiA9IE1hdGgudGFuO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIGF0YW4gPSBNYXRoLmF0YW47XG52YXIgZXhwID0gTWF0aC5leHA7XG52YXIgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG52YXIgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5mdW5jdGlvbiByYWRpYW5zKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAqIERFR1JFRVNfVE9fUkFESUFOUztcbn1cbmZ1bmN0aW9uIGRlZ3JlZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICogUkFESUFOU19UT19ERUdSRUVTO1xufVxuLy8gc2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWVyY2F0b3JcbmZ1bmN0aW9uIFZpZXdwb3J0TWVyY2F0b3Iob3B0cyA9IHt9KSB7XG4gIHZhciBzY2FsZSA9IChvcHRzLnRpbGVTaXplIHx8IDUxMikgKiAwLjUgLyBQSSAqIHBvdygyLCBvcHRzLnpvb20pO1xuICB2YXIgbGFtZGEgPSByYWRpYW5zKG9wdHMubG9uZ2l0dWRlKTtcbiAgdmFyIHBoaSA9IHJhZGlhbnMob3B0cy5sYXRpdHVkZSk7XG4gIHZhciB4ID0gc2NhbGUgKiAobGFtZGEgKyBQSSk7XG4gIHZhciB5ID0gc2NhbGUgKiAoUEkgLSBsb2codGFuKFBJICogMC4yNSArIHBoaSAqIDAuNSkpKTtcbiAgdmFyIG9mZnNldFggPSBvcHRzLndpZHRoICogMC41IC0geDtcbiAgdmFyIG9mZnNldFkgPSBvcHRzLmhlaWdodCAqIDAuNSAtIHk7XG5cbiAgZnVuY3Rpb24gcHJvamVjdChsbmdsYXQyKSB7XG4gICAgdmFyIGxhbWRhMiA9IGxuZ2xhdDJbMF0gKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gICAgdmFyIHBoaTIgPSBsbmdsYXQyWzFdICogREVHUkVFU19UT19SQURJQU5TO1xuICAgIHZhciB4MiA9IHNjYWxlICogKGxhbWRhMiArIFBJKTtcbiAgICB2YXIgeTIgPSBzY2FsZSAqIChQSSAtIGxvZyh0YW4oUEkgKiAwLjI1ICsgcGhpMiAqIDAuNSkpKTtcbiAgICByZXR1cm4gW3gyICsgb2Zmc2V0WCwgeTIgKyBvZmZzZXRZXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucHJvamVjdCh4eSkge1xuICAgIHZhciB4MiA9IHh5WzBdIC0gb2Zmc2V0WDtcbiAgICB2YXIgeTIgPSB4eVsxXSAtIG9mZnNldFk7XG4gICAgdmFyIGxhbWRhMiA9IHgyIC8gc2NhbGUgLSBQSTtcbiAgICB2YXIgcGhpMiA9IDIgKiAoYXRhbihleHAoUEkgLSB5MiAvIHNjYWxlKSkgLSBQSSAqIDAuMjUpO1xuICAgIHJldHVybiBbZGVncmVlcyhsYW1kYTIpLCBkZWdyZWVzKHBoaTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKGxuZ2xhdDIpIHtcbiAgICB2YXIgeHkgPSBwcm9qZWN0KGxuZ2xhdDIpO1xuICAgIHZhciB4ID0geHlbMF07XG4gICAgdmFyIHkgPSB4eVsxXTtcbiAgICByZXR1cm4geCA+PSAwICYmIHggPD0gb3B0cy53aWR0aCAmJiB5ID49IDAgJiYgeSA8PSBvcHRzLmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7IHByb2plY3Q6IHByb2plY3QsIHVucHJvamVjdDogdW5wcm9qZWN0LCBjb250YWluczogY29udGFpbnMgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1lcmNhdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3ZpZXdwb3J0cy9mbGF0LXZpZXdwb3J0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/* exports provided: default, ViewportMercatorProject, FlatViewport, Viewport, PerspectiveViewport, OrthographicViewport, WebMercatorViewport */
/* exports used: WebMercatorViewport, Viewport */
/*!************************************!*\
  !*** ./src/lib/viewports/index.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flat_viewport__ = __webpack_require__(/*! ./flat-viewport */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flat_viewport___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flat_viewport__);\n/* unused harmony reexport default */\n/* unused harmony reexport ViewportMercatorProject */\n/* unused harmony reexport FlatViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport__ = __webpack_require__(/*! ./viewport */ 8);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_1__viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__perspective_viewport__ = __webpack_require__(/*! ./perspective-viewport */ 55);\n/* unused harmony reexport PerspectiveViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__orthographic_viewport__ = __webpack_require__(/*! ./orthographic-viewport */ 54);\n/* unused harmony reexport OrthographicViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__web_mercator_viewport__ = __webpack_require__(/*! ./web-mercator-viewport */ 56);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_4__web_mercator_viewport__[\"a\"]; });\n// Classic web-mercator-project\n\n\n\n\n// 3D viewports\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi92aWV3cG9ydHMvaW5kZXguanM/MzlmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDbGFzc2ljIHdlYi1tZXJjYXRvci1wcm9qZWN0XG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9mbGF0LXZpZXdwb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmlld3BvcnRNZXJjYXRvclByb2plY3QgfSBmcm9tICcuL2ZsYXQtdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGbGF0Vmlld3BvcnQgfSBmcm9tICcuL2ZsYXQtdmlld3BvcnQnO1xuXG4vLyAzRCB2aWV3cG9ydHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmlld3BvcnQgfSBmcm9tICcuL3ZpZXdwb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGVyc3BlY3RpdmVWaWV3cG9ydCB9IGZyb20gJy4vcGVyc3BlY3RpdmUtdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPcnRob2dyYXBoaWNWaWV3cG9ydCB9IGZyb20gJy4vb3J0aG9ncmFwaGljLXZpZXdwb3J0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgV2ViTWVyY2F0b3JWaWV3cG9ydCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXZpZXdwb3J0JztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi92aWV3cG9ydHMvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/* unknown exports provided */
/* exports used: default */
/*!*************************!*\
  !*** external "earcut" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_14__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJlYXJjdXRcIj81ZmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZWFyY3V0XCJcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 15 */
/* unknown exports provided */
/* exports used: default */
/*!*************************************!*\
  !*** external "lodash.flattendeep" ***!
  \*************************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_15__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJsb2Rhc2guZmxhdHRlbmRlZXBcIj81M2RhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xNV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibG9kYXNoLmZsYXR0ZW5kZWVwXCJcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 16 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/index.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__reflection_effect__ = __webpack_require__(/*! ./reflection-effect */ 34);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__reflection_effect__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2V4cGVyaW1lbnRhbC9lZmZlY3RzL3JlZmxlY3Rpb24tZWZmZWN0L2luZGV4LmpzPzc4YTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vcmVmbGVjdGlvbi1lZmZlY3QnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 17 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/index.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scatterplot_layer__ = __webpack_require__(/*! ./scatterplot-layer */ 41);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__scatterplot_layer__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL3NjYXR0ZXJwbG90LWxheWVyL2luZGV4LmpzPzg3Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vc2NhdHRlcnBsb3QtbGF5ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 18 */
/* exports provided: default */
/* exports used: default */
/*!**************************************!*\
  !*** ./src/lib/attribute-manager.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(/*! ./utils */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(/*! assert */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);\n/* eslint-disable guard-for-in */\n\n\n\nfunction noop() {}\n\nvar AttributeManager = function AttributeManager(ref) {\n  if ( ref === void 0 ) ref = {};\n  var id = ref.id; if ( id === void 0 ) id = 'attribute-manager';\n\n  this.id = id;\n  this.attributes = {};\n  this.allocedInstances = -1;\n  this.needsRedraw = true;\n  this.userData = {};\n\n  this.onUpdateStart = noop;\n  this.onUpdateEnd = noop;\n  this.onLog = this._defaultLog;\n\n  // For debugging sanity, prevent uninitialized members\n  Object.seal(this);\n};\n\n/**\n * Adds attributes\n * Takes a map of attribute descriptor objects\n * - keys are attribute names\n * - values are objects with attribute fields\n *\n * attribute.size - number of elements per object\n * attribute.updater - number of elements\n * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)\n * attribute.noAlloc=false - if this attribute should not be allocated\n *\n * @example\n * attributeManager.add({\n * positions: {size: 2, update: calculatePositions}\n * colors: {size: 3, update: calculateColors}\n * });\n *\n * @param {Object} attributes - attribute map (see above)\n * @param {Object} updaters - separate map of update functions (deprecated)\n */\nAttributeManager.prototype.add = function add (attributes, updaters) {\n    if ( updaters === void 0 ) updaters = {};\n\n  this._add(attributes, updaters);\n};\n\n// Marks an attribute for update\nAttributeManager.prototype.invalidate = function invalidate (attributeName) {\n  var ref = this;\n    var attributes = ref.attributes;\n  var attribute = attributes[attributeName];\n  if (!attribute) {\n    var message = \"invalidating non-existent attribute \" + attributeName + \" for \" + (this.id) + \"\\n\";\n    message += \"Valid attributes: \" + (Object.keys(attributes).join(', '));\n    __WEBPACK_IMPORTED_MODULE_2_assert___default()(attribute, message);\n  }\n  attribute.needsUpdate = true;\n  // For performance tuning\n  this.onLog(1, (\"invalidated attribute \" + attributeName + \" for \" + (this.id)));\n};\n\nAttributeManager.prototype.invalidateAll = function invalidateAll () {\n    var this$1 = this;\n\n  var ref = this;\n    var attributes = ref.attributes;\n  for (var attributeName in attributes) {\n    this$1.invalidate(attributeName);\n  }\n};\n\n/**\n * Ensure all attribute buffers are updated from props or data.\n *\n * Note: Any preallocated buffers in \"buffers\" matching registered attribute\n * names will be used. No update will happen in this case.\n * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.\n *\n * @param {Object} opts - options\n * @param {Object} opts.data - data (iterable object)\n * @param {Object} opts.numInstances - count of data\n * @param {Object} opts.buffers = {} - pre-allocated buffers\n * @param {Object} opts.props - passed to updaters\n * @param {Object} opts.context - Used as \"this\" context for updaters\n */\nAttributeManager.prototype.update = function update (ref) {\n    if ( ref === void 0 ) ref = {};\n    var data = ref.data;\n    var numInstances = ref.numInstances;\n    var buffers = ref.buffers; if ( buffers === void 0 ) buffers = {};\n    var props = ref.props; if ( props === void 0 ) props = {};\n    var context = ref.context; if ( context === void 0 ) context = {};\n    var ignoreUnknownAttributes = ref.ignoreUnknownAttributes; if ( ignoreUnknownAttributes === void 0 ) ignoreUnknownAttributes = false;\n\n  // First apply any application provided buffers\n  this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });\n  this._setExternalBuffers(buffers);\n\n  // Only initiate alloc/update (and logging) if actually needed\n  if (this._analyzeBuffers({ numInstances: numInstances })) {\n    this.onUpdateStart(this.id);\n    this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });\n    this.onUpdateEnd(this.id);\n  }\n};\n\n/**\n * Sets log functions to help trace or time attribute updates.\n * Default logging uses luma logger.\n *\n * Note that the app may not be in control of when update is called,\n * so hooks are provided for update start and end.\n *\n * @param {Object} [opts]\n * @param {String} [opts.onLog=] - called to print\n * @param {String} [opts.onUpdateStart=] - called before update() starts\n * @param {String} [opts.onUpdateEnd=] - called after update() ends\n */\nAttributeManager.prototype.setLogFunctions = function setLogFunctions (ref) {\n    if ( ref === void 0 ) ref = {};\n    var onLog = ref.onLog;\n    var onUpdateStart = ref.onUpdateStart;\n    var onUpdateEnd = ref.onUpdateEnd;\n\n  this.onLog = onLog !== undefined ? onLog : this.onLog;\n  this.onUpdateStart = onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;\n  this.onUpdateEnd = onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;\n};\n\n/**\n * Returns all attribute descriptors\n * Note: Format matches luma.gl Model/Program.setAttributes()\n * @return {Object} attributes - descriptors\n */\nAttributeManager.prototype.getAttributes = function getAttributes () {\n  return this.attributes;\n};\n\n/**\n * Returns changed attribute descriptors\n * This indicates which WebGLBuggers need to be updated\n * @return {Object} attributes - descriptors\n */\nAttributeManager.prototype.getChangedAttributes = function getChangedAttributes (ref) {\n    var clearChangedFlags = ref.clearChangedFlags; if ( clearChangedFlags === void 0 ) clearChangedFlags = false;\n\n  var ref$1 = this;\n    var attributes = ref$1.attributes;\n  var changedAttributes = {};\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n    if (attribute.changed) {\n      attribute.changed = attribute.changed && !clearChangedFlags;\n      changedAttributes[attributeName] = attribute;\n    }\n  }\n  return changedAttributes;\n};\n\n/**\n * Returns the redraw flag, optionally clearing it.\n * Redraw flag will be set if any attributes attributes changed since\n * flag was last cleared.\n *\n * @param {Object} [opts]\n * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag\n * @return {Boolean} - whether a redraw is needed.\n */\nAttributeManager.prototype.getNeedsRedraw = function getNeedsRedraw (ref) {\n    if ( ref === void 0 ) ref = {};\n    var clearRedrawFlags = ref.clearRedrawFlags; if ( clearRedrawFlags === void 0 ) clearRedrawFlags = false;\n\n  var redraw = this.needsRedraw;\n  redraw = redraw || this.needsRedraw;\n  this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n  return redraw;\n};\n\n/**\n * Sets the redraw flag.\n * @param {Boolean} redraw=true\n * @return {AttributeManager} - for chaining\n */\nAttributeManager.prototype.setNeedsRedraw = function setNeedsRedraw (redraw) {\n    if ( redraw === void 0 ) redraw = true;\n\n  this.needsRedraw = true;\n  return this;\n};\n\n// DEPRECATED METHODS\n\n/**\n * @deprecated since version 2.5, use add() instead\n * Adds attributes\n * @param {Object} attributes - attribute map (see above)\n * @param {Object} updaters - separate map of update functions (deprecated)\n */\nAttributeManager.prototype.addDynamic = function addDynamic (attributes, updaters) {\n    if ( updaters === void 0 ) updaters = {};\n\n  this._add(attributes, updaters);\n};\n\n/**\n * @deprecated since version 2.5, use add() instead\n * Adds attributes\n * @param {Object} attributes - attribute map (see above)\n * @param {Object} updaters - separate map of update functions (deprecated)\n */\nAttributeManager.prototype.addInstanced = function addInstanced (attributes, updaters) {\n    if ( updaters === void 0 ) updaters = {};\n\n  this._add(attributes, updaters, { instanced: 1 });\n};\n\n// PRIVATE METHODS\n\n// Default logger\nAttributeManager.prototype._defaultLog = function _defaultLog (level, message) {\n  __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].log(level, message);\n};\n\n// Used to register an attribute\nAttributeManager.prototype._add = function _add (attributes, updaters, _extraProps) {\n    var this$1 = this;\n    if ( updaters === void 0 ) updaters = {};\n    if ( _extraProps === void 0 ) _extraProps = {};\n\n\n  var newAttributes = {};\n\n  for (var attributeName in attributes) {\n    // support for separate update function map\n    // For now, just copy any attributes from that map into the main map\n    // TODO - Attribute maps are a deprecated feature, remove\n    if (attributeName in updaters) {\n      attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);\n    }\n\n    var attribute = attributes[attributeName];\n\n    // Check all fields and generate helpful error messages\n    this$1._validate(attributeName, attribute);\n\n    // Initialize the attribute descriptor, with WebGL and metadata fields\n    var attributeData = Object.assign({\n      // Ensure that fields are present before Object.seal()\n      target: undefined,\n      isIndexed: false,\n\n      // Reserved for application\n      userData: {}\n    },\n    // Metadata\n    attribute, {\n      // State\n      isExternalBuffer: false,\n      needsAlloc: false,\n      needsUpdate: false,\n      changed: false,\n\n      // Luma fields\n      size: attribute.size,\n      value: attribute.value || null\n    }, _extraProps);\n    // Sanity - no app fields on our attributes. Use userData instead.\n    Object.seal(attributeData);\n\n    // Add to both attributes list (for registration with model)\n    this$1.attributes[attributeName] = attributeData;\n  }\n\n  Object.assign(this.attributes, newAttributes);\n};\n\nAttributeManager.prototype._validate = function _validate (attributeName, attribute) {\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(typeof attribute.size === 'number', (\"Attribute definition for \" + attributeName + \" missing size\"));\n\n  // Check the updater\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(typeof attribute.update === 'function' || attribute.noAlloc, (\"Attribute updater for \" + attributeName + \" missing update method\"));\n};\n\n// Checks that any attribute buffers in props are valid\n// Note: This is just to help app catch mistakes\nAttributeManager.prototype._checkExternalBuffers = function _checkExternalBuffers (ref) {\n    if ( ref === void 0 ) ref = {};\n    var buffers = ref.buffers; if ( buffers === void 0 ) buffers = {};\n    var ignoreUnknownAttributes = ref.ignoreUnknownAttributes; if ( ignoreUnknownAttributes === void 0 ) ignoreUnknownAttributes = false;\n\n  var ref$1 = this;\n    var attributes = ref$1.attributes;\n  for (var attributeName in buffers) {\n    var attribute = attributes[attributeName];\n    if (!attribute && !ignoreUnknownAttributes) {\n      throw new Error((\"Unknown attribute prop \" + attributeName));\n    }\n    // const buffer = buffers[attributeName];\n    // TODO - check buffer type\n  }\n};\n\n// Set the buffers for the supplied attributes\n// Update attribute buffers from any attributes in props\n// Detach any previously set buffers, marking all\n// Attributes for auto allocation\n/* eslint-disable max-statements */\nAttributeManager.prototype._setExternalBuffers = function _setExternalBuffers (bufferMap) {\n    var this$1 = this;\n\n  var ref = this;\n    var attributes = ref.attributes;\n    var numInstances = ref.numInstances;\n\n  // Copy the refs of any supplied buffers in the props\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n    var buffer = bufferMap[attributeName];\n    attribute.isExternalBuffer = false;\n    if (buffer) {\n      if (!(buffer instanceof Float32Array)) {\n        throw new Error('Attribute properties must be of type Float32Array');\n      }\n      if (attribute.auto && buffer.length <= numInstances * attribute.size) {\n        throw new Error('Attribute prop array must match length and size');\n      }\n\n      attribute.isExternalBuffer = true;\n      attribute.needsUpdate = false;\n      if (attribute.value !== buffer) {\n        attribute.value = buffer;\n        attribute.changed = true;\n        this$1.needsRedraw = true;\n      }\n    }\n  }\n};\n/* eslint-enable max-statements */\n\n/* Checks that typed arrays for attributes are big enough\n * sets alloc flag if not\n * @return {Boolean} whether any updates are needed\n */\nAttributeManager.prototype._analyzeBuffers = function _analyzeBuffers (ref) {\n    var numInstances = ref.numInstances;\n\n  var ref$1 = this;\n    var attributes = ref$1.attributes;\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(numInstances !== undefined, 'numInstances not defined');\n\n  // Track whether any allocations or updates are needed\n  var needsUpdate = false;\n\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n    if (!attribute.isExternalBuffer) {\n      // Do we need to reallocate the attribute's typed array?\n      var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;\n      if (needsAlloc && attribute.update) {\n        attribute.needsAlloc = true;\n        needsUpdate = true;\n      }\n      if (attribute.needsUpdate) {\n        needsUpdate = true;\n      }\n    }\n  }\n\n  return needsUpdate;\n};\n\n/**\n * @private\n * Calls update on any buffers that need update\n * TODO? - If app supplied all attributes, no need to iterate over data\n *\n * @param {Object} opts - options\n * @param {Object} opts.data - data (iterable object)\n * @param {Object} opts.numInstances - count of data\n * @param {Object} opts.buffers = {} - pre-allocated buffers\n * @param {Object} opts.props - passed to updaters\n * @param {Object} opts.context - Used as \"this\" context for updaters\n */\n/* eslint-disable max-statements */\nAttributeManager.prototype._updateBuffers = function _updateBuffers (ref) {\n    var this$1 = this;\n    var numInstances = ref.numInstances;\n    var data = ref.data;\n    var props = ref.props;\n    var context = ref.context;\n\n  var ref$1 = this;\n    var attributes = ref$1.attributes;\n\n  // Allocate at least one element to ensure a valid buffer\n  var allocCount = Math.max(numInstances, 1);\n\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n\n    // Allocate a new typed array if needed\n    if (attribute.needsAlloc) {\n      var ArrayType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glArrayFromType\"])(attribute.type || __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].FLOAT);\n      attribute.value = new ArrayType(attribute.size * allocCount);\n      this$1.onLog(2, ((this$1.id) + \":\" + attributeName + \" allocated \" + allocCount));\n      attribute.needsAlloc = false;\n      attribute.needsUpdate = true;\n    }\n\n    // Call updater function if needed\n    if (attribute.needsUpdate) {\n      var update = attribute.update;\n      if (update) {\n        this$1.onLog(2, ((this$1.id) + \":\" + attributeName + \" updating \" + numInstances));\n        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });\n      } else {\n        this$1.onLog(2, ((this$1.id) + \":\" + attributeName + \" missing update function\"));\n      }\n      attribute.needsUpdate = false;\n      attribute.changed = true;\n      this$1.needsRedraw = true;\n    }\n  }\n\n  this.allocedInstances = allocCount;\n};\n\n/* harmony default export */ exports[\"a\"] = AttributeManager;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9hdHRyaWJ1dGUtbWFuYWdlci5qcz8wNzRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuaW1wb3J0IHsgR0wsIGdsQXJyYXlGcm9tVHlwZSB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlTWFuYWdlciB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEF1dG9tYXRlZCBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiBhbmQgbWFuYWdlbWVudC4gU3VpdGFibGUgd2hlbiBhIHNldCBvZlxuICAgKiB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZXMgYXJlIGdlbmVyYXRlZCBieSBpdGVyYXRpb24gb3ZlciBhIGRhdGEgYXJyYXksXG4gICAqIGFuZCB1cGRhdGVzIHRvIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG5lZWRlZCBlaXRoZXIgd2hlbiB0aGUgZGF0YSBpdHNlbGZcbiAgICogY2hhbmdlcywgb3Igd2hlbiBvdGhlciBkYXRhIHJlbGV2YW50IHRvIHRoZSBjYWxjdWxhdGlvbnMgY2hhbmdlLlxuICAgKlxuICAgKiAtIEZpcnN0IHRoZSBhcHBsaWNhdGlvbiByZWdpc3RlcnMgZGVzY3JpcHRpb25zIG9mIGl0cyBkeW5hbWljIHZlcnRleFxuICAgKiAgIGF0dHJpYnV0ZXMgdXNpbmcgQXR0cmlidXRlTWFuYWdlci5hZGQoKS5cbiAgICogLSBUaGVuLCB3aGVuIGFueSBjaGFuZ2UgdGhhdCBhZmZlY3RzIGF0dHJpYnV0ZXMgaXMgZGV0ZWN0ZWQgYnkgdGhlXG4gICAqICAgYXBwbGljYXRpb24sIHRoZSBhcHAgd2lsbCBjYWxsIEF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgpLlxuICAgKiAtIEZpbmFsbHkgYmVmb3JlIGl0IHJlbmRlcnMsIGl0IGNhbGxzIEF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKCkgdG9cbiAgICogICBlbnN1cmUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgaWYgYW55dGhpbmcgaGFzIGJlZW5cbiAgICogICBpbnZhbGlkYXRlZC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIHVwZGF0ZSBmdW5jdGlvbnMgZGVzY3JpYmUgaG93IGF0dHJpYnV0ZXNcbiAgICogc2hvdWxkIGJlIHVwZGF0ZWQgZnJvbSBhIGRhdGEgYXJyYXkgYW5kIGFyZSBleHBlY3RlZCB0byB0cmF2ZXJzZVxuICAgKiB0aGF0IGRhdGEgYXJyYXkgKG9yIGl0ZXJhYmxlKSBhbmQgZmlsbCBpbiB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIG1hbmFnZXIgaW50ZW50aW9uYWxseSBkb2VzIG5vdCBkbyBhZHZhbmNlZFxuICAgKiBjaGFuZ2UgZGV0ZWN0aW9uLCBidXQgaW5zdGVhZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHN1Y2ggZGV0ZWN0aW9uXG4gICAqIGJ5IG9mZmVyaW5nIHRoZSBhYmlsaXR5IHRvIFwiaW52YWxpZGF0ZVwiIGVhY2ggYXR0cmlidXRlIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIFN1bW1hcnk6XG4gICAqIC0ga2VlcHMgdHJhY2sgb2YgdmFsaWQgc3RhdGUgZm9yIGVhY2ggYXR0cmlidXRlXG4gICAqIC0gYXV0byByZWFsbG9jYXRlcyBhdHRyaWJ1dGVzIHdoZW4gbmVlZGVkXG4gICAqIC0gYXV0byB1cGRhdGVzIGF0dHJpYnV0ZXMgd2l0aCByZWdpc3RlcmVkIHVwZGF0ZXIgZnVuY3Rpb25zXG4gICAqIC0gYWxsb3dzIG92ZXJyaWRpbmcgd2l0aCBhcHBsaWNhdGlvbiBzdXBwbGllZCBidWZmZXJzXG4gICAqXG4gICAqIExpbWl0YXRpb25zOlxuICAgKiAtIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gcHJvdmlzaW9ucyBmb3Igb25seSBpbnZhbGlkYXRpbmcgYSByYW5nZSBvZlxuICAgKiAgIGluZGljZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wcy5pZF0gLSBpZGVudGlmaWVyIChmb3IgZGVidWdnaW5nKVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBpZCA9ICdhdHRyaWJ1dGUtbWFuYWdlcicgfSA9IHt9KSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IC0xO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcblxuICAgIHRoaXMub25VcGRhdGVTdGFydCA9IG5vb3A7XG4gICAgdGhpcy5vblVwZGF0ZUVuZCA9IG5vb3A7XG4gICAgdGhpcy5vbkxvZyA9IHRoaXMuX2RlZmF1bHRMb2c7XG5cbiAgICAvLyBGb3IgZGVidWdnaW5nIHNhbml0eSwgcHJldmVudCB1bmluaXRpYWxpemVkIG1lbWJlcnNcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogVGFrZXMgYSBtYXAgb2YgYXR0cmlidXRlIGRlc2NyaXB0b3Igb2JqZWN0c1xuICAgKiAtIGtleXMgYXJlIGF0dHJpYnV0ZSBuYW1lc1xuICAgKiAtIHZhbHVlcyBhcmUgb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZSBmaWVsZHNcbiAgICpcbiAgICogYXR0cmlidXRlLnNpemUgLSBudW1iZXIgb2YgZWxlbWVudHMgcGVyIG9iamVjdFxuICAgKiBhdHRyaWJ1dGUudXBkYXRlciAtIG51bWJlciBvZiBlbGVtZW50c1xuICAgKiBhdHRyaWJ1dGUuaW5zdGFuY2VkPTAgLSBpcyB0aGlzIGlzIGFuIGluc3RhbmNlZCBhdHRyaWJ1dGUgKGEuay5hLiBkaXZpc29yKVxuICAgKiBhdHRyaWJ1dGUubm9BbGxvYz1mYWxzZSAtIGlmIHRoaXMgYXR0cmlidXRlIHNob3VsZCBub3QgYmUgYWxsb2NhdGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICogICBwb3NpdGlvbnM6IHtzaXplOiAyLCB1cGRhdGU6IGNhbGN1bGF0ZVBvc2l0aW9uc31cbiAgICogICBjb2xvcnM6IHtzaXplOiAzLCB1cGRhdGU6IGNhbGN1bGF0ZUNvbG9yc31cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzKTtcbiAgfVxuXG4gIC8vIE1hcmtzIGFuIGF0dHJpYnV0ZSBmb3IgdXBkYXRlXG4gIGludmFsaWRhdGUoYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgIGlmICghYXR0cmlidXRlKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGBpbnZhbGlkYXRpbmcgbm9uLWV4aXN0ZW50IGF0dHJpYnV0ZSAkeyBhdHRyaWJ1dGVOYW1lIH0gZm9yICR7IHRoaXMuaWQgfVxcbmA7XG4gICAgICBtZXNzYWdlICs9IGBWYWxpZCBhdHRyaWJ1dGVzOiAkeyBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5qb2luKCcsICcpIH1gO1xuICAgICAgYXNzZXJ0KGF0dHJpYnV0ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlIHR1bmluZ1xuICAgIHRoaXMub25Mb2coMSwgYGludmFsaWRhdGVkIGF0dHJpYnV0ZSAkeyBhdHRyaWJ1dGVOYW1lIH0gZm9yICR7IHRoaXMuaWQgfWApO1xuICB9XG5cbiAgaW52YWxpZGF0ZUFsbCgpIHtcbiAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBhdHRyaWJ1dGUgYnVmZmVycyBhcmUgdXBkYXRlZCBmcm9tIHByb3BzIG9yIGRhdGEuXG4gICAqXG4gICAqIE5vdGU6IEFueSBwcmVhbGxvY2F0ZWQgYnVmZmVycyBpbiBcImJ1ZmZlcnNcIiBtYXRjaGluZyByZWdpc3RlcmVkIGF0dHJpYnV0ZVxuICAgKiBuYW1lcyB3aWxsIGJlIHVzZWQuIE5vIHVwZGF0ZSB3aWxsIGhhcHBlbiBpbiB0aGlzIGNhc2UuXG4gICAqIE5vdGU6IENhbGxzIG9uVXBkYXRlU3RhcnQgYW5kIG9uVXBkYXRlRW5kIGxvZyBjYWxsYmFja3MgYmVmb3JlIGFuZCBhZnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICB1cGRhdGUoe1xuICAgIGRhdGEsXG4gICAgbnVtSW5zdGFuY2VzLFxuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGNvbnRleHQgPSB7fSxcbiAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIC8vIEZpcnN0IGFwcGx5IGFueSBhcHBsaWNhdGlvbiBwcm92aWRlZCBidWZmZXJzXG4gICAgdGhpcy5fY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoeyBidWZmZXJzLCBpZ25vcmVVbmtub3duQXR0cmlidXRlcyB9KTtcbiAgICB0aGlzLl9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVycyk7XG5cbiAgICAvLyBPbmx5IGluaXRpYXRlIGFsbG9jL3VwZGF0ZSAoYW5kIGxvZ2dpbmcpIGlmIGFjdHVhbGx5IG5lZWRlZFxuICAgIGlmICh0aGlzLl9hbmFseXplQnVmZmVycyh7IG51bUluc3RhbmNlcyB9KSkge1xuICAgICAgdGhpcy5vblVwZGF0ZVN0YXJ0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVycyh7IG51bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHQgfSk7XG4gICAgICB0aGlzLm9uVXBkYXRlRW5kKHRoaXMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGxvZyBmdW5jdGlvbnMgdG8gaGVscCB0cmFjZSBvciB0aW1lIGF0dHJpYnV0ZSB1cGRhdGVzLlxuICAgKiBEZWZhdWx0IGxvZ2dpbmcgdXNlcyBsdW1hIGxvZ2dlci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBhcHAgbWF5IG5vdCBiZSBpbiBjb250cm9sIG9mIHdoZW4gdXBkYXRlIGlzIGNhbGxlZCxcbiAgICogc28gaG9va3MgYXJlIHByb3ZpZGVkIGZvciB1cGRhdGUgc3RhcnQgYW5kIGVuZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25Mb2c9XSAtIGNhbGxlZCB0byBwcmludFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVTdGFydD1dIC0gY2FsbGVkIGJlZm9yZSB1cGRhdGUoKSBzdGFydHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uVXBkYXRlRW5kPV0gLSBjYWxsZWQgYWZ0ZXIgdXBkYXRlKCkgZW5kc1xuICAgKi9cbiAgc2V0TG9nRnVuY3Rpb25zKHtcbiAgICBvbkxvZyxcbiAgICBvblVwZGF0ZVN0YXJ0LFxuICAgIG9uVXBkYXRlRW5kXG4gIH0gPSB7fSkge1xuICAgIHRoaXMub25Mb2cgPSBvbkxvZyAhPT0gdW5kZWZpbmVkID8gb25Mb2cgOiB0aGlzLm9uTG9nO1xuICAgIHRoaXMub25VcGRhdGVTdGFydCA9IG9uVXBkYXRlU3RhcnQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlU3RhcnQgOiB0aGlzLm9uVXBkYXRlU3RhcnQ7XG4gICAgdGhpcy5vblVwZGF0ZUVuZCA9IG9uVXBkYXRlRW5kICE9PSB1bmRlZmluZWQgPyBvblVwZGF0ZUVuZCA6IHRoaXMub25VcGRhdGVFbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIE5vdGU6IEZvcm1hdCBtYXRjaGVzIGx1bWEuZ2wgTW9kZWwvUHJvZ3JhbS5zZXRBdHRyaWJ1dGVzKClcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNoYW5nZWQgYXR0cmlidXRlIGRlc2NyaXB0b3JzXG4gICAqIFRoaXMgaW5kaWNhdGVzIHdoaWNoIFdlYkdMQnVnZ2VycyBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICovXG4gIGdldENoYW5nZWRBdHRyaWJ1dGVzKHsgY2xlYXJDaGFuZ2VkRmxhZ3MgPSBmYWxzZSB9KSB7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoYXR0cmlidXRlLmNoYW5nZWQpIHtcbiAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSBhdHRyaWJ1dGUuY2hhbmdlZCAmJiAhY2xlYXJDaGFuZ2VkRmxhZ3M7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVkcmF3IGZsYWcsIG9wdGlvbmFsbHkgY2xlYXJpbmcgaXQuXG4gICAqIFJlZHJhdyBmbGFnIHdpbGwgYmUgc2V0IGlmIGFueSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgY2hhbmdlZCBzaW5jZVxuICAgKiBmbGFnIHdhcyBsYXN0IGNsZWFyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmNsZWFyUmVkcmF3RmxhZ3M9ZmFsc2VdIC0gd2hldGhlciB0byBjbGVhciB0aGUgZmxhZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIHdoZXRoZXIgYSByZWRyYXcgaXMgbmVlZGVkLlxuICAgKi9cbiAgZ2V0TmVlZHNSZWRyYXcoeyBjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgbGV0IHJlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRoaXMubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByZWRyYXcgZmxhZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSByZWRyYXc9dHJ1ZVxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGVNYW5hZ2VyfSAtIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LCB1c2UgYWRkKCkgaW5zdGVhZFxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkRHluYW1pYyhhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNSwgdXNlIGFkZCgpIGluc3RlYWRcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZEluc3RhbmNlZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzLCB7IGluc3RhbmNlZDogMSB9KTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIERlZmF1bHQgbG9nZ2VyXG4gIF9kZWZhdWx0TG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgbG9nLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICAvLyBVc2VkIHRvIHJlZ2lzdGVyIGFuIGF0dHJpYnV0ZVxuICBfYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30sIF9leHRyYVByb3BzID0ge30pIHtcblxuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAvLyBzdXBwb3J0IGZvciBzZXBhcmF0ZSB1cGRhdGUgZnVuY3Rpb24gbWFwXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGNvcHkgYW55IGF0dHJpYnV0ZXMgZnJvbSB0aGF0IG1hcCBpbnRvIHRoZSBtYWluIG1hcFxuICAgICAgLy8gVE9ETyAtIEF0dHJpYnV0ZSBtYXBzIGFyZSBhIGRlcHJlY2F0ZWQgZmVhdHVyZSwgcmVtb3ZlXG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiB1cGRhdGVycykge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSwgdXBkYXRlcnNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAvLyBDaGVjayBhbGwgZmllbGRzIGFuZCBnZW5lcmF0ZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VzXG4gICAgICB0aGlzLl92YWxpZGF0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBhdHRyaWJ1dGUgZGVzY3JpcHRvciwgd2l0aCBXZWJHTCBhbmQgbWV0YWRhdGEgZmllbGRzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGZpZWxkcyBhcmUgcHJlc2VudCBiZWZvcmUgT2JqZWN0LnNlYWwoKVxuICAgICAgICB0YXJnZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNJbmRleGVkOiBmYWxzZSxcblxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgYXBwbGljYXRpb25cbiAgICAgICAgdXNlckRhdGE6IHt9XG4gICAgICB9LFxuICAgICAgLy8gTWV0YWRhdGFcbiAgICAgIGF0dHJpYnV0ZSwge1xuICAgICAgICAvLyBTdGF0ZVxuICAgICAgICBpc0V4dGVybmFsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgbmVlZHNBbGxvYzogZmFsc2UsXG4gICAgICAgIG5lZWRzVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgY2hhbmdlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gTHVtYSBmaWVsZHNcbiAgICAgICAgc2l6ZTogYXR0cmlidXRlLnNpemUsXG4gICAgICAgIHZhbHVlOiBhdHRyaWJ1dGUudmFsdWUgfHwgbnVsbFxuICAgICAgfSwgX2V4dHJhUHJvcHMpO1xuICAgICAgLy8gU2FuaXR5IC0gbm8gYXBwIGZpZWxkcyBvbiBvdXIgYXR0cmlidXRlcy4gVXNlIHVzZXJEYXRhIGluc3RlYWQuXG4gICAgICBPYmplY3Quc2VhbChhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQWRkIHRvIGJvdGggYXR0cmlidXRlcyBsaXN0IChmb3IgcmVnaXN0cmF0aW9uIHdpdGggbW9kZWwpXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVEYXRhO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIF92YWxpZGF0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICBhc3NlcnQodHlwZW9mIGF0dHJpYnV0ZS5zaXplID09PSAnbnVtYmVyJywgYEF0dHJpYnV0ZSBkZWZpbml0aW9uIGZvciAkeyBhdHRyaWJ1dGVOYW1lIH0gbWlzc2luZyBzaXplYCk7XG5cbiAgICAvLyBDaGVjayB0aGUgdXBkYXRlclxuICAgIGFzc2VydCh0eXBlb2YgYXR0cmlidXRlLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBhdHRyaWJ1dGUubm9BbGxvYywgYEF0dHJpYnV0ZSB1cGRhdGVyIGZvciAkeyBhdHRyaWJ1dGVOYW1lIH0gbWlzc2luZyB1cGRhdGUgbWV0aG9kYCk7XG4gIH1cblxuICAvLyBDaGVja3MgdGhhdCBhbnkgYXR0cmlidXRlIGJ1ZmZlcnMgaW4gcHJvcHMgYXJlIHZhbGlkXG4gIC8vIE5vdGU6IFRoaXMgaXMganVzdCB0byBoZWxwIGFwcCBjYXRjaCBtaXN0YWtlc1xuICBfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoe1xuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYnVmZmVycykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlICYmICFpZ25vcmVVbmtub3duQXR0cmlidXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIHByb3AgJHsgYXR0cmlidXRlTmFtZSB9YCk7XG4gICAgICB9XG4gICAgICAvLyBjb25zdCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgLy8gVE9ETyAtIGNoZWNrIGJ1ZmZlciB0eXBlXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSBidWZmZXJzIGZvciB0aGUgc3VwcGxpZWQgYXR0cmlidXRlc1xuICAvLyBVcGRhdGUgYXR0cmlidXRlIGJ1ZmZlcnMgZnJvbSBhbnkgYXR0cmlidXRlcyBpbiBwcm9wc1xuICAvLyBEZXRhY2ggYW55IHByZXZpb3VzbHkgc2V0IGJ1ZmZlcnMsIG1hcmtpbmcgYWxsXG4gIC8vIEF0dHJpYnV0ZXMgZm9yIGF1dG8gYWxsb2NhdGlvblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlck1hcCkge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgbnVtSW5zdGFuY2VzIH0gPSB0aGlzO1xuXG4gICAgLy8gQ29weSB0aGUgcmVmcyBvZiBhbnkgc3VwcGxpZWQgYnVmZmVycyBpbiB0aGUgcHJvcHNcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlck1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gZmFsc2U7XG4gICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wZXJ0aWVzIG11c3QgYmUgb2YgdHlwZSBGbG9hdDMyQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLmF1dG8gJiYgYnVmZmVyLmxlbmd0aCA8PSBudW1JbnN0YW5jZXMgKiBhdHRyaWJ1dGUuc2l6ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHByb3AgYXJyYXkgbXVzdCBtYXRjaCBsZW5ndGggYW5kIHNpemUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgIT09IGJ1ZmZlcikge1xuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGJ1ZmZlcjtcbiAgICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qIENoZWNrcyB0aGF0IHR5cGVkIGFycmF5cyBmb3IgYXR0cmlidXRlcyBhcmUgYmlnIGVub3VnaFxuICAgKiBzZXRzIGFsbG9jIGZsYWcgaWYgbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgYW55IHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgKi9cbiAgX2FuYWx5emVCdWZmZXJzKHsgbnVtSW5zdGFuY2VzIH0pIHtcbiAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IHRoaXM7XG4gICAgYXNzZXJ0KG51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkLCAnbnVtSW5zdGFuY2VzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICAvLyBUcmFjayB3aGV0aGVyIGFueSBhbGxvY2F0aW9ucyBvciB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlcikge1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlYWxsb2NhdGUgdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5P1xuICAgICAgICBjb25zdCBuZWVkc0FsbG9jID0gYXR0cmlidXRlLnZhbHVlID09PSBudWxsIHx8IGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSA8IG51bUluc3RhbmNlcztcbiAgICAgICAgaWYgKG5lZWRzQWxsb2MgJiYgYXR0cmlidXRlLnVwZGF0ZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc0FsbG9jID0gdHJ1ZTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWVkc1VwZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDYWxscyB1cGRhdGUgb24gYW55IGJ1ZmZlcnMgdGhhdCBuZWVkIHVwZGF0ZVxuICAgKiBUT0RPPyAtIElmIGFwcCBzdXBwbGllZCBhbGwgYXR0cmlidXRlcywgbm8gbmVlZCB0byBpdGVyYXRlIG92ZXIgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubnVtSW5zdGFuY2VzIC0gY291bnQgb2YgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udGV4dCAtIFVzZWQgYXMgXCJ0aGlzXCIgY29udGV4dCBmb3IgdXBkYXRlcnNcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF91cGRhdGVCdWZmZXJzKHsgbnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dCB9KSB7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSB0aGlzO1xuXG4gICAgLy8gQWxsb2NhdGUgYXQgbGVhc3Qgb25lIGVsZW1lbnQgdG8gZW5zdXJlIGEgdmFsaWQgYnVmZmVyXG4gICAgY29uc3QgYWxsb2NDb3VudCA9IE1hdGgubWF4KG51bUluc3RhbmNlcywgMSk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgLy8gQWxsb2NhdGUgYSBuZXcgdHlwZWQgYXJyYXkgaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzQWxsb2MpIHtcbiAgICAgICAgY29uc3QgQXJyYXlUeXBlID0gZ2xBcnJheUZyb21UeXBlKGF0dHJpYnV0ZS50eXBlIHx8IEdMLkZMT0FUKTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEFycmF5VHlwZShhdHRyaWJ1dGUuc2l6ZSAqIGFsbG9jQ291bnQpO1xuICAgICAgICB0aGlzLm9uTG9nKDIsIGAkeyB0aGlzLmlkIH06JHsgYXR0cmlidXRlTmFtZSB9IGFsbG9jYXRlZCAkeyBhbGxvY0NvdW50IH1gKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCB1cGRhdGVyIGZ1bmN0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICBjb25zdCB7IHVwZGF0ZSB9ID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5vbkxvZygyLCBgJHsgdGhpcy5pZCB9OiR7IGF0dHJpYnV0ZU5hbWUgfSB1cGRhdGluZyAkeyBudW1JbnN0YW5jZXMgfWApO1xuICAgICAgICAgIHVwZGF0ZS5jYWxsKGNvbnRleHQsIGF0dHJpYnV0ZSwgeyBkYXRhLCBwcm9wcywgbnVtSW5zdGFuY2VzIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25Mb2coMiwgYCR7IHRoaXMuaWQgfTokeyBhdHRyaWJ1dGVOYW1lIH0gbWlzc2luZyB1cGRhdGUgZnVuY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSBhbGxvY0NvdW50O1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi9hdHRyaWJ1dGUtbWFuYWdlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 19 */
/* exports provided: COORDINATE_SYSTEM */
/* exports used: COORDINATE_SYSTEM */
/*!******************************!*\
  !*** ./src/lib/constants.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(exports, \"a\", function() { return COORDINATE_SYSTEM; });\n// Note: The numeric values here are matched by shader code in the\n// \"project\" and \"project64\" shader modules. Both places need to be\n// updated.\n\n// TODO: Maybe \"POSITIONS\" would be a better name?\nvar COORDINATE_SYSTEM = {\n  // Positions are interpreted as [lng, lat, elevation]\n  // lng lat are degrees, elevation is meters. distances as meters.\n  LNGLAT: 1.0,\n\n  // Positions are interpreted as lng lat offsets: [deltaLng, deltaLat, elevation]\n  // deltaLng, deltaLat are delta degrees, elevation is meters.\n  // distances as meters.\n  LNGLAT_OFFSETS: 3.0,\n\n  // Positions are interpreted as meter offsets, distances as meters\n  METER_OFFSETS: 2.0,\n  METERS: 2.0,\n\n  // Positions and distances are not transformed: [x, y, z] in unit coordinates\n  IDENTITY: 0.0\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9jb25zdGFudHMuanM/MWQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOb3RlOiBUaGUgbnVtZXJpYyB2YWx1ZXMgaGVyZSBhcmUgbWF0Y2hlZCBieSBzaGFkZXIgY29kZSBpbiB0aGVcbi8vIFwicHJvamVjdFwiIGFuZCBcInByb2plY3Q2NFwiIHNoYWRlciBtb2R1bGVzLiBCb3RoIHBsYWNlcyBuZWVkIHRvIGJlXG4vLyB1cGRhdGVkLlxuXG4vLyBUT0RPOiBNYXliZSBcIlBPU0lUSU9OU1wiIHdvdWxkIGJlIGEgYmV0dGVyIG5hbWU/XG5leHBvcnQgY29uc3QgQ09PUkRJTkFURV9TWVNURU0gPSB7XG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgW2xuZywgbGF0LCBlbGV2YXRpb25dXG4gIC8vIGxuZyBsYXQgYXJlIGRlZ3JlZXMsIGVsZXZhdGlvbiBpcyBtZXRlcnMuIGRpc3RhbmNlcyBhcyBtZXRlcnMuXG4gIExOR0xBVDogMS4wLFxuXG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgbG5nIGxhdCBvZmZzZXRzOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCBlbGV2YXRpb25dXG4gIC8vIGRlbHRhTG5nLCBkZWx0YUxhdCBhcmUgZGVsdGEgZGVncmVlcywgZWxldmF0aW9uIGlzIG1ldGVycy5cbiAgLy8gZGlzdGFuY2VzIGFzIG1ldGVycy5cbiAgTE5HTEFUX09GRlNFVFM6IDMuMCxcblxuICAvLyBQb3NpdGlvbnMgYXJlIGludGVycHJldGVkIGFzIG1ldGVyIG9mZnNldHMsIGRpc3RhbmNlcyBhcyBtZXRlcnNcbiAgTUVURVJfT0ZGU0VUUzogMi4wLFxuICBNRVRFUlM6IDIuMCxcblxuICAvLyBQb3NpdGlvbnMgYW5kIGRpc3RhbmNlcyBhcmUgbm90IHRyYW5zZm9ybWVkOiBbeCwgeSwgel0gaW4gdW5pdCBjb29yZGluYXRlc1xuICBJREVOVElUWTogMC4wXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL2NvbnN0YW50cy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 20 */
/* exports provided: default */
/* exports used: default */
/*!**************************!*\
  !*** ./src/lib/layer.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attribute_manager__ = __webpack_require__(/*! ./attribute-manager */ 18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(/*! ./utils */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert__ = __webpack_require__(/*! assert */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_assert__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* global window */\n\n\n\n\n\n/*\n * @param {string} props.id - layer name\n * @param {array}  props.data - array of data instances\n * @param {bool} props.opacity - opacity of the layer\n */\nvar defaultProps = {\n  data: [],\n  dataIterator: null,\n  dataComparator: null,\n  numInstances: undefined,\n  visible: true,\n  pickable: false,\n  opacity: 0.8,\n  onHover: function () {},\n  onClick: function () {},\n  getValue: function (x) { return x; },\n  // Update triggers: a key change detection mechanism in deck.gl\n  // See layer documentation\n  updateTriggers: {}\n};\n\nvar counter = 0;\n\nvar Layer = function Layer(props) {\n  props = Object.assign({}, defaultProps, props, {\n    // Accept null as data - otherwise apps will need to add ugly checks\n    data: props.data || [],\n    id: props.id || this.constructor.layerName\n  });\n\n  this.id = props.id;\n  this.count = counter++;\n  this.props = props;\n  this.oldProps = null;\n  this.state = null;\n  this.context = null;\n  Object.seal(this);\n\n  this.validateRequiredProp('id', function (x) { return typeof x === 'string'; });\n  this.validateRequiredProp('data');\n  // TODO - allow app to supply dataIterator prop?\n  // if (props.data) {\n  // addIterator(props.data);\n  // if (!props.data[Symbol.iterator]) {\n  //   log.once(0, 'data prop must have iterator');\n  // }\n  // }\n\n  this._validateDeprecatedProps();\n};\n\nLayer.prototype.toString = function toString () {\n  var className = this.constructor.name;\n  return className !== this.props.id ? (\"<\" + className + \":'\" + (this.props.id) + \"'>\") : (\"<\" + className + \">\");\n};\n\n// //////////////////////////////////////////////////\n// LIFECYCLE METHODS, overridden by the layer subclasses\n\n// Called once to set up the initial state\n// App can create WebGL resources\nLayer.prototype.initializeState = function initializeState () {\n  throw new Error((\"Layer \" + (this) + \" has not defined initializeState\"));\n};\n\n// Called once when layer is no longer matched and state will be discarded\n// App can destroy WebGL resources\nLayer.prototype.finalizeState = function finalizeState () {};\n\nLayer.prototype.shouldUpdateState = function shouldUpdateState (ref) {\n    var oldProps = ref.oldProps;\n    var props = ref.props;\n    var oldContext = ref.oldContext;\n    var context = ref.context;\n    var changeFlags = ref.changeFlags;\n\n  return changeFlags.somethingChanged;\n};\n\n// Default implementation, all attributeManager will be updated\nLayer.prototype.updateState = function updateState (ref) {\n    var oldProps = ref.oldProps;\n    var props = ref.props;\n    var oldContext = ref.oldContext;\n    var context = ref.context;\n    var changeFlags = ref.changeFlags;\n\n  if (changeFlags.dataChanged && this.state.attributeManager) {\n    this.state.attributeManager.invalidateAll();\n  }\n};\n\n// Implement to generate sublayers\nLayer.prototype.renderLayers = function renderLayers () {\n  return null;\n};\n\n// If state has a model, draw it with supplied uniforms\nLayer.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms; if ( uniforms === void 0 ) uniforms = {};\n\n  if (this.state.model) {\n    this.state.model.render(uniforms);\n  }\n};\n\n// If state has a model, draw it with supplied uniforms\n/* eslint-disable max-statements */\nLayer.prototype.pick = function pick (ref) {\n    var info = ref.info;\n    var uniforms = ref.uniforms;\n    var pickEnableUniforms = ref.pickEnableUniforms;\n    var pickDisableUniforms = ref.pickDisableUniforms;\n    var mode = ref.mode;\n\n  var ref$1 = this.context;\n    var gl = ref$1.gl;\n  var ref$2 = this.state;\n    var model = ref$2.model;\n\n  if (model) {\n    model.setUniforms(pickEnableUniforms);\n    model.render(uniforms);\n    model.setUniforms(pickDisableUniforms);\n\n    // Read color in the central pixel, to be mapped with picking colors\n    var ref$3 = info.devicePixel;\n      var x = ref$3[0];\n      var y = ref$3[1];\n    var color = new Uint8Array(4);\n    gl.readPixels(x, y, 1, 1, __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].RGBA, __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE, color);\n\n    // Index < 0 means nothing selected\n    info.index = this.decodePickingColor(color);\n    info.color = color;\n\n    // TODO - selectedPickingColor should be removed?\n    if (mode === 'hover') {\n      var selectedPickingColor = new Float32Array(3);\n      selectedPickingColor[0] = color[0];\n      selectedPickingColor[1] = color[1];\n      selectedPickingColor[2] = color[2];\n      this.setUniforms({ selectedPickingColor: selectedPickingColor });\n    }\n  }\n};\n/* eslint-enable max-statements */\n\n// END LIFECYCLE METHODS\n// //////////////////////////////////////////////////\n\n// Public API\n\n// Updates selected state members and marks the object for redraw\nLayer.prototype.setState = function setState (updateObject) {\n  Object.assign(this.state, updateObject);\n  this.state.needsRedraw = true;\n};\n\nLayer.prototype.setNeedsRedraw = function setNeedsRedraw (redraw) {\n    if ( redraw === void 0 ) redraw = true;\n\n  if (this.state) {\n    this.state.needsRedraw = redraw;\n  }\n};\n\n// PROJECTION METHODS\n\n/**\n * Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n *\n * Note: Position conversion is done in shader, so in many cases there is no need\n * for this function\n * @param {Array|TypedArray} lngLat - long and lat values\n * @return {Array|TypedArray} - x, y coordinates\n */\nLayer.prototype.project = function project (lngLat) {\n  var ref = this.context;\n    var viewport = ref.viewport;\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n  return viewport.project(lngLat);\n};\n\nLayer.prototype.unproject = function unproject (xy) {\n  var ref = this.context;\n    var viewport = ref.viewport;\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n  return viewport.unproject(xy);\n};\n\nLayer.prototype.projectFlat = function projectFlat (lngLat) {\n  var ref = this.context;\n    var viewport = ref.viewport;\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n  return viewport.projectFlat(lngLat);\n};\n\nLayer.prototype.unprojectFlat = function unprojectFlat (xy) {\n  var ref = this.context;\n    var viewport = ref.viewport;\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n  return viewport.unprojectFlat(xy);\n};\n\nLayer.prototype.screenToDevicePixels = function screenToDevicePixels (screenPixels) {\n  var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n  return screenPixels * devicePixelRatio;\n};\n\n/**\n * Returns the picking color that doesn't match any subfeature\n * Use if some graphics do not belong to any pickable subfeature\n * @return {Array} - a black color\n */\nLayer.prototype.nullPickingColor = function nullPickingColor () {\n  return [0, 0, 0];\n};\n\n/**\n * Returns the picking color that doesn't match any subfeature\n * Use if some graphics do not belong to any pickable subfeature\n * @param {int} i - index to be decoded\n * @return {Array} - the decoded color\n */\nLayer.prototype.encodePickingColor = function encodePickingColor (i) {\n  return [(i + 1) % 256, Math.floor((i + 1) / 256) % 256, Math.floor((i + 1) / 256 / 256) % 256];\n};\n\n/**\n * Returns the picking color that doesn't match any subfeature\n * Use if some graphics do not belong to any pickable subfeature\n * @param {Uint8Array} color - color array to be decoded\n * @return {Array} - the decoded picking color\n */\nLayer.prototype.decodePickingColor = function decodePickingColor (color) {\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(color instanceof Uint8Array);\n  var i1 = color[0];\n    var i2 = color[1];\n    var i3 = color[2];\n  // 1 was added to seperate from no selection\n  var index = i1 + i2 * 256 + i3 * 65536 - 1;\n  return index;\n};\n\nLayer.prototype.calculateInstancePickingColors = function calculateInstancePickingColors (attribute, ref) {\n    var this$1 = this;\n    var numInstances = ref.numInstances;\n\n  var value = attribute.value;\n    var size = attribute.size;\n  // add 1 to index to seperate from no selection\n  for (var i = 0; i < numInstances; i++) {\n    var pickingColor = this$1.encodePickingColor(i);\n    value[i * size + 0] = pickingColor[0];\n    value[i * size + 1] = pickingColor[1];\n    value[i * size + 2] = pickingColor[2];\n  }\n};\n\n// DATA ACCESS API\n// Data can use iterators and may not be random access\n\n// Use iteration (the only required capability on data) to get first element\nLayer.prototype.getFirstObject = function getFirstObject () {\n  var ref = this.props;\n    var data = ref.data;\n  for (var i = 0, list = data; i < list.length; i += 1) {\n    var object = list[i];\n\n      return object;\n  }\n  return null;\n};\n\n// INTERNAL METHODS\n\n// Deduces numer of instances. Intention is to support:\n// - Explicit setting of numInstances\n// - Auto-deduction for ES6 containers that define a size member\n// - Auto-deduction for Classic Arrays via the built-in length attribute\n// - Auto-deduction via arrays\nLayer.prototype.getNumInstances = function getNumInstances (props) {\n  props = props || this.props;\n\n  // First check if the layer has set its own value\n  if (this.state && this.state.numInstances !== undefined) {\n    return this.state.numInstances;\n  }\n\n  // Check if app has provided an explicit value\n  if (props.numInstances !== undefined) {\n    return props.numInstances;\n  }\n\n  var data = props.data;\n\n  // Check if ES6 collection \"count\" function is available\n  if (data && typeof data.count === 'function') {\n    return data.count();\n  }\n\n  // Check if ES6 collection \"size\" attribute is set\n  if (data && data.size !== undefined) {\n    return data.size;\n  }\n\n  // Check if array length attribute is set\n  // Note: checking this last since some ES6 collections (Immutable.js)\n  // emit profuse warnings when trying to access `length` attribute\n  if (data && data.length !== undefined) {\n    return data.length;\n  }\n\n  throw new Error('Could not deduce numInstances');\n};\n\n// LAYER MANAGER API\n// Should only be called by the deck.gl LayerManager class\n\n// Called by layer manager when a new layer is found\n/* eslint-disable max-statements */\nLayer.prototype.initializeLayer = function initializeLayer (updateParams) {\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(this.context.gl, 'Layer context missing gl');\n  __WEBPACK_IMPORTED_MODULE_3_assert___default()(!this.state, 'Layer missing state');\n\n  this.state = {};\n\n  // Initialize state only once\n  this.setState({\n    attributeManager: new __WEBPACK_IMPORTED_MODULE_1__attribute_manager__[\"a\" /* default */]({ id: this.props.id }),\n    model: null,\n    needsRedraw: true,\n    dataChanged: true\n  });\n\n  // Add attribute manager loggers if provided\n  this.state.attributeManager.setLogFunctions(this.props);\n\n  var ref = this.state;\n    var attributeManager = ref.attributeManager;\n  // All instanced layers get instancePickingColors attribute by default\n  // Their shaders can use it to render a picking scene\n  // TODO - this slows down non instanced layers\n  attributeManager.addInstanced({\n    instancePickingColors: {\n      type: __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n      size: 3,\n      update: this.calculateInstancePickingColors\n    }\n  });\n\n  // Call subclass lifecycle methods\n  this.initializeState();\n  this.updateState(updateParams);\n  // End subclass lifecycle methods\n\n  // Add any subclass attributes\n  this._updateAttributes(this.props);\n  this._updateBaseUniforms();\n\n  var ref$1 = this.state;\n    var model = ref$1.model;\n  if (model) {\n    model.setInstanceCount(this.getNumInstances());\n    model.id = this.props.id;\n    model.program.id = (this.props.id) + \"-program\";\n    model.geometry.id = (this.props.id) + \"-geometry\";\n    model.setAttributes(attributeManager.getAttributes());\n  }\n};\n\n// Called by layer manager when existing layer is getting new props\nLayer.prototype.updateLayer = function updateLayer (updateParams) {\n  // Check for deprecated method\n  if (this.shouldUpdate) {\n    __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, (\"deck.gl v3 shouldUpdate deprecated. Use shouldUpdateState in \" + (this)));\n  }\n\n  // Call subclass lifecycle method\n  var stateNeedsUpdate = this.shouldUpdateState(updateParams);\n  // End lifecycle method\n\n  if (stateNeedsUpdate) {\n\n    // Call deprecated lifecycle method if defined\n    var hasRedefinedMethod = this.willReceiveProps && this.willReceiveProps !== Layer.prototype.willReceiveProps;\n    if (hasRedefinedMethod) {\n      __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, (\"deck.gl v3 willReceiveProps deprecated. Use updateState in \" + (this)));\n      var oldProps = updateParams.oldProps;\n        var props = updateParams.props;\n        var changeFlags = updateParams.changeFlags;\n      this.setState(changeFlags);\n      this.willReceiveProps(oldProps, props, changeFlags);\n      this.setState({\n        dataChanged: false,\n        viewportChanged: false\n      });\n    }\n    // End lifecycle method\n\n    // Call subclass lifecycle method\n    this.updateState(updateParams);\n    // End lifecycle method\n\n    // Run the attribute updaters\n    this._updateAttributes(updateParams.newProps);\n    this._updateBaseUniforms();\n\n    if (this.state.model) {\n      this.state.model.setInstanceCount(this.getNumInstances());\n    }\n  }\n};\n/* eslint-enable max-statements */\n\n// Called by manager when layer is about to be disposed\n// Note: not guaranteed to be called on application shutdown\nLayer.prototype.finalizeLayer = function finalizeLayer () {\n  // Call subclass lifecycle method\n  this.finalizeState();\n  // End lifecycle method\n};\n\n// Calculates uniforms\nLayer.prototype.drawLayer = function drawLayer (ref) {\n    var uniforms = ref.uniforms; if ( uniforms === void 0 ) uniforms = {};\n\n  // Call subclass lifecycle method\n  this.draw({ uniforms: uniforms });\n  // End lifecycle method\n};\n\n// {uniforms = {}, ...opts}\nLayer.prototype.pickLayer = function pickLayer (opts) {\n  // Call subclass lifecycle method\n  return this.pick(opts);\n  // End lifecycle method\n};\n\nLayer.prototype.diffProps = function diffProps (oldProps, newProps, context) {\n  // If any props have changed, ignoring updateTriggers objects\n  // (updateTriggers are expected to be a new object on every update)\n  var propsChangedReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* compareProps */])({\n    newProps: newProps,\n    oldProps: oldProps,\n    ignoreProps: { data: null, updateTriggers: null }\n  });\n\n  var dataChangedReason = this._diffDataProps(oldProps, newProps);\n\n  var propsChanged = Boolean(propsChangedReason);\n  var dataChanged = Boolean(dataChangedReason);\n  var viewportChanged = context.viewportChanged;\n  var somethingChanged = propsChanged || dataChanged || viewportChanged;\n\n  // If data hasn't changed, check update triggers\n  if (!dataChanged) {\n    this._diffUpdateTriggers(oldProps, newProps);\n  } else {\n    __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, (\"dataChanged: \" + dataChanged));\n  }\n\n  return {\n    propsChanged: propsChanged,\n    dataChanged: dataChanged,\n    viewportChanged: viewportChanged,\n    somethingChanged: somethingChanged,\n    reason: dataChangedReason || propsChangedReason\n  };\n};\n\n// Checks state of attributes and model\n// TODO - is attribute manager needed? - Model should be enough.\nLayer.prototype.getNeedsRedraw = function getNeedsRedraw (ref) {\n    if ( ref === void 0 ) ref = {};\n    var clearRedrawFlags = ref.clearRedrawFlags; if ( clearRedrawFlags === void 0 ) clearRedrawFlags = false;\n\n  // this method may be called by the render loop as soon a the layer\n  // has been created, so guard against uninitialized state\n  if (!this.state) {\n    return false;\n  }\n\n  var redraw = false;\n  redraw = redraw || this.state.needsRedraw;\n  this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;\n\n  var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    var model = ref$1.model;\n  redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });\n  redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });\n\n  return redraw;\n};\n\n// PRIVATE METHODS\n\n// The comparison of the data prop requires special handling\n// the dataComparator should be used if supplied\nLayer.prototype._diffDataProps = function _diffDataProps (oldProps, newProps) {\n  // Support optional app defined comparison of data\n  var dataComparator = newProps.dataComparator;\n  if (dataComparator) {\n    if (!dataComparator(newProps.data, oldProps.data)) {\n      return 'Data comparator detected a change';\n    }\n    // Otherwise, do a shallow equal on props\n  } else if (newProps.data !== oldProps.data) {\n    return 'A new data container was supplied';\n  }\n\n  return null;\n};\n\n// Checks if any update triggers have changed, and invalidate\n// attributes accordingly.\n/* eslint-disable max-statements */\nLayer.prototype._diffUpdateTriggers = function _diffUpdateTriggers (oldProps, newProps) {\n  var ref = this.state;\n    var attributeManager = ref.attributeManager;\n  if (!attributeManager) {\n    return false;\n  }\n\n  var change = false;\n\n  for (var propName in newProps.updateTriggers) {\n    var oldTriggers = oldProps.updateTriggers[propName];\n    var newTriggers = newProps.updateTriggers[propName];\n    var diffReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"b\" /* compareProps */])({\n      oldProps: oldTriggers,\n      newProps: newTriggers\n    });\n    if (diffReason) {\n      if (propName === 'all') {\n        __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, (\"updateTriggers invalidating all attributes: \" + diffReason));\n        attributeManager.invalidateAll();\n        change = true;\n      } else {\n        __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, (\"updateTriggers invalidating attribute \" + propName + \": \" + diffReason));\n        attributeManager.invalidate(propName);\n        change = true;\n      }\n    }\n  }\n\n  return change;\n};\n/* eslint-enable max-statements */\n\nLayer.prototype.validateRequiredProp = function validateRequiredProp (propertyName, condition) {\n  var value = this.props[propertyName];\n  if (value === undefined) {\n    throw new Error((\"Property \" + propertyName + \" undefined in layer \" + (this)));\n  }\n  if (condition && !condition(value)) {\n    throw new Error((\"Bad property \" + propertyName + \" in layer \" + (this)));\n  }\n};\n\n// Calls attribute manager to update any WebGL attributes\nLayer.prototype._updateAttributes = function _updateAttributes (props) {\n  var ref = this.state;\n    var attributeManager = ref.attributeManager;\n    var model = ref.model;\n  if (!attributeManager) {\n    return;\n  }\n\n  var numInstances = this.getNumInstances(props);\n  // Figure out data length\n  attributeManager.update({\n    numInstances: numInstances,\n    bufferMap: props,\n    context: this,\n    // Don't worry about non-attribute props\n    ignoreUnknownAttributes: true\n  });\n  if (model) {\n    var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });\n    model.setAttributes(changedAttributes);\n  }\n};\n\nLayer.prototype._updateBaseUniforms = function _updateBaseUniforms () {\n  this.setUniforms({\n    // apply gamma to opacity to make it visually \"linear\"\n    opacity: Math.pow(this.props.opacity, 1 / 2.2),\n    ONE: 1.0\n  });\n};\n\n// DEPRECATED METHODS\n// shouldUpdate() {}\n\nLayer.prototype.willReceiveProps = function willReceiveProps () {};\n\n// Updates selected state members and marks the object for redraw\nLayer.prototype.setUniforms = function setUniforms (uniformMap) {\n  if (this.state.model) {\n    this.state.model.setUniforms(uniformMap);\n  }\n  // TODO - set needsRedraw on the model?\n  this.state.needsRedraw = true;\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */])(3, 'layer.setUniforms', uniformMap);\n};\n\nLayer.prototype._validateDeprecatedProps = function _validateDeprecatedProps () {\n  if (this.props.isPickable !== undefined) {\n    __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, 'No isPickable prop in deckgl v3 - use pickable instead');\n  }\n\n  // TODO - inject viewport from overlay instead of creating for each layer?\n  var hasViewportProps =\n  // this.props.width !== undefined ||\n  // this.props.height !== undefined ||\n  this.props.latitude !== undefined || this.props.longitude !== undefined || this.props.zoom !== undefined || this.props.pitch !== undefined || this.props.bearing !== undefined;\n  if (hasViewportProps) {\n    /* eslint-disable no-console */\n    // /* global console */\n    __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, (\"deck.gl v3 no longer needs viewport props in Layer \" + (this)));\n  }\n};\n\n/* harmony default export */ exports[\"a\"] = Layer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9sYXllci5qcz9jM2U2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgeyBHTCB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IEF0dHJpYnV0ZU1hbmFnZXIgZnJvbSAnLi9hdHRyaWJ1dGUtbWFuYWdlcic7XG5pbXBvcnQgeyBjb21wYXJlUHJvcHMsIGxvZyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLmlkIC0gbGF5ZXIgbmFtZVxuICogQHBhcmFtIHthcnJheX0gIHByb3BzLmRhdGEgLSBhcnJheSBvZiBkYXRhIGluc3RhbmNlc1xuICogQHBhcmFtIHtib29sfSBwcm9wcy5vcGFjaXR5IC0gb3BhY2l0eSBvZiB0aGUgbGF5ZXJcbiAqL1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBkYXRhOiBbXSxcbiAgZGF0YUl0ZXJhdG9yOiBudWxsLFxuICBkYXRhQ29tcGFyYXRvcjogbnVsbCxcbiAgbnVtSW5zdGFuY2VzOiB1bmRlZmluZWQsXG4gIHZpc2libGU6IHRydWUsXG4gIHBpY2thYmxlOiBmYWxzZSxcbiAgb3BhY2l0eTogMC44LFxuICBvbkhvdmVyOiAoKSA9PiB7fSxcbiAgb25DbGljazogKCkgPT4ge30sXG4gIGdldFZhbHVlOiB4ID0+IHgsXG4gIC8vIFVwZGF0ZSB0cmlnZ2VyczogYSBrZXkgY2hhbmdlIGRldGVjdGlvbiBtZWNoYW5pc20gaW4gZGVjay5nbFxuICAvLyBTZWUgbGF5ZXIgZG9jdW1lbnRhdGlvblxuICB1cGRhdGVUcmlnZ2Vyczoge31cbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBCYXNlIExheWVyIGNsYXNzXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBTZWUgZG9jcyBhYm92ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgcHJvcHMsIHtcbiAgICAgIC8vIEFjY2VwdCBudWxsIGFzIGRhdGEgLSBvdGhlcndpc2UgYXBwcyB3aWxsIG5lZWQgdG8gYWRkIHVnbHkgY2hlY2tzXG4gICAgICBkYXRhOiBwcm9wcy5kYXRhIHx8IFtdLFxuICAgICAgaWQ6IHByb3BzLmlkIHx8IHRoaXMuY29uc3RydWN0b3IubGF5ZXJOYW1lXG4gICAgfSk7XG5cbiAgICB0aGlzLmlkID0gcHJvcHMuaWQ7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKztcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5vbGRQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcblxuICAgIHRoaXMudmFsaWRhdGVSZXF1aXJlZFByb3AoJ2lkJywgeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycpO1xuICAgIHRoaXMudmFsaWRhdGVSZXF1aXJlZFByb3AoJ2RhdGEnKTtcbiAgICAvLyBUT0RPIC0gYWxsb3cgYXBwIHRvIHN1cHBseSBkYXRhSXRlcmF0b3IgcHJvcD9cbiAgICAvLyBpZiAocHJvcHMuZGF0YSkge1xuICAgIC8vICAgYWRkSXRlcmF0b3IocHJvcHMuZGF0YSk7XG4gICAgLy8gICBpZiAoIXByb3BzLmRhdGFbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgIC8vICAgICBsb2cub25jZSgwLCAnZGF0YSBwcm9wIG11c3QgaGF2ZSBpdGVyYXRvcicpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIHRoaXMuX3ZhbGlkYXRlRGVwcmVjYXRlZFByb3BzKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIGNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy5pZCA/IGA8JHsgY2xhc3NOYW1lIH06JyR7IHRoaXMucHJvcHMuaWQgfSc+YCA6IGA8JHsgY2xhc3NOYW1lIH0+YDtcbiAgfVxuXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIExJRkVDWUNMRSBNRVRIT0RTLCBvdmVycmlkZGVuIGJ5IHRoZSBsYXllciBzdWJjbGFzc2VzXG5cbiAgLy8gQ2FsbGVkIG9uY2UgdG8gc2V0IHVwIHRoZSBpbml0aWFsIHN0YXRlXG4gIC8vIEFwcCBjYW4gY3JlYXRlIFdlYkdMIHJlc291cmNlc1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciAkeyB0aGlzIH0gaGFzIG5vdCBkZWZpbmVkIGluaXRpYWxpemVTdGF0ZWApO1xuICB9XG5cbiAgLy8gQ2FsbGVkIG9uY2Ugd2hlbiBsYXllciBpcyBubyBsb25nZXIgbWF0Y2hlZCBhbmQgc3RhdGUgd2lsbCBiZSBkaXNjYXJkZWRcbiAgLy8gQXBwIGNhbiBkZXN0cm95IFdlYkdMIHJlc291cmNlc1xuICBmaW5hbGl6ZVN0YXRlKCkge31cblxuICBzaG91bGRVcGRhdGVTdGF0ZSh7IG9sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3MgfSkge1xuICAgIHJldHVybiBjaGFuZ2VGbGFncy5zb21ldGhpbmdDaGFuZ2VkO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgYWxsIGF0dHJpYnV0ZU1hbmFnZXIgd2lsbCBiZSB1cGRhdGVkXG4gIHVwZGF0ZVN0YXRlKHsgb2xkUHJvcHMsIHByb3BzLCBvbGRDb250ZXh0LCBjb250ZXh0LCBjaGFuZ2VGbGFncyB9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkICYmIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbXBsZW1lbnQgdG8gZ2VuZXJhdGUgc3VibGF5ZXJzXG4gIHJlbmRlckxheWVycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHN0YXRlIGhhcyBhIG1vZGVsLCBkcmF3IGl0IHdpdGggc3VwcGxpZWQgdW5pZm9ybXNcbiAgZHJhdyh7IHVuaWZvcm1zID0ge30gfSkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBwaWNrKHsgaW5mbywgdW5pZm9ybXMsIHBpY2tFbmFibGVVbmlmb3JtcywgcGlja0Rpc2FibGVVbmlmb3JtcywgbW9kZSB9KSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG1vZGVsLnNldFVuaWZvcm1zKHBpY2tFbmFibGVVbmlmb3Jtcyk7XG4gICAgICBtb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgICAgbW9kZWwuc2V0VW5pZm9ybXMocGlja0Rpc2FibGVVbmlmb3Jtcyk7XG5cbiAgICAgIC8vIFJlYWQgY29sb3IgaW4gdGhlIGNlbnRyYWwgcGl4ZWwsIHRvIGJlIG1hcHBlZCB3aXRoIHBpY2tpbmcgY29sb3JzXG4gICAgICBjb25zdCBbeCwgeV0gPSBpbmZvLmRldmljZVBpeGVsO1xuICAgICAgY29uc3QgY29sb3IgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgMSwgMSwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgY29sb3IpO1xuXG4gICAgICAvLyBJbmRleCA8IDAgbWVhbnMgbm90aGluZyBzZWxlY3RlZFxuICAgICAgaW5mby5pbmRleCA9IHRoaXMuZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKTtcbiAgICAgIGluZm8uY29sb3IgPSBjb2xvcjtcblxuICAgICAgLy8gVE9ETyAtIHNlbGVjdGVkUGlja2luZ0NvbG9yIHNob3VsZCBiZSByZW1vdmVkP1xuICAgICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRQaWNraW5nQ29sb3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclswXSA9IGNvbG9yWzBdO1xuICAgICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclsxXSA9IGNvbG9yWzFdO1xuICAgICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclsyXSA9IGNvbG9yWzJdO1xuICAgICAgICB0aGlzLnNldFVuaWZvcm1zKHsgc2VsZWN0ZWRQaWNraW5nQ29sb3IgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvLyBFTkQgTElGRUNZQ0xFIE1FVEhPRFNcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvLyBQdWJsaWMgQVBJXG5cbiAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcbiAgc2V0U3RhdGUodXBkYXRlT2JqZWN0KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB1cGRhdGVPYmplY3QpO1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIH1cbiAgfVxuXG4gIC8vIFBST0pFQ1RJT04gTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyBhIHBvaW50IHdpdGggY3VycmVudCBtYXAgc3RhdGUgKGxhdCwgbG9uLCB6b29tLCBwaXRjaCwgYmVhcmluZylcbiAgICpcbiAgICogTm90ZTogUG9zaXRpb24gY29udmVyc2lvbiBpcyBkb25lIGluIHNoYWRlciwgc28gaW4gbWFueSBjYXNlcyB0aGVyZSBpcyBubyBuZWVkXG4gICAqIGZvciB0aGlzIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gbG5nTGF0IC0gbG9uZyBhbmQgbGF0IHZhbHVlc1xuICAgKiBAcmV0dXJuIHtBcnJheXxUeXBlZEFycmF5fSAtIHgsIHkgY29vcmRpbmF0ZXNcbiAgICovXG4gIHByb2plY3QobG5nTGF0KSB7XG4gICAgY29uc3QgeyB2aWV3cG9ydCB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7IHZpZXdwb3J0IH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnVucHJvamVjdCh4eSk7XG4gIH1cblxuICBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICBjb25zdCB7IHZpZXdwb3J0IH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3RGbGF0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3RGbGF0KHh5KSB7XG4gICAgY29uc3QgeyB2aWV3cG9ydCB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICByZXR1cm4gc2NyZWVuUGl4ZWxzICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIGEgYmxhY2sgY29sb3JcbiAgICovXG4gIG51bGxQaWNraW5nQ29sb3IoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgKiBVc2UgaWYgc29tZSBncmFwaGljcyBkbyBub3QgYmVsb25nIHRvIGFueSBwaWNrYWJsZSBzdWJmZWF0dXJlXG4gICAqIEBwYXJhbSB7aW50fSBpIC0gaW5kZXggdG8gYmUgZGVjb2RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBjb2xvclxuICAgKi9cbiAgZW5jb2RlUGlja2luZ0NvbG9yKGkpIHtcbiAgICByZXR1cm4gWyhpICsgMSkgJSAyNTYsIE1hdGguZmxvb3IoKGkgKyAxKSAvIDI1NikgJSAyNTYsIE1hdGguZmxvb3IoKGkgKyAxKSAvIDI1NiAvIDI1NikgJSAyNTZdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb2xvciAtIGNvbG9yIGFycmF5IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgcGlja2luZyBjb2xvclxuICAgKi9cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgLy8gMSB3YXMgYWRkZWQgdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBjb25zdCBpbmRleCA9IGkxICsgaTIgKiAyNTYgKyBpMyAqIDY1NTM2IC0gMTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7IG51bUluc3RhbmNlcyB9KSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIC8vIGFkZCAxIHRvIGluZGV4IHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbnN0YW5jZXM7IGkrKykge1xuICAgICAgY29uc3QgcGlja2luZ0NvbG9yID0gdGhpcy5lbmNvZGVQaWNraW5nQ29sb3IoaSk7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDBdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAxXSA9IHBpY2tpbmdDb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMl0gPSBwaWNraW5nQ29sb3JbMl07XG4gICAgfVxuICB9XG5cbiAgLy8gREFUQSBBQ0NFU1MgQVBJXG4gIC8vIERhdGEgY2FuIHVzZSBpdGVyYXRvcnMgYW5kIG1heSBub3QgYmUgcmFuZG9tIGFjY2Vzc1xuXG4gIC8vIFVzZSBpdGVyYXRpb24gKHRoZSBvbmx5IHJlcXVpcmVkIGNhcGFiaWxpdHkgb24gZGF0YSkgdG8gZ2V0IGZpcnN0IGVsZW1lbnRcbiAgZ2V0Rmlyc3RPYmplY3QoKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIERlZHVjZXMgbnVtZXIgb2YgaW5zdGFuY2VzLiBJbnRlbnRpb24gaXMgdG8gc3VwcG9ydDpcbiAgLy8gLSBFeHBsaWNpdCBzZXR0aW5nIG9mIG51bUluc3RhbmNlc1xuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBFUzYgY29udGFpbmVycyB0aGF0IGRlZmluZSBhIHNpemUgbWVtYmVyXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIHZpYSBhcnJheXNcbiAgZ2V0TnVtSW5zdGFuY2VzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGxheWVyIGhhcyBzZXQgaXRzIG93biB2YWx1ZVxuICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhcHAgaGFzIHByb3ZpZGVkIGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgaWYgKHByb3BzLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvcHMubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gcHJvcHM7XG5cbiAgICAvLyBDaGVjayBpZiBFUzYgY29sbGVjdGlvbiBcImNvdW50XCIgZnVuY3Rpb24gaXMgYXZhaWxhYmxlXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEuY291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkYXRhLmNvdW50KCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgRVM2IGNvbGxlY3Rpb24gXCJzaXplXCIgYXR0cmlidXRlIGlzIHNldFxuICAgIGlmIChkYXRhICYmIGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFycmF5IGxlbmd0aCBhdHRyaWJ1dGUgaXMgc2V0XG4gICAgLy8gTm90ZTogY2hlY2tpbmcgdGhpcyBsYXN0IHNpbmNlIHNvbWUgRVM2IGNvbGxlY3Rpb25zIChJbW11dGFibGUuanMpXG4gICAgLy8gZW1pdCBwcm9mdXNlIHdhcm5pbmdzIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyBgbGVuZ3RoYCBhdHRyaWJ1dGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGVkdWNlIG51bUluc3RhbmNlcycpO1xuICB9XG5cbiAgLy8gTEFZRVIgTUFOQUdFUiBBUElcbiAgLy8gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IHRoZSBkZWNrLmdsIExheWVyTWFuYWdlciBjbGFzc1xuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gYSBuZXcgbGF5ZXIgaXMgZm91bmRcbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgaW5pdGlhbGl6ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQuZ2wsICdMYXllciBjb250ZXh0IG1pc3NpbmcgZ2wnKTtcbiAgICBhc3NlcnQoIXRoaXMuc3RhdGUsICdMYXllciBtaXNzaW5nIHN0YXRlJyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG5cbiAgICAvLyBJbml0aWFsaXplIHN0YXRlIG9ubHkgb25jZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYXR0cmlidXRlTWFuYWdlcjogbmV3IEF0dHJpYnV0ZU1hbmFnZXIoeyBpZDogdGhpcy5wcm9wcy5pZCB9KSxcbiAgICAgIG1vZGVsOiBudWxsLFxuICAgICAgbmVlZHNSZWRyYXc6IHRydWUsXG4gICAgICBkYXRhQ2hhbmdlZDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGF0dHJpYnV0ZSBtYW5hZ2VyIGxvZ2dlcnMgaWYgcHJvdmlkZWRcbiAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuc2V0TG9nRnVuY3Rpb25zKHRoaXMucHJvcHMpO1xuXG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAvLyBUaGVpciBzaGFkZXJzIGNhbiB1c2UgaXQgdG8gcmVuZGVyIGEgcGlja2luZyBzY2VuZVxuICAgIC8vIFRPRE8gLSB0aGlzIHNsb3dzIGRvd24gbm9uIGluc3RhbmNlZCBsYXllcnNcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQWRkIGFueSBzdWJjbGFzcyBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyh0aGlzLnByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgbW9kZWwuaWQgPSB0aGlzLnByb3BzLmlkO1xuICAgICAgbW9kZWwucHJvZ3JhbS5pZCA9IGAkeyB0aGlzLnByb3BzLmlkIH0tcHJvZ3JhbWA7XG4gICAgICBtb2RlbC5nZW9tZXRyeS5pZCA9IGAkeyB0aGlzLnByb3BzLmlkIH0tZ2VvbWV0cnlgO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVNYW5hZ2VyLmdldEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBleGlzdGluZyBsYXllciBpcyBnZXR0aW5nIG5ldyBwcm9wc1xuICB1cGRhdGVMYXllcih1cGRhdGVQYXJhbXMpIHtcbiAgICAvLyBDaGVjayBmb3IgZGVwcmVjYXRlZCBtZXRob2RcbiAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIHYzIHNob3VsZFVwZGF0ZSBkZXByZWNhdGVkLiBVc2Ugc2hvdWxkVXBkYXRlU3RhdGUgaW4gJHsgdGhpcyB9YCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgY29uc3Qgc3RhdGVOZWVkc1VwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgaWYgKHN0YXRlTmVlZHNVcGRhdGUpIHtcblxuICAgICAgLy8gQ2FsbCBkZXByZWNhdGVkIGxpZmVjeWNsZSBtZXRob2QgaWYgZGVmaW5lZFxuICAgICAgY29uc3QgaGFzUmVkZWZpbmVkTWV0aG9kID0gdGhpcy53aWxsUmVjZWl2ZVByb3BzICYmIHRoaXMud2lsbFJlY2VpdmVQcm9wcyAhPT0gTGF5ZXIucHJvdG90eXBlLndpbGxSZWNlaXZlUHJvcHM7XG4gICAgICBpZiAoaGFzUmVkZWZpbmVkTWV0aG9kKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIHYzIHdpbGxSZWNlaXZlUHJvcHMgZGVwcmVjYXRlZC4gVXNlIHVwZGF0ZVN0YXRlIGluICR7IHRoaXMgfWApO1xuICAgICAgICBjb25zdCB7IG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MgfSA9IHVwZGF0ZVBhcmFtcztcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjaGFuZ2VGbGFncyk7XG4gICAgICAgIHRoaXMud2lsbFJlY2VpdmVQcm9wcyhvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAgIHZpZXdwb3J0Q2hhbmdlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICAgIC8vIFJ1biB0aGUgYXR0cmlidXRlIHVwZGF0ZXJzXG4gICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKHVwZGF0ZVBhcmFtcy5uZXdQcm9wcyk7XG4gICAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRJbnN0YW5jZUNvdW50KHRoaXMuZ2V0TnVtSW5zdGFuY2VzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLy8gQ2FsbGVkIGJ5IG1hbmFnZXIgd2hlbiBsYXllciBpcyBhYm91dCB0byBiZSBkaXNwb3NlZFxuICAvLyBOb3RlOiBub3QgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgb24gYXBwbGljYXRpb24gc2h1dGRvd25cbiAgZmluYWxpemVMYXllcigpIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmZpbmFsaXplU3RhdGUoKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlcyB1bmlmb3Jtc1xuICBkcmF3TGF5ZXIoeyB1bmlmb3JtcyA9IHt9IH0pIHtcbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICB0aGlzLmRyYXcoeyB1bmlmb3JtcyB9KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8ge3VuaWZvcm1zID0ge30sIC4uLm9wdHN9XG4gIHBpY2tMYXllcihvcHRzKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMucGljayhvcHRzKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgZGlmZlByb3BzKG9sZFByb3BzLCBuZXdQcm9wcywgY29udGV4dCkge1xuICAgIC8vIElmIGFueSBwcm9wcyBoYXZlIGNoYW5nZWQsIGlnbm9yaW5nIHVwZGF0ZVRyaWdnZXJzIG9iamVjdHNcbiAgICAvLyAodXBkYXRlVHJpZ2dlcnMgYXJlIGV4cGVjdGVkIHRvIGJlIGEgbmV3IG9iamVjdCBvbiBldmVyeSB1cGRhdGUpXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBpZ25vcmVQcm9wczogeyBkYXRhOiBudWxsLCB1cGRhdGVUcmlnZ2VyczogbnVsbCB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBkYXRhQ2hhbmdlZFJlYXNvbiA9IHRoaXMuX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9IEJvb2xlYW4ocHJvcHNDaGFuZ2VkUmVhc29uKTtcbiAgICBjb25zdCBkYXRhQ2hhbmdlZCA9IEJvb2xlYW4oZGF0YUNoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IGNvbnRleHQudmlld3BvcnRDaGFuZ2VkO1xuICAgIGNvbnN0IHNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc0NoYW5nZWQgfHwgZGF0YUNoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgLy8gSWYgZGF0YSBoYXNuJ3QgY2hhbmdlZCwgY2hlY2sgdXBkYXRlIHRyaWdnZXJzXG4gICAgaWYgKCFkYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coMSwgYGRhdGFDaGFuZ2VkOiAkeyBkYXRhQ2hhbmdlZCB9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzQ2hhbmdlZCxcbiAgICAgIGRhdGFDaGFuZ2VkLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkLFxuICAgICAgc29tZXRoaW5nQ2hhbmdlZCxcbiAgICAgIHJlYXNvbjogZGF0YUNoYW5nZWRSZWFzb24gfHwgcHJvcHNDaGFuZ2VkUmVhc29uXG4gICAgfTtcbiAgfVxuXG4gIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICAvLyBUT0RPIC0gaXMgYXR0cmlidXRlIG1hbmFnZXIgbmVlZGVkPyAtIE1vZGVsIHNob3VsZCBiZSBlbm91Z2guXG4gIGdldE5lZWRzUmVkcmF3KHsgY2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlIH0gPSB7fSkge1xuICAgIC8vIHRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYnkgdGhlIHJlbmRlciBsb29wIGFzIHNvb24gYSB0aGUgbGF5ZXJcbiAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLCBzbyBndWFyZCBhZ2FpbnN0IHVuaW5pdGlhbGl6ZWQgc3RhdGVcbiAgICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkcmF3ID0gZmFsc2U7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMuc3RhdGUubmVlZHNSZWRyYXc7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgJiYgIWNsZWFyUmVkcmF3RmxhZ3M7XG5cbiAgICBjb25zdCB7IGF0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIuZ2V0TmVlZHNSZWRyYXcoeyBjbGVhclJlZHJhd0ZsYWdzIH0pO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBtb2RlbCAmJiBtb2RlbC5nZXROZWVkc1JlZHJhdyh7IGNsZWFyUmVkcmF3RmxhZ3MgfSk7XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gVGhlIGNvbXBhcmlzb24gb2YgdGhlIGRhdGEgcHJvcCByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4gIC8vIHRoZSBkYXRhQ29tcGFyYXRvciBzaG91bGQgYmUgdXNlZCBpZiBzdXBwbGllZFxuICBfZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBTdXBwb3J0IG9wdGlvbmFsIGFwcCBkZWZpbmVkIGNvbXBhcmlzb24gb2YgZGF0YVxuICAgIGNvbnN0IHsgZGF0YUNvbXBhcmF0b3IgfSA9IG5ld1Byb3BzO1xuICAgIGlmIChkYXRhQ29tcGFyYXRvcikge1xuICAgICAgaWYgKCFkYXRhQ29tcGFyYXRvcihuZXdQcm9wcy5kYXRhLCBvbGRQcm9wcy5kYXRhKSkge1xuICAgICAgICByZXR1cm4gJ0RhdGEgY29tcGFyYXRvciBkZXRlY3RlZCBhIGNoYW5nZSc7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICAgIH0gZWxzZSBpZiAobmV3UHJvcHMuZGF0YSAhPT0gb2xkUHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuICdBIG5ldyBkYXRhIGNvbnRhaW5lciB3YXMgc3VwcGxpZWQnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkLCBhbmQgaW52YWxpZGF0ZVxuICAvLyBhdHRyaWJ1dGVzIGFjY29yZGluZ2x5LlxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlTWFuYWdlciB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY2hhbmdlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgICBjb25zdCBvbGRUcmlnZ2VycyA9IG9sZFByb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXTtcbiAgICAgIGNvbnN0IG5ld1RyaWdnZXJzID0gbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnNbcHJvcE5hbWVdO1xuICAgICAgY29uc3QgZGlmZlJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICAgIG9sZFByb3BzOiBvbGRUcmlnZ2VycyxcbiAgICAgICAgbmV3UHJvcHM6IG5ld1RyaWdnZXJzXG4gICAgICB9KTtcbiAgICAgIGlmIChkaWZmUmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsb2cubG9nKDEsIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYWxsIGF0dHJpYnV0ZXM6ICR7IGRpZmZSZWFzb24gfWApO1xuICAgICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLmxvZygxLCBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGF0dHJpYnV0ZSAkeyBwcm9wTmFtZSB9OiAkeyBkaWZmUmVhc29uIH1gKTtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUocHJvcE5hbWUpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICB2YWxpZGF0ZVJlcXVpcmVkUHJvcChwcm9wZXJ0eU5hbWUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wc1twcm9wZXJ0eU5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICR7IHByb3BlcnR5TmFtZSB9IHVuZGVmaW5lZCBpbiBsYXllciAkeyB0aGlzIH1gKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbiAmJiAhY29uZGl0aW9uKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgcHJvcGVydHkgJHsgcHJvcGVydHlOYW1lIH0gaW4gbGF5ZXIgJHsgdGhpcyB9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbHMgYXR0cmlidXRlIG1hbmFnZXIgdG8gdXBkYXRlIGFueSBXZWJHTCBhdHRyaWJ1dGVzXG4gIF91cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBudW1JbnN0YW5jZXMgPSB0aGlzLmdldE51bUluc3RhbmNlcyhwcm9wcyk7XG4gICAgLy8gRmlndXJlIG91dCBkYXRhIGxlbmd0aFxuICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgIG51bUluc3RhbmNlcyxcbiAgICAgIGJ1ZmZlck1hcDogcHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgbm9uLWF0dHJpYnV0ZSBwcm9wc1xuICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRDaGFuZ2VkQXR0cmlidXRlcyh7IGNsZWFyQ2hhbmdlZEZsYWdzOiB0cnVlIH0pO1xuICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9KTtcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuICAvLyBzaG91bGRVcGRhdGUoKSB7fVxuXG4gIHdpbGxSZWNlaXZlUHJvcHMoKSB7fVxuXG4gIC8vIFVwZGF0ZXMgc2VsZWN0ZWQgc3RhdGUgbWVtYmVycyBhbmQgbWFya3MgdGhlIG9iamVjdCBmb3IgcmVkcmF3XG4gIHNldFVuaWZvcm1zKHVuaWZvcm1NYXApIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3JtTWFwKTtcbiAgICB9XG4gICAgLy8gVE9ETyAtIHNldCBuZWVkc1JlZHJhdyBvbiB0aGUgbW9kZWw/XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgbG9nKDMsICdsYXllci5zZXRVbmlmb3JtcycsIHVuaWZvcm1NYXApO1xuICB9XG5cbiAgX3ZhbGlkYXRlRGVwcmVjYXRlZFByb3BzKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmlzUGlja2FibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nLm9uY2UoMCwgJ05vIGlzUGlja2FibGUgcHJvcCBpbiBkZWNrZ2wgdjMgLSB1c2UgcGlja2FibGUgaW5zdGVhZCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLSBpbmplY3Qgdmlld3BvcnQgZnJvbSBvdmVybGF5IGluc3RlYWQgb2YgY3JlYXRpbmcgZm9yIGVhY2ggbGF5ZXI/XG4gICAgY29uc3QgaGFzVmlld3BvcnRQcm9wcyA9XG4gICAgLy8gdGhpcy5wcm9wcy53aWR0aCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgLy8gdGhpcy5wcm9wcy5oZWlnaHQgIT09IHVuZGVmaW5lZCB8fFxuICAgIHRoaXMucHJvcHMubGF0aXR1ZGUgIT09IHVuZGVmaW5lZCB8fCB0aGlzLnByb3BzLmxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMucHJvcHMuem9vbSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMucHJvcHMucGl0Y2ggIT09IHVuZGVmaW5lZCB8fCB0aGlzLnByb3BzLmJlYXJpbmcgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoaGFzVmlld3BvcnRQcm9wcykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgLy8gLyogZ2xvYmFsIGNvbnNvbGUgKi9cbiAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIHYzIG5vIGxvbmdlciBuZWVkcyB2aWV3cG9ydCBwcm9wcyBpbiBMYXllciAkeyB0aGlzIH1gKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi9sYXllci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 21 */
/* exports provided: isPlainObject */
/* exports used: isPlainObject */
/*!******************************************!*\
  !*** ./src/lib/utils/object-iterator.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ exports[\"a\"] = isPlainObject;\n// Enable classic JavaScript object maps to be used as data\n\n// export function* makeObjectValueIterator(obj) {\n//   for (const key in obj) {\n//     if (obj.hasOwnProperty(key)) {\n//       yield obj[key];\n//     }\n//   }\n// }\n\n// export function addIterator(object) {\n//   if (isPlainObject(object) && !object[Symbol.iterator]) {\n//     object[Symbol.iterator] = function iterator() {\n//       return makeObjectValueIterator(object);\n//     };\n//   }\n// }\n\nfunction isPlainObject(o) {\n  return o !== null && typeof o === 'object' && o.constructor === Object;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi91dGlscy9vYmplY3QtaXRlcmF0b3IuanM/MjUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmFibGUgY2xhc3NpYyBKYXZhU2NyaXB0IG9iamVjdCBtYXBzIHRvIGJlIHVzZWQgYXMgZGF0YVxuXG4vLyBleHBvcnQgZnVuY3Rpb24qIG1ha2VPYmplY3RWYWx1ZUl0ZXJhdG9yKG9iaikge1xuLy8gICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbi8vICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbi8vICAgICAgIHlpZWxkIG9ialtrZXldO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYWRkSXRlcmF0b3Iob2JqZWN0KSB7XG4vLyAgIGlmIChpc1BsYWluT2JqZWN0KG9iamVjdCkgJiYgIW9iamVjdFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4vLyAgICAgb2JqZWN0W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbi8vICAgICAgIHJldHVybiBtYWtlT2JqZWN0VmFsdWVJdGVyYXRvcihvYmplY3QpO1xuLy8gICAgIH07XG4vLyAgIH1cbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICByZXR1cm4gbyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3V0aWxzL29iamVjdC1pdGVyYXRvci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 22 */
/* unknown exports provided */
/* exports used: default */
/*!************************************!*\
  !*** external "geojson-normalize" ***!
  \************************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_22__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJnZW9qc29uLW5vcm1hbGl6ZVwiP2FmZjUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzIyX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJnZW9qc29uLW5vcm1hbGl6ZVwiXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 23 */
/* unknown exports provided */
/* exports used: PropTypes, createElement, default */
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_23__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiPzNjNjIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzIzX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWFjdFwiXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 24 */
/* exports provided: default */
/* exports used: default */
/*!********************************************!*\
  !*** ./src/layers/core/arc-layer/index.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arc_layer__ = __webpack_require__(/*! ./arc-layer */ 38);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__arc_layer__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL2FyYy1sYXllci9pbmRleC5qcz8xZTYxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2FyYy1sYXllcic7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 25 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/layers/core/choropleth-layer/index.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__choropleth_layer__ = __webpack_require__(/*! ./choropleth-layer */ 39);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__choropleth_layer__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL2Nob3JvcGxldGgtbGF5ZXIvaW5kZXguanM/NDNhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9jb3JlL2Nob3JvcGxldGgtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 26 */
/* exports provided: default */
/* exports used: default */
/*!*********************************************!*\
  !*** ./src/layers/core/line-layer/index.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__line_layer__ = __webpack_require__(/*! ./line-layer */ 40);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__line_layer__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL2xpbmUtbGF5ZXIvaW5kZXguanM/ZDg1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9saW5lLWxheWVyJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9jb3JlL2xpbmUtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 27 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/layers/core/screen-grid-layer/index.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__screen_grid_layer__ = __webpack_require__(/*! ./screen-grid-layer */ 42);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__screen_grid_layer__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL3NjcmVlbi1ncmlkLWxheWVyL2luZGV4LmpzPzZlMmUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vc2NyZWVuLWdyaWQtbGF5ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 28 */
/* exports provided: default */
/* exports used: default */
/*!********************************************!*\
  !*** ./src/layers/fp64/arc-layer/index.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arc_layer_64__ = __webpack_require__(/*! ./arc-layer-64 */ 43);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__arc_layer_64__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2FyYy1sYXllci9pbmRleC5qcz82ZThkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2FyYy1sYXllci02NCc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sYXllcnMvZnA2NC9hcmMtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 29 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/layers/fp64/choropleth-layer/index.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__choropleth_layer_64__ = __webpack_require__(/*! ./choropleth-layer-64 */ 44);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__choropleth_layer_64__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2Nob3JvcGxldGgtbGF5ZXIvaW5kZXguanM/NDZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyLTY0JztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9mcDY0L2Nob3JvcGxldGgtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 30 */
/* exports provided: default */
/* exports used: default */
/*!************************************************************!*\
  !*** ./src/layers/fp64/extruded-choropleth-layer/index.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extruded_choropleth_layer_64__ = __webpack_require__(/*! ./extruded-choropleth-layer-64 */ 45);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__extruded_choropleth_layer_64__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXIvaW5kZXguanM/NThhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0JztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9mcDY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 31 */
/* exports provided: default */
/* exports used: default */
/*!*********************************************!*\
  !*** ./src/layers/fp64/line-layer/index.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__line_layer_64__ = __webpack_require__(/*! ./line-layer-64 */ 46);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__line_layer_64__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2xpbmUtbGF5ZXIvaW5kZXguanM/ZDJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9saW5lLWxheWVyLTY0JztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9mcDY0L2xpbmUtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 32 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/layers/fp64/scatterplot-layer/index.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scatterplot_layer_64__ = __webpack_require__(/*! ./scatterplot-layer-64 */ 47);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__scatterplot_layer_64__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L3NjYXR0ZXJwbG90LWxheWVyL2luZGV4LmpzP2FjY2IiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vc2NhdHRlcnBsb3QtbGF5ZXItNjQnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2ZwNjQvc2NhdHRlcnBsb3QtbGF5ZXIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 33 */
/* exports provided: ReflectionEffect */
/* exports used:  */
/*!*******************************************!*\
  !*** ./src/experimental/effects/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__reflection_effect__ = __webpack_require__(/*! ./reflection-effect */ 16);\n/* unused harmony reexport ReflectionEffect */\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2V4cGVyaW1lbnRhbC9lZmZlY3RzL2luZGV4LmpzPzk4OTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWZsZWN0aW9uRWZmZWN0IH0gZnJvbSAnLi9yZWZsZWN0aW9uLWVmZmVjdCc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9leHBlcmltZW50YWwvZWZmZWN0cy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 34 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/reflection-effect.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib__ = __webpack_require__(/*! ../../lib */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_viewports__ = __webpack_require__(/*! ../../../lib/viewports */ 13);\n/* global window */\n\n\n\n\n\n// import {WebMercatorViewport} from 'viewport-mercator-project';\n\n\nvar ReflectionEffect = (function (Effect) {\n  function ReflectionEffect(reflectivity, blur) {\n    if ( reflectivity === void 0 ) reflectivity = 0.5;\n    if ( blur === void 0 ) blur = 0.5;\n\n    Effect.call(this);\n    this.reflectivity = reflectivity;\n    this.blur = blur;\n    this.framebuffer = null;\n    this.setNeedsRedraw();\n  }\n\n  if ( Effect ) ReflectionEffect.__proto__ = Effect;\n  ReflectionEffect.prototype = Object.create( Effect && Effect.prototype );\n  ReflectionEffect.prototype.constructor = ReflectionEffect;\n\n  ReflectionEffect.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME reflection-effect-vs\\n\\nattribute vec3 vertices;\\n\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n  uv = vertices.xy;\\n  gl_Position = vec4(2. * vertices.xy - vec2(1., 1.), 1., 1.);\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME reflection-effect-fs\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform sampler2D reflectionTexture;\\nuniform int reflectionTextureWidth;\\nuniform int reflectionTextureHeight;\\n\\nuniform float reflectivity;\\nuniform float blur;\\n\\n\\nvarying vec2 uv;\\n\\n#define KERNEL_SIZE 7\\n\\n/*\\n * Samples from tex with a gaussian-shaped patch, centered at uv and\\n * with standard deviation sigma.  The size of the texture in\\n * pixels must be specified by dim\\n */\\nvec4 sample_gaussian(sampler2D tex, vec2 dim, vec2 uv, float sigma) {\\n  if (sigma == 0.0) {\\n    return texture2D(tex, uv);\\n  }\\n  \\n  vec2 delta = 1.0 / dim;\\n  vec2 top_left = uv - delta * float(KERNEL_SIZE+1) / 2.0;\\n  \\n  vec4 color = vec4(0);\\n  float sum = 0.0;\\n  for (int i = 0; i <  KERNEL_SIZE; ++i) {\\n    for (int j = 0; j < KERNEL_SIZE; ++j) {\\n      vec2 uv2 = top_left + vec2(i, j) * delta;\\n      float d = length((uv2 - uv) * dim);\\n      float f = exp(-(d*d) / (2.0*sigma * sigma));\\n      color += f * texture2D(tex, uv2);\\n      sum += f;\\n    }\\n  }\\n  return color / sum;\\n}\\n\\nvoid main(void) {\\n  //map blur in [0, 1] to sigma in [0, inf]\\n  //alpha will determine the \"steepness\" of our curve.\\n  //this was picked just to make the scale feel \"natural\"\\n  //if our image is 1000 pixels wide, a blur of 0.5 should correspond\\n  //to a sigma of 1 pixels\\n  float alpha = 1000.0;\\n  float sigma = blur / (alpha * (1.0 - blur));\\n  //let this be our standard deviation in terms of screen-widths.\\n  //rewrite this in terms of pixels.\\n  sigma *= float(reflectionTextureWidth);\\n  \\n  \\n  gl_FragColor = sample_gaussian(reflectionTexture, vec2(reflectionTextureWidth, reflectionTextureHeight), vec2(uv.x, 1. - uv.y), sigma);\\n  //because our canvas expects alphas to be pre-multiplied, we multiply by whole\\n  //color vector by reflectivity, not just the alpha channel\\n  gl_FragColor *= reflectivity;\\n}\\n'\n    };\n  };\n\n  ReflectionEffect.prototype.initialize = function initialize (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    this.unitQuad = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: 'reflection-effect',\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n      })\n    });\n    this.framebuffer = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Framebuffer\"](gl, { depth: true });\n  };\n\n  ReflectionEffect.prototype.preDraw = function preDraw (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n\n    var ref$1 = layerManager.context;\n    var viewport = ref$1.viewport;\n    /*\n     * the renderer already has a reference to this, but we don't have a reference to the renderer.\n     * when we refactor the camera code, we should make sure we get a reference to the renderer so\n     * that we can keep this in one place.\n     */\n    var dpi = typeof window !== 'undefined' && window.devicePixelRatio || 1;\n    this.framebuffer.resize({ width: dpi * viewport.width, height: dpi * viewport.height });\n    var pitch = viewport.pitch;\n    this.framebuffer.bind();\n    /* this is a huge hack around the existing viewport class.\n     * TODO in the future, once we implement bona-fide cameras, we really need to fix this.\n     */\n    layerManager.setViewport(new __WEBPACK_IMPORTED_MODULE_4__lib_viewports__[\"a\" /* WebMercatorViewport */](Object.assign({}, viewport, { pitch: -180 - pitch })));\n    gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n\n    layerManager.drawLayers();\n    layerManager.setViewport(viewport);\n    this.framebuffer.unbind();\n  };\n\n  ReflectionEffect.prototype.draw = function draw (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n\n    /*\n     * Render our unit quad.\n     * This will cover the entire screen, but will lie behind all other geometry.\n     * This quad will sample the previously generated reflection texture\n     * in order to create the reflection effect\n     */\n    this.unitQuad.render({\n      reflectionTexture: this.framebuffer.texture,\n      reflectionTextureWidth: this.framebuffer.width,\n      reflectionTextureHeight: this.framebuffer.height,\n      reflectivity: this.reflectivity,\n      blur: this.blur\n    });\n  };\n\n  ReflectionEffect.prototype.finalize = function finalize (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n\n    /* TODO: Free resources? */\n  };\n\n  return ReflectionEffect;\n}(__WEBPACK_IMPORTED_MODULE_2__lib__[\"b\" /* Effect */]));\n\n/* harmony default export */ exports[\"a\"] = ReflectionEffect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2V4cGVyaW1lbnRhbC9lZmZlY3RzL3JlZmxlY3Rpb24tZWZmZWN0L3JlZmxlY3Rpb24tZWZmZWN0LmpzP2YzODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHsgR0wsIEZyYW1lYnVmZmVyLCBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBFZmZlY3QgfSBmcm9tICcuLi8uLi9saWInO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG4vLyBpbXBvcnQge1dlYk1lcmNhdG9yVmlld3BvcnR9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IHsgV2ViTWVyY2F0b3JWaWV3cG9ydCB9IGZyb20gJy4uLy4uLy4uL2xpYi92aWV3cG9ydHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZsZWN0aW9uRWZmZWN0IGV4dGVuZHMgRWZmZWN0IHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBSZWZsZWN0aW9uRWZmZWN0XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gcmVmbGVjdGl2aXR5IEhvdyB2aXNpYmxlIHJlZmxlY3Rpb25zIHNob3VsZCBiZSBvdmVyIHRoZSBtYXAsIGJldHdlZW4gMCBhbmQgMVxuICAgKiBAcGFyYW0gYmx1ciBob3cgYmx1cnJ5IHRoZSByZWZsZWN0aW9uIHNob3VsZCBiZSwgYmV0d2VlbiAwIGFuZCAxXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKHJlZmxlY3Rpdml0eSA9IDAuNSwgYmx1ciA9IDAuNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZWZsZWN0aXZpdHkgPSByZWZsZWN0aXZpdHk7XG4gICAgdGhpcy5ibHVyID0gYmx1cjtcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnNldE5lZWRzUmVkcmF3KCk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSByZWZsZWN0aW9uLWVmZmVjdC12c1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRpY2VzO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdXYgPSB2ZXJ0aWNlcy54eTtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgyLiAqIHZlcnRpY2VzLnh5IC0gdmVjMigxLiwgMS4pLCAxLiwgMS4pO1xcbn1cXG4nLFxuICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgcmVmbGVjdGlvbi1lZmZlY3QtZnNcXG5cXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgcmVmbGVjdGlvblRleHR1cmU7XFxudW5pZm9ybSBpbnQgcmVmbGVjdGlvblRleHR1cmVXaWR0aDtcXG51bmlmb3JtIGludCByZWZsZWN0aW9uVGV4dHVyZUhlaWdodDtcXG5cXG51bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG51bmlmb3JtIGZsb2F0IGJsdXI7XFxuXFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbiNkZWZpbmUgS0VSTkVMX1NJWkUgN1xcblxcbi8qXFxuICogU2FtcGxlcyBmcm9tIHRleCB3aXRoIGEgZ2F1c3NpYW4tc2hhcGVkIHBhdGNoLCBjZW50ZXJlZCBhdCB1diBhbmRcXG4gKiB3aXRoIHN0YW5kYXJkIGRldmlhdGlvbiBzaWdtYS4gIFRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGluXFxuICogcGl4ZWxzIG11c3QgYmUgc3BlY2lmaWVkIGJ5IGRpbVxcbiAqL1xcbnZlYzQgc2FtcGxlX2dhdXNzaWFuKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZGltLCB2ZWMyIHV2LCBmbG9hdCBzaWdtYSkge1xcbiAgaWYgKHNpZ21hID09IDAuMCkge1xcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgdXYpO1xcbiAgfVxcbiAgXFxuICB2ZWMyIGRlbHRhID0gMS4wIC8gZGltO1xcbiAgdmVjMiB0b3BfbGVmdCA9IHV2IC0gZGVsdGEgKiBmbG9hdChLRVJORUxfU0laRSsxKSAvIDIuMDtcXG4gIFxcbiAgdmVjNCBjb2xvciA9IHZlYzQoMCk7XFxuICBmbG9hdCBzdW0gPSAwLjA7XFxuICBmb3IgKGludCBpID0gMDsgaSA8ICBLRVJORUxfU0laRTsgKytpKSB7XFxuICAgIGZvciAoaW50IGogPSAwOyBqIDwgS0VSTkVMX1NJWkU7ICsraikge1xcbiAgICAgIHZlYzIgdXYyID0gdG9wX2xlZnQgKyB2ZWMyKGksIGopICogZGVsdGE7XFxuICAgICAgZmxvYXQgZCA9IGxlbmd0aCgodXYyIC0gdXYpICogZGltKTtcXG4gICAgICBmbG9hdCBmID0gZXhwKC0oZCpkKSAvICgyLjAqc2lnbWEgKiBzaWdtYSkpO1xcbiAgICAgIGNvbG9yICs9IGYgKiB0ZXh0dXJlMkQodGV4LCB1djIpO1xcbiAgICAgIHN1bSArPSBmO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gY29sb3IgLyBzdW07XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvL21hcCBibHVyIGluIFswLCAxXSB0byBzaWdtYSBpbiBbMCwgaW5mXVxcbiAgLy9hbHBoYSB3aWxsIGRldGVybWluZSB0aGUgXCJzdGVlcG5lc3NcIiBvZiBvdXIgY3VydmUuXFxuICAvL3RoaXMgd2FzIHBpY2tlZCBqdXN0IHRvIG1ha2UgdGhlIHNjYWxlIGZlZWwgXCJuYXR1cmFsXCJcXG4gIC8vaWYgb3VyIGltYWdlIGlzIDEwMDAgcGl4ZWxzIHdpZGUsIGEgYmx1ciBvZiAwLjUgc2hvdWxkIGNvcnJlc3BvbmRcXG4gIC8vdG8gYSBzaWdtYSBvZiAxIHBpeGVsc1xcbiAgZmxvYXQgYWxwaGEgPSAxMDAwLjA7XFxuICBmbG9hdCBzaWdtYSA9IGJsdXIgLyAoYWxwaGEgKiAoMS4wIC0gYmx1cikpO1xcbiAgLy9sZXQgdGhpcyBiZSBvdXIgc3RhbmRhcmQgZGV2aWF0aW9uIGluIHRlcm1zIG9mIHNjcmVlbi13aWR0aHMuXFxuICAvL3Jld3JpdGUgdGhpcyBpbiB0ZXJtcyBvZiBwaXhlbHMuXFxuICBzaWdtYSAqPSBmbG9hdChyZWZsZWN0aW9uVGV4dHVyZVdpZHRoKTtcXG4gIFxcbiAgXFxuICBnbF9GcmFnQ29sb3IgPSBzYW1wbGVfZ2F1c3NpYW4ocmVmbGVjdGlvblRleHR1cmUsIHZlYzIocmVmbGVjdGlvblRleHR1cmVXaWR0aCwgcmVmbGVjdGlvblRleHR1cmVIZWlnaHQpLCB2ZWMyKHV2LngsIDEuIC0gdXYueSksIHNpZ21hKTtcXG4gIC8vYmVjYXVzZSBvdXIgY2FudmFzIGV4cGVjdHMgYWxwaGFzIHRvIGJlIHByZS1tdWx0aXBsaWVkLCB3ZSBtdWx0aXBseSBieSB3aG9sZVxcbiAgLy9jb2xvciB2ZWN0b3IgYnkgcmVmbGVjdGl2aXR5LCBub3QganVzdCB0aGUgYWxwaGEgY2hhbm5lbFxcbiAgZ2xfRnJhZ0NvbG9yICo9IHJlZmxlY3Rpdml0eTtcXG59XFxuJ1xuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplKHsgZ2wsIGxheWVyTWFuYWdlciB9KSB7XG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgdGhpcy51bml0UXVhZCA9IG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiAncmVmbGVjdGlvbi1lZmZlY3QnLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfRkFOLFxuICAgICAgICB2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMF0pXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIoZ2wsIHsgZGVwdGg6IHRydWUgfSk7XG4gIH1cblxuICBwcmVEcmF3KHsgZ2wsIGxheWVyTWFuYWdlciB9KSB7XG4gICAgY29uc3QgeyB2aWV3cG9ydCB9ID0gbGF5ZXJNYW5hZ2VyLmNvbnRleHQ7XG4gICAgLypcbiAgICAgKiB0aGUgcmVuZGVyZXIgYWxyZWFkeSBoYXMgYSByZWZlcmVuY2UgdG8gdGhpcywgYnV0IHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqIHdoZW4gd2UgcmVmYWN0b3IgdGhlIGNhbWVyYSBjb2RlLCB3ZSBzaG91bGQgbWFrZSBzdXJlIHdlIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIgc29cbiAgICAgKiB0aGF0IHdlIGNhbiBrZWVwIHRoaXMgaW4gb25lIHBsYWNlLlxuICAgICAqL1xuICAgIGNvbnN0IGRwaSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5yZXNpemUoeyB3aWR0aDogZHBpICogdmlld3BvcnQud2lkdGgsIGhlaWdodDogZHBpICogdmlld3BvcnQuaGVpZ2h0IH0pO1xuICAgIGNvbnN0IHBpdGNoID0gdmlld3BvcnQucGl0Y2g7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5iaW5kKCk7XG4gICAgLyogdGhpcyBpcyBhIGh1Z2UgaGFjayBhcm91bmQgdGhlIGV4aXN0aW5nIHZpZXdwb3J0IGNsYXNzLlxuICAgICAqIFRPRE8gaW4gdGhlIGZ1dHVyZSwgb25jZSB3ZSBpbXBsZW1lbnQgYm9uYS1maWRlIGNhbWVyYXMsIHdlIHJlYWxseSBuZWVkIHRvIGZpeCB0aGlzLlxuICAgICAqL1xuICAgIGxheWVyTWFuYWdlci5zZXRWaWV3cG9ydChuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydChPYmplY3QuYXNzaWduKHt9LCB2aWV3cG9ydCwgeyBwaXRjaDogLTE4MCAtIHBpdGNoIH0pKSk7XG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG4gICAgbGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnMoKTtcbiAgICBsYXllck1hbmFnZXIuc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIudW5iaW5kKCk7XG4gIH1cblxuICBkcmF3KHsgZ2wsIGxheWVyTWFuYWdlciB9KSB7XG4gICAgLypcbiAgICAgKiBSZW5kZXIgb3VyIHVuaXQgcXVhZC5cbiAgICAgKiBUaGlzIHdpbGwgY292ZXIgdGhlIGVudGlyZSBzY3JlZW4sIGJ1dCB3aWxsIGxpZSBiZWhpbmQgYWxsIG90aGVyIGdlb21ldHJ5LlxuICAgICAqIFRoaXMgcXVhZCB3aWxsIHNhbXBsZSB0aGUgcHJldmlvdXNseSBnZW5lcmF0ZWQgcmVmbGVjdGlvbiB0ZXh0dXJlXG4gICAgICogaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSByZWZsZWN0aW9uIGVmZmVjdFxuICAgICAqL1xuICAgIHRoaXMudW5pdFF1YWQucmVuZGVyKHtcbiAgICAgIHJlZmxlY3Rpb25UZXh0dXJlOiB0aGlzLmZyYW1lYnVmZmVyLnRleHR1cmUsXG4gICAgICByZWZsZWN0aW9uVGV4dHVyZVdpZHRoOiB0aGlzLmZyYW1lYnVmZmVyLndpZHRoLFxuICAgICAgcmVmbGVjdGlvblRleHR1cmVIZWlnaHQ6IHRoaXMuZnJhbWVidWZmZXIuaGVpZ2h0LFxuICAgICAgcmVmbGVjdGl2aXR5OiB0aGlzLnJlZmxlY3Rpdml0eSxcbiAgICAgIGJsdXI6IHRoaXMuYmx1clxuICAgIH0pO1xuICB9XG5cbiAgZmluYWxpemUoeyBnbCwgbGF5ZXJNYW5hZ2VyIH0pIHtcbiAgICAvKiBUT0RPOiBGcmVlIHJlc291cmNlcz8gKi9cbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQVdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQW5GQTtBQUNBOzs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 35 */
/* exports provided: Effect, EffectManager, ReflectionEffect */
/* exports used: Effect, EffectManager */
/*!***********************************!*\
  !*** ./src/experimental/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__effects__ = __webpack_require__(/*! ./effects */ 33);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib__ = __webpack_require__(/*! ./lib */ 9);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"b\"]; });\n/* harmony namespace reexport (by used) */ __webpack_require__.d(exports, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"a\"]; });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2V4cGVyaW1lbnRhbC9pbmRleC5qcz85OGU3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZWZmZWN0cyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYic7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9leHBlcmltZW50YWwvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 36 */
/* exports provided: default */
/* exports used: default */
/*!************************************************!*\
  !*** ./src/experimental/lib/effect-manager.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* eslint-disable no-try-catch */\n\nvar EffectManager = function EffectManager(ref) {\n  var gl = ref.gl;\n  var layerManager = ref.layerManager;\n\n  this.gl = gl;\n  this.layerManager = layerManager;\n  this._effects = [];\n};\n\n/**\n * Adds an effect to be managed.That effect's initialize function will\n * be called, and the effect's preDraw and draw callbacks will be\n * called at the appropriate times in the render loop\n * @param {Effect} effect - the effect to be added\n */\nEffectManager.prototype.addEffect = function addEffect (effect) {\n  this._effects.push(effect);\n  this._sortEffects();\n  effect.initialize({ gl: this.gl, layerManager: this.layerManager });\n};\n\n/**\n * Removes an effect that is already being managed.That effect's\n * finalize function will be called, and its callbacks will no longer\n * be envoked in the render loop\n * @param {Effect} effect - the effect to be removed\n * @return {bool} - True if the effect was already being managed, and\n * thus successfully removed; false otherwise\n */\nEffectManager.prototype.removeEffect = function removeEffect (effect) {\n  var i = this._effects.indexOf(effect);\n  if (i >= 0) {\n    effect.finalize({ gl: this.gl, layerManager: this.layerManager });\n    this._effects.splice(i, 1);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Envoke the preDraw callback of all managed events, in order of\n * decreasing priority\n */\nEffectManager.prototype.preDraw = function preDraw () {\n    var this$1 = this;\n\n  for (var i = 0, list = this$1._effects; i < list.length; i += 1) {\n    var effect = list[i];\n\n      if (effect.needsRedraw) {\n      effect.preDraw({ gl: this$1.gl, layerManager: this$1.layerManager });\n    }\n  }\n};\n\n/**\n * Envoke the draw callback of all managed events, in order of\n * decreasing priority\n */\nEffectManager.prototype.draw = function draw () {\n    var this$1 = this;\n\n  for (var i = 0, list = this$1._effects; i < list.length; i += 1) {\n    var effect = list[i];\n\n      if (effect.needsRedraw) {\n      effect.draw({ gl: this$1.gl, layerManager: this$1.layerManager });\n    }\n  }\n};\n\nEffectManager.prototype._sortEffects = function _sortEffects () {\n  this._effects.sort(function (a, b) {\n    if (a.priority > b.priority) {\n      return -1;\n    } else if (a.priority < b.priority) {\n      return 1;\n    }\n    return a.count - b.count;\n  });\n};\n\n/* harmony default export */ exports[\"a\"] = EffectManager;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2V4cGVyaW1lbnRhbC9saWIvZWZmZWN0LW1hbmFnZXIuanM/OGJlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby10cnktY2F0Y2ggKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWZmZWN0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHsgZ2wsIGxheWVyTWFuYWdlciB9KSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyID0gbGF5ZXJNYW5hZ2VyO1xuICAgIHRoaXMuX2VmZmVjdHMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVmZmVjdCB0byBiZSBtYW5hZ2VkLiAgVGhhdCBlZmZlY3QncyBpbml0aWFsaXplIGZ1bmN0aW9uIHdpbGxcbiAgICogYmUgY2FsbGVkLCBhbmQgdGhlIGVmZmVjdCdzIHByZURyYXcgYW5kIGRyYXcgY2FsbGJhY2tzIHdpbGwgYmVcbiAgICogY2FsbGVkIGF0IHRoZSBhcHByb3ByaWF0ZSB0aW1lcyBpbiB0aGUgcmVuZGVyIGxvb3BcbiAgICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdCAtIHRoZSBlZmZlY3QgdG8gYmUgYWRkZWRcbiAgICovXG4gIGFkZEVmZmVjdChlZmZlY3QpIHtcbiAgICB0aGlzLl9lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB0aGlzLl9zb3J0RWZmZWN0cygpO1xuICAgIGVmZmVjdC5pbml0aWFsaXplKHsgZ2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXIgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGJlaW5nIG1hbmFnZWQuICBUaGF0IGVmZmVjdCdzXG4gICAqIGZpbmFsaXplIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLCBhbmQgaXRzIGNhbGxiYWNrcyB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBlbnZva2VkIGluIHRoZSByZW5kZXIgbG9vcFxuICAgKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0IC0gdGhlIGVmZmVjdCB0byBiZSByZW1vdmVkXG4gICAqIEByZXR1cm4ge2Jvb2x9IC0gVHJ1ZSBpZiB0aGUgZWZmZWN0IHdhcyBhbHJlYWR5IGJlaW5nIG1hbmFnZWQsIGFuZFxuICAgKiB0aHVzIHN1Y2Nlc3NmdWxseSByZW1vdmVkOyBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHJlbW92ZUVmZmVjdChlZmZlY3QpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgZWZmZWN0LmZpbmFsaXplKHsgZ2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXIgfSk7XG4gICAgICB0aGlzLl9lZmZlY3RzLnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRW52b2tlIHRoZSBwcmVEcmF3IGNhbGxiYWNrIG9mIGFsbCBtYW5hZ2VkIGV2ZW50cywgaW4gb3JkZXIgb2ZcbiAgICogZGVjcmVhc2luZyBwcmlvcml0eVxuICAgKi9cbiAgcHJlRHJhdygpIHtcbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLl9lZmZlY3RzKSB7XG4gICAgICBpZiAoZWZmZWN0Lm5lZWRzUmVkcmF3KSB7XG4gICAgICAgIGVmZmVjdC5wcmVEcmF3KHsgZ2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXIgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVudm9rZSB0aGUgZHJhdyBjYWxsYmFjayBvZiBhbGwgbWFuYWdlZCBldmVudHMsIGluIG9yZGVyIG9mXG4gICAqIGRlY3JlYXNpbmcgcHJpb3JpdHlcbiAgICovXG4gIGRyYXcoKSB7XG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5fZWZmZWN0cykge1xuICAgICAgaWYgKGVmZmVjdC5uZWVkc1JlZHJhdykge1xuICAgICAgICBlZmZlY3QuZHJhdyh7IGdsOiB0aGlzLmdsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zb3J0RWZmZWN0cygpIHtcbiAgICB0aGlzLl9lZmZlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhLnByaW9yaXR5ID4gYi5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEucHJpb3JpdHkgPCBiLnByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEuY291bnQgLSBiLmNvdW50O1xuICAgIH0pO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9leHBlcmltZW50YWwvbGliL2VmZmVjdC1tYW5hZ2VyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 37 */
/* exports provided: default */
/* exports used: default */
/*!****************************************!*\
  !*** ./src/experimental/lib/effect.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var counter = 0;\n\nvar Effect = function Effect() {\n  this.count = counter++;\n  this.visible = true;\n  this.priority = 0;\n  this.needsRedraw = false;\n};\n\n/**\n * subclasses should override to set up any resources needed\n */\nEffect.prototype.initialize = function initialize (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n};\n/**\n * and subclasses should free those resources here\n */\nEffect.prototype.finalize = function finalize (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n};\n/**\n * override for a callback immediately before drawing each frame\n */\nEffect.prototype.preDraw = function preDraw (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n};\n/**\n * override for a callback immediately after drawing a frame's layers\n */\nEffect.prototype.draw = function draw (ref) {\n    var gl = ref.gl;\n    var layerManager = ref.layerManager;\n};\n\nEffect.prototype.setNeedsRedraw = function setNeedsRedraw (redraw) {\n    if ( redraw === void 0 ) redraw = true;\n\n  this.needsRedraw = redraw;\n};\n\n/* harmony default export */ exports[\"a\"] = Effect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2V4cGVyaW1lbnRhbC9saWIvZWZmZWN0LmpzPzE2ODgiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGNvdW50ZXIgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZmZlY3Qge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY291bnQgPSBjb3VudGVyKys7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMDtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHVwIGFueSByZXNvdXJjZXMgbmVlZGVkXG4gICAqL1xuICBpbml0aWFsaXplKHsgZ2wsIGxheWVyTWFuYWdlciB9KSB7fVxuICAvKipcbiAgICogYW5kIHN1YmNsYXNzZXMgc2hvdWxkIGZyZWUgdGhvc2UgcmVzb3VyY2VzIGhlcmVcbiAgICovXG4gIGZpbmFsaXplKHsgZ2wsIGxheWVyTWFuYWdlciB9KSB7fVxuICAvKipcbiAgICogb3ZlcnJpZGUgZm9yIGEgY2FsbGJhY2sgaW1tZWRpYXRlbHkgYmVmb3JlIGRyYXdpbmcgZWFjaCBmcmFtZVxuICAgKi9cbiAgcHJlRHJhdyh7IGdsLCBsYXllck1hbmFnZXIgfSkge31cbiAgLyoqXG4gICAqIG92ZXJyaWRlIGZvciBhIGNhbGxiYWNrIGltbWVkaWF0ZWx5IGFmdGVyIGRyYXdpbmcgYSBmcmFtZSdzIGxheWVyc1xuICAgKi9cbiAgZHJhdyh7IGdsLCBsYXllck1hbmFnZXIgfSkge31cblxuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHJlZHJhdztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 38 */
/* exports provided: default */
/* exports used: default */
/*!************************************************!*\
  !*** ./src/layers/core/arc-layer/arc-layer.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 255, 255];\n\nvar defaultProps = {\n  strokeWidth: 1,\n  getSourcePosition: function (x) { return x.sourcePosition; },\n  getTargetPosition: function (x) { return x.targetPosition; },\n  getSourceColor: function (x) { return x.color; },\n  getTargetColor: function (x) { return x.color; }\n};\n\nvar ArcLayer = (function (Layer) {\n  function ArcLayer(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ArcLayer.__proto__ = Layer;\n  ArcLayer.prototype = Object.create( Layer && Layer.prototype );\n  ArcLayer.prototype.constructor = ArcLayer;\n\n  ArcLayer.prototype.initializeState = function initializeState () {\n    var ref = this.context;\n    var gl = ref.gl;\n    this.setState({ model: this._createModel(gl) });\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    attributeManager.addInstanced({\n      instancePositions: { size: 4, update: this.calculateInstancePositions },\n      instanceSourceColors: {\n        type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        size: 4,\n        update: this.calculateInstanceSourceColors\n      },\n      instanceTargetColors: {\n        type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        size: 4,\n        update: this.calculateInstanceTargetColors\n      }\n    });\n  };\n\n  ArcLayer.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  ArcLayer.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-vertex-shader\\n\\nconst float N = 49.0;\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourceColors;\\nattribute vec4 instanceTargetColors;\\nattribute vec4 instancePositions;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\\n\\n  vec2 x = mix(source, target, ratio);\\n  vec2 center = mix(source, target, 0.5);\\n\\n  float dSourceCenter = distance(source, center);\\n  float dXCenter = distance(x, center);\\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\\n}\\n\\nvoid main(void) {\\n  vec2 source = preproject(instancePositions.xy);\\n  vec2 target = preproject(instancePositions.zw);\\n\\n  float segmentRatio = smoothstep(0.0, 1.0, positions.x / N);\\n\\n  float vertex_height = paraboloid(source, target, segmentRatio);\\n  if (vertex_height < 0.0) vertex_height = 0.0;\\n  vec3 p = vec3(\\n    // xy: linear interpolation of source & target\\n    mix(source, target, segmentRatio),\\n    // z: paraboloid interpolate of source & target\\n    sqrt(vertex_height)\\n  );\\n\\n  gl_Position = project(vec4(p, 1.0));\\n\\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\\n\\n  vColor = mix(\\n    vec4(color.rgb, color.a * opacity),\\n    vec4(instancePickingColors / 255., 1.),\\n    renderPickingBuffer\\n  );\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n    };\n  };\n\n  ArcLayer.prototype._createModel = function _createModel (gl) {\n    var positions = [];\n    var NUM_SEGMENTS = 50;\n    for (var i = 0; i < NUM_SEGMENTS; i++) {\n      positions = positions.concat( [i], [i], [i]);\n    }\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl: gl,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].LINE_STRIP,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  };\n\n  ArcLayer.prototype.calculateInstancePositions = function calculateInstancePositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourcePosition = ref.getSourcePosition;\n    var getTargetPosition = ref.getTargetPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var sourcePosition = getSourcePosition(object);\n      var targetPosition = getTargetPosition(object);\n      value[i + 0] = sourcePosition[0];\n      value[i + 1] = sourcePosition[1];\n      value[i + 2] = targetPosition[0];\n      value[i + 3] = targetPosition[1];\n      i += size;\n    }\n  };\n\n  ArcLayer.prototype.calculateInstanceSourceColors = function calculateInstanceSourceColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourceColor = ref.getSourceColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var color = getSourceColor(object) || DEFAULT_COLOR;\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  ArcLayer.prototype.calculateInstanceTargetColors = function calculateInstanceTargetColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getTargetColor = ref.getTargetColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var color = getTargetColor(object) || DEFAULT_COLOR;\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  return ArcLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ArcLayer;\n\nArcLayer.layerName = 'ArcLayer';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL2FyYy1sYXllci9hcmMtbGF5ZXIuanM/NTdjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMjU1LCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIHN0cm9rZVdpZHRoOiAxLFxuICBnZXRTb3VyY2VQb3NpdGlvbjogeCA9PiB4LnNvdXJjZVBvc2l0aW9uLFxuICBnZXRUYXJnZXRQb3NpdGlvbjogeCA9PiB4LnRhcmdldFBvc2l0aW9uLFxuICBnZXRTb3VyY2VDb2xvcjogeCA9PiB4LmNvbG9yLFxuICBnZXRUYXJnZXRDb2xvcjogeCA9PiB4LmNvbG9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5fY3JlYXRlTW9kZWwoZ2wpIH0pO1xuXG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7IHNpemU6IDQsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyB9LFxuICAgICAgaW5zdGFuY2VTb3VyY2VDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlU291cmNlQ29sb3JzXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VUYXJnZXRDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkcmF3KHsgdW5pZm9ybXMgfSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLnNjcmVlblRvRGV2aWNlUGl4ZWxzKHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgpO1xuICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICAvLyBTZXR0aW5nIGxpbmUgd2lkdGggYmFjayB0byAxIGlzIGhlcmUgdG8gd29ya2Fyb3VuZCBhIEdvb2dsZSBDaHJvbWUgYnVnXG4gICAgLy8gZ2wuY2xlYXIoKSBhbmQgZ2wuaXNFbmFibGVkKCkgd2lsbCByZXR1cm4gR0xfSU5WQUxJRF9WQUxVRSBldmVuIHdpdGhcbiAgICAvLyBjb3JyZWN0IHBhcmFtZXRlclxuICAgIC8vIFRoaXMgaXMgbm90IGhhcHBlbmluZyBvbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICBnbC5saW5lV2lkdGgoMS4wKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGFyYy1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuY29uc3QgZmxvYXQgTiA9IDQ5LjA7XFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU291cmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlVGFyZ2V0Q29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxuZmxvYXQgcGFyYWJvbG9pZCh2ZWMyIHNvdXJjZSwgdmVjMiB0YXJnZXQsIGZsb2F0IHJhdGlvKSB7XFxuXFxuICB2ZWMyIHggPSBtaXgoc291cmNlLCB0YXJnZXQsIHJhdGlvKTtcXG4gIHZlYzIgY2VudGVyID0gbWl4KHNvdXJjZSwgdGFyZ2V0LCAwLjUpO1xcblxcbiAgZmxvYXQgZFNvdXJjZUNlbnRlciA9IGRpc3RhbmNlKHNvdXJjZSwgY2VudGVyKTtcXG4gIGZsb2F0IGRYQ2VudGVyID0gZGlzdGFuY2UoeCwgY2VudGVyKTtcXG4gIHJldHVybiAoZFNvdXJjZUNlbnRlciArIGRYQ2VudGVyKSAqIChkU291cmNlQ2VudGVyIC0gZFhDZW50ZXIpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdmVjMiBzb3VyY2UgPSBwcmVwcm9qZWN0KGluc3RhbmNlUG9zaXRpb25zLnh5KTtcXG4gIHZlYzIgdGFyZ2V0ID0gcHJlcHJvamVjdChpbnN0YW5jZVBvc2l0aW9ucy56dyk7XFxuXFxuICBmbG9hdCBzZWdtZW50UmF0aW8gPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBwb3NpdGlvbnMueCAvIE4pO1xcblxcbiAgZmxvYXQgdmVydGV4X2hlaWdodCA9IHBhcmFib2xvaWQoc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbyk7XFxuICBpZiAodmVydGV4X2hlaWdodCA8IDAuMCkgdmVydGV4X2hlaWdodCA9IDAuMDtcXG4gIHZlYzMgcCA9IHZlYzMoXFxuICAgIC8vIHh5OiBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvZiBzb3VyY2UgJiB0YXJnZXRcXG4gICAgbWl4KHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pLFxcbiAgICAvLyB6OiBwYXJhYm9sb2lkIGludGVycG9sYXRlIG9mIHNvdXJjZSAmIHRhcmdldFxcbiAgICBzcXJ0KHZlcnRleF9oZWlnaHQpXFxuICApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0KHZlYzQocCwgMS4wKSk7XFxuXFxuICB2ZWM0IGNvbG9yID0gbWl4KGluc3RhbmNlU291cmNlQ29sb3JzLCBpbnN0YW5jZVRhcmdldENvbG9ycywgc2VnbWVudFJhdGlvKSAvIDI1NS47XFxuXFxuICB2Q29sb3IgPSBtaXgoXFxuICAgIHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogb3BhY2l0eSksXFxuICAgIHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pLFxcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXFxuICApO1xcbn1cXG4nLFxuICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbidcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZU1vZGVsKGdsKSB7XG4gICAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IE5VTV9TRUdNRU5UUyA9IDUwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlVNX1NFR01FTlRTOyBpKyspIHtcbiAgICAgIHBvc2l0aW9ucyA9IFsuLi5wb3NpdGlvbnMsIGksIGksIGldO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiBHTC5MSU5FX1NUUklQLFxuICAgICAgICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKVxuICAgICAgfSksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRTb3VyY2VQb3NpdGlvbiwgZ2V0VGFyZ2V0UG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBzb3VyY2VQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHNvdXJjZVBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gdGFyZ2V0UG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgM10gPSB0YXJnZXRQb3NpdGlvblsxXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldFNvdXJjZUNvbG9yIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdmFsdWUsIHNpemUgfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRTb3VyY2VDb2xvcihvYmplY3QpIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBjb2xvclswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gY29sb3JbMl07XG4gICAgICB2YWx1ZVtpICsgM10gPSBpc05hTihjb2xvclszXSkgPyBERUZBVUxUX0NPTE9SWzNdIDogY29sb3JbM107XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRUYXJnZXRDb2xvciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0VGFyZ2V0Q29sb3Iob2JqZWN0KSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gREVGQVVMVF9DT0xPUlszXSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5BcmNMYXllci5sYXllck5hbWUgPSAnQXJjTGF5ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0dBO0FBQ0E7QUEwR0E7QUFDQTs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 39 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************!*\
  !*** ./src/layers/core/choropleth-layer/choropleth-layer.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_geojson_normalize__ = __webpack_require__(/*! geojson-normalize */ 22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_geojson_normalize___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_geojson_normalize__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(/*! earcut */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 255, 255];\n\nvar defaultProps = {\n  getColor: function (feature) { return feature.properties.color; },\n  drawCountour: false,\n  strokeWidth: 1\n};\n\nvar ChoroplethLayer = (function (Layer) {\n  function ChoroplethLayer(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ChoroplethLayer.__proto__ = Layer;\n  ChoroplethLayer.prototype = Object.create( Layer && Layer.prototype );\n  ChoroplethLayer.prototype.constructor = ChoroplethLayer;\n\n  ChoroplethLayer.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 colors;\\nattribute vec3 pickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\n// PICKING\\nuniform float pickingEnabled;\\nvarying vec4 vPickingColor;\\nvoid picking_setPickColor(vec3 pickingColor) {\\n  vPickingColor = vec4(pickingColor,  1.);\\n}\\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\\n  return vPickingColor;\\n}\\n\\n// PICKING\\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\\n//   return mix(color4, pickingColor4, renderPickingBuffer);\\n// }\\n\\nvoid main(void) {\\n\\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\\n\\n  picking_setNormalAndPickColors(\\n    color,\\n    pickingColors / 255.\\n  );\\n\\n  vec3 p = project_position(positions);\\n  gl_Position = project_to_clipspace(vec4(p, 1.));\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n// PICKING\\n// uniform bool pickingEnabled;\\nvarying vec4 vPickingColor;\\nvec4 picking_getColor() {\\n  return vPickingColor;\\n}\\n// PICKING\\n\\nvoid main(void) {\\n  gl_FragColor = picking_getColor();\\n}\\n'\n    };\n  };\n\n  ChoroplethLayer.prototype.initializeState = function initializeState () {\n    var ref = this.context;\n    var gl = ref.gl;\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    attributeManager.addDynamic({\n      // Primtive attributes\n      indices: { size: 1, update: this.calculateIndices, isIndexed: true },\n      positions: { size: 3, update: this.calculatePositions },\n      colors: {\n        type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        size: 4,\n        update: this.calculateColors\n      },\n      // Instanced attributes\n      pickingColors: {\n        type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        size: 3,\n        update: this.calculatePickingColors,\n        noAlloc: true\n      }\n    });\n\n    var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;\n\n    this.setState({\n      model: this.getModel(gl),\n      numInstances: 0,\n      IndexType: IndexType\n    });\n  };\n\n  ChoroplethLayer.prototype.updateState = function updateState (ref) {\n    var oldProps = ref.oldProps;\n    var props = ref.props;\n    var changeFlags = ref.changeFlags;\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    if (changeFlags.dataChanged) {\n      this.state.choropleths = extractChoropleths(props.data);\n      attributeManager.invalidateAll();\n    }\n\n    if (oldProps.opacity !== props.opacity) {\n      this.setUniforms({ opacity: props.opacity });\n    }\n  };\n\n  ChoroplethLayer.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  ChoroplethLayer.prototype.pick = function pick (opts) {\n    Layer.prototype.pick.call(this, opts);\n    var info = opts.info;\n    var index = this.decodePickingColor(info.color);\n    var feature = index >= 0 ? this.props.data.features[index] : null;\n    info.feature = feature;\n    info.object = feature;\n  };\n\n  ChoroplethLayer.prototype.getModel = function getModel (gl) {\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: this.props.drawContour ? __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLES\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  };\n\n  ChoroplethLayer.prototype.calculateIndices = function calculateIndices (attribute) {\n    var this$1 = this;\n\n    // adjust index offset for multiple choropleths\n    var offsets = this.state.choropleths.reduce(function (acc, choropleth) { return acc.concat( [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) { return count + polygon.length; }, 0)]); }, [0]);\n    var ref = this.state;\n    var IndexType = ref.IndexType;\n    if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {\n      throw new Error('Vertex count exceeds browser\\'s limit');\n    }\n\n    var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) { return this$1.props.drawContour ?\n    // 1. get sequentially ordered indices of each choropleth contour\n    // 2. offset them by the number of indices in previous choropleths\n    calculateContourIndices(choropleth).map(function (index) { return index + offsets[choroplethIndex]; }) :\n    // 1. get triangulated indices for the internal areas\n    // 2. offset them by the number of indices in previous choropleths\n    calculateSurfaceIndices(choropleth).map(function (index) { return index + offsets[choroplethIndex]; }); });\n\n    attribute.value = new IndexType(__WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep___default()(indices));\n    attribute.target = __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n    this.state.model.setVertexCount(attribute.value.length / attribute.size);\n  };\n\n  ChoroplethLayer.prototype.calculatePositions = function calculatePositions (attribute) {\n    var vertices = __WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep___default()(this.state.choropleths);\n    attribute.value = new Float32Array(vertices);\n  };\n\n  ChoroplethLayer.prototype.calculateColors = function calculateColors (attribute) {\n    var ref = this.props;\n    var features = ref.data.features;\n    var getColor = ref.getColor;\n\n    var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n      var feature = features[choropleth.featureIndex];\n      var color = getColor(feature) || DEFAULT_COLOR;\n\n      if (isNaN(color[3])) {\n        color[3] = DEFAULT_COLOR[3];\n      }\n\n      return choropleth.map(function (polygon) { return polygon.map(function (vertex) { return color; }); });\n    });\n\n    attribute.value = new Uint8Array(__WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep___default()(colors));\n  };\n\n  // Override the default picking colors calculation\n  ChoroplethLayer.prototype.calculatePickingColors = function calculatePickingColors (attribute) {\n    var this$1 = this;\n\n\n    var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n      var featureIndex = choropleth.featureIndex;\n      var color = this$1.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];\n      return choropleth.map(function (polygon) { return polygon.map(function (vertex) { return color; }); });\n    });\n\n    attribute.value = new Uint8Array(__WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep___default()(colors));\n  };\n\n  return ChoroplethLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ChoroplethLayer;\n\nChoroplethLayer.layerName = 'ChoroplethLayer';\n\n/*\n * converts list of features from a GeoJSON object to a list of GeoJSON\n * polygon-style coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction extractChoropleths(data) {\n  var normalizedGeojson = __WEBPACK_IMPORTED_MODULE_4_geojson_normalize___default()(data);\n  var result = [];\n\n  normalizedGeojson.features.map(function (feature, featureIndex) {\n    var choropleths = featureToChoropleths(feature);\n    choropleths.forEach(function (choropleth) {\n      choropleth.featureIndex = featureIndex;\n    });\n    result.push.apply(result, choropleths);\n  });\n  return result;\n}\n\n/*\n * converts one GeoJSON features from object to a list of GeoJSON polygon-style\n * coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction featureToChoropleths(feature) {\n  var ref = feature.geometry;\n  var coordinates = ref.coordinates;\n  var type = ref.type;\n  var choropleths;\n\n  switch (type) {\n    case 'MultiPolygon':\n      choropleths = coordinates;\n      break;\n    case 'Polygon':\n      choropleths = [coordinates];\n      break;\n    case 'LineString':\n      // create a LineStringLayer for LineString and MultiLineString?\n      choropleths = [[coordinates]];\n      break;\n    case 'MultiLineString':\n      choropleths = coordinates.map(function (coords) { return [coords]; });\n      break;\n    default:\n      choropleths = [];\n  }\n  return choropleths.map(function (choropleth) { return choropleth.map(function (polygon) { return polygon.map(function (coordinate) { return [coordinate[0], coordinate[1], coordinate[2] || 0]; }); }); });\n}\n\n/*\n * get vertex indices for drawing choropleth contour\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateContourIndices(choropleth) {\n  var offset = 0;\n\n  return choropleth.reduce(function (acc, polygon) {\n    var numVertices = polygon.length;\n\n    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]\n    var indices = acc.concat( [offset]);\n    for (var i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n    indices.push(offset + numVertices - 1);\n\n    offset += numVertices;\n    return indices;\n  }, []);\n}\n\n/*\n * get vertex indices for drawing choropleth mesh\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateSurfaceIndices(choropleth) {\n  var holes = null;\n\n  if (choropleth.length > 1) {\n    holes = choropleth.reduce(function (acc, polygon) { return acc.concat( [acc[acc.length - 1] + polygon.length]); }, [0]).slice(1, choropleth.length);\n  }\n\n  return __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__WEBPACK_IMPORTED_MODULE_3_lodash_flattendeep___default()(choropleth), holes, 3);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL2Nob3JvcGxldGgtbGF5ZXIvY2hvcm9wbGV0aC1sYXllci5qcz9hYzdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgZmxhdHRlbkRlZXAgZnJvbSAnbG9kYXNoLmZsYXR0ZW5kZWVwJztcbmltcG9ydCBub3JtYWxpemUgZnJvbSAnZ2VvanNvbi1ub3JtYWxpemUnO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMjU1LCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGdldENvbG9yOiBmZWF0dXJlID0+IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcixcbiAgZHJhd0NvdW50b3VyOiBmYWxzZSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENob3JvcGxldGhMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKSk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBjaG9yb3BsZXRoLWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgY29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XFxuXFxuLy8gUElDS0lOR1xcbnVuaWZvcm0gZmxvYXQgcGlja2luZ0VuYWJsZWQ7XFxudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XFxudm9pZCBwaWNraW5nX3NldFBpY2tDb2xvcih2ZWMzIHBpY2tpbmdDb2xvcikge1xcbiAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9yLCAgMS4pO1xcbn1cXG52ZWM0IHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyh2ZWM0IGNvbG9yLCB2ZWMzIHBpY2tpbmdDb2xvcikge1xcbiAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IucmdiLCAxLik7XFxuICB2UGlja2luZ0NvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3I0LCBwaWNraW5nRW5hYmxlZCk7XFxuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcXG59XFxuXFxuLy8gUElDS0lOR1xcbi8vIHZlYzQgZ2V0Q29sb3IodmVjNCBjb2xvciwgZmxvYXQgb3BhY2l0eSwgdmVjMyBwaWNraW5nQ29sb3IsIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXIpIHtcXG4vLyAgIHZlYzQgY29sb3I0ID0gdmVjNChjb2xvci54eXogLyAyNTUuLCBjb2xvci53IC8gMjU1LiAqIG9wYWNpdHkpO1xcbi8vICAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IgLyAyNTUuLCAxLik7XFxuLy8gICByZXR1cm4gbWl4KGNvbG9yNCwgcGlja2luZ0NvbG9yNCwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XFxuLy8gfVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuICB2ZWM0IGNvbG9yID0gdmVjNChjb2xvcnMucmdiLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG5cXG4gIHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyhcXG4gICAgY29sb3IsXFxuICAgIHBpY2tpbmdDb2xvcnMgLyAyNTUuXFxuICApO1xcblxcbiAgdmVjMyBwID0gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbnMpO1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KHAsIDEuKSk7XFxufVxcbicsXG4gICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBjaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBQSUNLSU5HXFxuLy8gdW5pZm9ybSBib29sIHBpY2tpbmdFbmFibGVkO1xcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xcbnZlYzQgcGlja2luZ19nZXRDb2xvcigpIHtcXG4gIHJldHVybiB2UGlja2luZ0NvbG9yO1xcbn1cXG4vLyBQSUNLSU5HXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHBpY2tpbmdfZ2V0Q29sb3IoKTtcXG59XFxuJ1xuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkRHluYW1pYyh7XG4gICAgICAvLyBQcmltdGl2ZSBhdHRyaWJ1dGVzXG4gICAgICBpbmRpY2VzOiB7IHNpemU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzLCBpc0luZGV4ZWQ6IHRydWUgfSxcbiAgICAgIHBvc2l0aW9uczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zIH0sXG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc1xuICAgICAgfSxcbiAgICAgIC8vIEluc3RhbmNlZCBhdHRyaWJ1dGVzXG4gICAgICBwaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLFxuICAgICAgICBub0FsbG9jOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBJbmRleFR5cGUgPSBnbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsKGdsKSxcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIEluZGV4VHlwZVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoeyBvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzIH0pIHtcbiAgICBjb25zdCB7IGF0dHJpYnV0ZU1hbmFnZXIgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnN0YXRlLmNob3JvcGxldGhzID0gZXh0cmFjdENob3JvcGxldGhzKHByb3BzLmRhdGEpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFByb3BzLm9wYWNpdHkgIT09IHByb3BzLm9wYWNpdHkpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMoeyBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5IH0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoeyB1bmlmb3JtcyB9KSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMuc2NyZWVuVG9EZXZpY2VQaXhlbHModGhpcy5wcm9wcy5zdHJva2VXaWR0aCk7XG4gICAgZ2wubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIC8vIFNldHRpbmcgbGluZSB3aWR0aCBiYWNrIHRvIDEgaXMgaGVyZSB0byB3b3JrYXJvdW5kIGEgR29vZ2xlIENocm9tZSBidWdcbiAgICAvLyBnbC5jbGVhcigpIGFuZCBnbC5pc0VuYWJsZWQoKSB3aWxsIHJldHVybiBHTF9JTlZBTElEX1ZBTFVFIGV2ZW4gd2l0aFxuICAgIC8vIGNvcnJlY3QgcGFyYW1ldGVyXG4gICAgLy8gVGhpcyBpcyBub3QgaGFwcGVuaW5nIG9uIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgIGdsLmxpbmVXaWR0aCgxLjApO1xuICB9XG5cbiAgcGljayhvcHRzKSB7XG4gICAgc3VwZXIucGljayhvcHRzKTtcbiAgICBjb25zdCB7IGluZm8gfSA9IG9wdHM7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihpbmZvLmNvbG9yKTtcbiAgICBjb25zdCBmZWF0dXJlID0gaW5kZXggPj0gMCA/IHRoaXMucHJvcHMuZGF0YS5mZWF0dXJlc1tpbmRleF0gOiBudWxsO1xuICAgIGluZm8uZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgaW5mby5vYmplY3QgPSBmZWF0dXJlO1xuICB9XG5cbiAgZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiB0aGlzLnByb3BzLmRyYXdDb250b3VyID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgY2hvcm9wbGV0aHNcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5yZWR1Y2UoKGFjYywgY2hvcm9wbGV0aCkgPT4gWy4uLmFjYywgYWNjW2FjYy5sZW5ndGggLSAxXSArIGNob3JvcGxldGgucmVkdWNlKChjb3VudCwgcG9seWdvbikgPT4gY291bnQgKyBwb2x5Z29uLmxlbmd0aCwgMCldLCBbMF0pO1xuICAgIGNvbnN0IHsgSW5kZXhUeXBlIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChJbmRleFR5cGUgPT09IFVpbnQxNkFycmF5ICYmIG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXSA+IDY1NTM1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBjb3VudCBleGNlZWRzIGJyb3dzZXJcXCdzIGxpbWl0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggY2hvcm9wbGV0aCBjb250b3VyXG4gICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGNob3JvcGxldGhzXG4gICAgY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdKSA6XG4gICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgY2hvcm9wbGV0aHNcbiAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXRzW2Nob3JvcGxldGhJbmRleF0pKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBJbmRleFR5cGUoZmxhdHRlbkRlZXAoaW5kaWNlcykpO1xuICAgIGF0dHJpYnV0ZS50YXJnZXQgPSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFZlcnRleENvdW50KGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSk7XG4gIH1cblxuICBjYWxjdWxhdGVQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgdmVydGljZXMgPSBmbGF0dGVuRGVlcCh0aGlzLnN0YXRlLmNob3JvcGxldGhzKTtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGE6IHsgZmVhdHVyZXMgfSwgZ2V0Q29sb3IgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcCgoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbY2hvcm9wbGV0aC5mZWF0dXJlSW5kZXhdO1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihmZWF0dXJlKSB8fCBERUZBVUxUX0NPTE9SO1xuXG4gICAgICBpZiAoaXNOYU4oY29sb3JbM10pKSB7XG4gICAgICAgIGNvbG9yWzNdID0gREVGQVVMVF9DT0xPUlszXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKHBvbHlnb24gPT4gcG9seWdvbi5tYXAodmVydGV4ID0+IGNvbG9yKSk7XG4gICAgfSk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDhBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG4gIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlKSB7XG5cbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcCgoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGZlYXR1cmVJbmRleCB9ID0gY2hvcm9wbGV0aDtcbiAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IFswLCAwLCAwXSA6IFsoZmVhdHVyZUluZGV4ICsgMSkgJSAyNTYsIE1hdGguZmxvb3IoKGZlYXR1cmVJbmRleCArIDEpIC8gMjU2KSAlIDI1NiwgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XTtcbiAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChwb2x5Z29uID0+IHBvbHlnb24ubWFwKHZlcnRleCA9PiBjb2xvcikpO1xuICAgIH0pO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG4gIH1cbn1cblxuQ2hvcm9wbGV0aExheWVyLmxheWVyTmFtZSA9ICdDaG9yb3BsZXRoTGF5ZXInO1xuXG4vKlxuICogY29udmVydHMgbGlzdCBvZiBmZWF0dXJlcyBmcm9tIGEgR2VvSlNPTiBvYmplY3QgdG8gYSBsaXN0IG9mIEdlb0pTT05cbiAqIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZ2VvanNvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXVtdfSBhcnJheSBvZiBjaG9yb3BsZXRoc1xuICovXG5mdW5jdGlvbiBleHRyYWN0Q2hvcm9wbGV0aHMoZGF0YSkge1xuICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZShkYXRhKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgbm9ybWFsaXplZEdlb2pzb24uZmVhdHVyZXMubWFwKChmZWF0dXJlLCBmZWF0dXJlSW5kZXgpID0+IHtcbiAgICBjb25zdCBjaG9yb3BsZXRocyA9IGZlYXR1cmVUb0Nob3JvcGxldGhzKGZlYXR1cmUpO1xuICAgIGNob3JvcGxldGhzLmZvckVhY2goY2hvcm9wbGV0aCA9PiB7XG4gICAgICBjaG9yb3BsZXRoLmZlYXR1cmVJbmRleCA9IGZlYXR1cmVJbmRleDtcbiAgICB9KTtcbiAgICByZXN1bHQucHVzaCguLi5jaG9yb3BsZXRocyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogY29udmVydHMgb25lIEdlb0pTT04gZmVhdHVyZXMgZnJvbSBvYmplY3QgdG8gYSBsaXN0IG9mIEdlb0pTT04gcG9seWdvbi1zdHlsZVxuICogY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZ2VvanNvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXVtdfSBhcnJheSBvZiBjaG9yb3BsZXRoc1xuICovXG5mdW5jdGlvbiBmZWF0dXJlVG9DaG9yb3BsZXRocyhmZWF0dXJlKSB7XG4gIGNvbnN0IHsgY29vcmRpbmF0ZXMsIHR5cGUgfSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gIGxldCBjaG9yb3BsZXRocztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgY2hvcm9wbGV0aHMgPSBjb29yZGluYXRlcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgY2hvcm9wbGV0aHMgPSBbY29vcmRpbmF0ZXNdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAvLyBjcmVhdGUgYSBMaW5lU3RyaW5nTGF5ZXIgZm9yIExpbmVTdHJpbmcgYW5kIE11bHRpTGluZVN0cmluZz9cbiAgICAgIGNob3JvcGxldGhzID0gW1tjb29yZGluYXRlc11dO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIGNob3JvcGxldGhzID0gY29vcmRpbmF0ZXMubWFwKGNvb3JkcyA9PiBbY29vcmRzXSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY2hvcm9wbGV0aHMgPSBbXTtcbiAgfVxuICByZXR1cm4gY2hvcm9wbGV0aHMubWFwKGNob3JvcGxldGggPT4gY2hvcm9wbGV0aC5tYXAocG9seWdvbiA9PiBwb2x5Z29uLm1hcChjb29yZGluYXRlID0+IFtjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdIHx8IDBdKSkpO1xufVxuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggY29udG91clxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgcmV0dXJuIGNob3JvcGxldGgucmVkdWNlKChhY2MsIHBvbHlnb24pID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgZ2wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0yLCBuLTIsIG4tMV1cbiAgICBjb25zdCBpbmRpY2VzID0gWy4uLmFjYywgb2Zmc2V0XTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyBudW1WZXJ0aWNlcyAtIDEpO1xuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9LCBbXSk7XG59XG5cbi8qXG4gKiBnZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY2hvcm9wbGV0aCBtZXNoXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjaG9yb3BsZXRoXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY2hvcm9wbGV0aCkge1xuICBsZXQgaG9sZXMgPSBudWxsO1xuXG4gIGlmIChjaG9yb3BsZXRoLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IGNob3JvcGxldGgucmVkdWNlKChhY2MsIHBvbHlnb24pID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aF0sIFswXSkuc2xpY2UoMSwgY2hvcm9wbGV0aC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGVhcmN1dChmbGF0dGVuRGVlcChjaG9yb3BsZXRoKSwgaG9sZXMsIDMpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2NvcmUvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxKQTtBQUNBO0FBaUpBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 40 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/line-layer/line-layer.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 255, 0, 255];\n\nvar defaultProps = {\n  getSourcePosition: function (x) { return x.sourcePosition; },\n  getTargetPosition: function (x) { return x.targetPosition; },\n  getColor: function (x) { return x.color || DEFAULT_COLOR; },\n  strokeWidth: 1\n};\n\nvar LineLayer = (function (Layer) {\n  function LineLayer(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) LineLayer.__proto__ = Layer;\n  LineLayer.prototype = Object.create( Layer && Layer.prototype );\n  LineLayer.prototype.constructor = LineLayer;\n\n  LineLayer.prototype.initializeState = function initializeState () {\n    var ref = this.context;\n    var gl = ref.gl;\n    this.setState({ model: this.createModel(gl) });\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    attributeManager.addInstanced({\n      instanceSourcePositions: { size: 3, update: this.calculateInstanceSourcePositions },\n      instanceTargetPositions: { size: 3, update: this.calculateInstanceTargetPositions },\n      instanceColors: {\n        type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        size: 4,\n        update: this.calculateInstanceColors\n      }\n    });\n  };\n\n  LineLayer.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  LineLayer.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME line-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 instanceSourcePositions;\\nattribute vec3 instanceTargetPositions;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  // Position\\n  vec3 source = project_position(instanceSourcePositions);\\n  vec3 target = project_position(instanceTargetPositions);\\n\\n  // linear interpolation of source & target to pick right coord\\n  float segmentIndex = positions.x;\\n  vec3 p = mix(source, target, segmentIndex);\\n\\n  gl_Position = project_to_clipspace(vec4(p, 1.));\\n\\n  // Color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(\\n    color,\\n    pickingColor,\\n    renderPickingBuffer\\n  );\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME line-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n    };\n  };\n\n  LineLayer.prototype.createModel = function createModel (gl) {\n    var positions = [0, 0, 0, 1, 1, 1];\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].LINE_STRIP,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  };\n\n  LineLayer.prototype.calculateInstanceSourcePositions = function calculateInstanceSourcePositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourcePosition = ref.getSourcePosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var sourcePosition = getSourcePosition(object);\n      value[i + 0] = sourcePosition[0];\n      value[i + 1] = sourcePosition[1];\n      value[i + 2] = sourcePosition[2] || 0;\n      i += size;\n    }\n  };\n\n  LineLayer.prototype.calculateInstanceTargetPositions = function calculateInstanceTargetPositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getTargetPosition = ref.getTargetPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var targetPosition = getTargetPosition(object);\n      value[i + 0] = targetPosition[0];\n      value[i + 1] = targetPosition[1];\n      value[i + 2] = targetPosition[2] || 0;\n      i += size;\n    }\n  };\n\n  LineLayer.prototype.calculateInstanceColors = function calculateInstanceColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getColor = ref.getColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var color = getColor(object);\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  return LineLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = LineLayer;\n\nLineLayer.layerName = 'LineLayer';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL2xpbmUtbGF5ZXIvbGluZS1sYXllci5qcz9lNjAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAyNTUsIDAsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZ2V0U291cmNlUG9zaXRpb246IHggPT4geC5zb3VyY2VQb3NpdGlvbixcbiAgZ2V0VGFyZ2V0UG9zaXRpb246IHggPT4geC50YXJnZXRQb3NpdGlvbixcbiAgZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1vZGVsOiB0aGlzLmNyZWF0ZU1vZGVsKGdsKSB9KTtcblxuICAgIGNvbnN0IHsgYXR0cmlidXRlTWFuYWdlciB9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMgfSxcbiAgICAgIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zOiB7IHNpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVRhcmdldFBvc2l0aW9ucyB9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkcmF3KHsgdW5pZm9ybXMgfSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLnNjcmVlblRvRGV2aWNlUGl4ZWxzKHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgpO1xuICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICAvLyBTZXR0aW5nIGxpbmUgd2lkdGggYmFjayB0byAxIGlzIGhlcmUgdG8gd29ya2Fyb3VuZCBhIEdvb2dsZSBDaHJvbWUgYnVnXG4gICAgLy8gZ2wuY2xlYXIoKSBhbmQgZ2wuaXNFbmFibGVkKCkgd2lsbCByZXR1cm4gR0xfSU5WQUxJRF9WQUxVRSBldmVuIHdpdGhcbiAgICAvLyBjb3JyZWN0IHBhcmFtZXRlclxuICAgIC8vIFRoaXMgaXMgbm90IGhhcHBlbmluZyBvbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICBnbC5saW5lV2lkdGgoMS4wKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGxpbmUtbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVRhcmdldFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBQb3NpdGlvblxcbiAgdmVjMyBzb3VyY2UgPSBwcm9qZWN0X3Bvc2l0aW9uKGluc3RhbmNlU291cmNlUG9zaXRpb25zKTtcXG4gIHZlYzMgdGFyZ2V0ID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVRhcmdldFBvc2l0aW9ucyk7XFxuXFxuICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvZiBzb3VyY2UgJiB0YXJnZXQgdG8gcGljayByaWdodCBjb29yZFxcbiAgZmxvYXQgc2VnbWVudEluZGV4ID0gcG9zaXRpb25zLng7XFxuICB2ZWMzIHAgPSBtaXgoc291cmNlLCB0YXJnZXQsIHNlZ21lbnRJbmRleCk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQocCwgMS4pKTtcXG5cXG4gIC8vIENvbG9yXFxuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xcbiAgdkNvbG9yID0gbWl4KFxcbiAgICBjb2xvcixcXG4gICAgcGlja2luZ0NvbG9yLFxcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXFxuICApO1xcbn1cXG4nLFxuICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcbiNkZWZpbmUgU0hBREVSX05BTUUgbGluZS1sYXllci1mcmFnbWVudC1zaGFkZXJcXG5cXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xcbn1cXG4nXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZU1vZGVsKGdsKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWzAsIDAsIDAsIDEsIDEsIDFdO1xuXG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuTElORV9TVFJJUCxcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgZ2V0U291cmNlUG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBzb3VyY2VQb3NpdGlvblswXTtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IHNvdXJjZVBvc2l0aW9uWzFdO1xuICAgICAgdmFsdWVbaSArIDJdID0gc291cmNlUG9zaXRpb25bMl0gfHwgMDtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVRhcmdldFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldFRhcmdldFBvc2l0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdmFsdWUsIHNpemUgfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gdGFyZ2V0UG9zaXRpb25bMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSB0YXJnZXRQb3NpdGlvblsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IHRhcmdldFBvc2l0aW9uWzJdIHx8IDA7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRDb2xvciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3Iob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IERFRkFVTFRfQ09MT1JbM10gOiBjb2xvclszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuTGluZUxheWVyLmxheWVyTmFtZSA9ICdMaW5lTGF5ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqR0E7QUFDQTtBQWdHQTtBQUNBOzs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 41 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/scatterplot-layer.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_RADIUS = 30;\nvar DEFAULT_COLOR = [255, 0, 255, 255];\n\nvar defaultGetPosition = function (x) { return x.position; };\nvar defaultGetRadius = function (x) { return x.radius || DEFAULT_RADIUS; };\nvar defaultGetColor = function (x) { return x.color || DEFAULT_COLOR; };\n\nvar defaultProps = {\n  getPosition: defaultGetPosition,\n  getRadius: defaultGetRadius,\n  getColor: defaultGetColor,\n  radius: 30, //  point radius in meters\n  radiusMinPixels: 0, //  min point radius in pixels\n  radiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels\n  drawOutline: false,\n  strokeWidth: 1\n};\n\nvar ScatterplotLayer = (function (Layer) {\n  function ScatterplotLayer(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ScatterplotLayer.__proto__ = Layer;\n  ScatterplotLayer.prototype = Object.create( Layer && Layer.prototype );\n  ScatterplotLayer.prototype.constructor = ScatterplotLayer;\n\n  ScatterplotLayer.prototype.getShaders = function getShaders (id) {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute float instanceRadius;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float radius;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  // Multiply out radius and clamp to limits\\n  float radiusPixels = clamp(\\n    project_scale(radius * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n\\n  // Find the center of the point and add the current vertex\\n  vec3 center = project_position(instancePositions);\\n  vec3 vertex = positions * radiusPixels;\\n  gl_Position = project_to_clipspace(vec4(center + vertex, 1.0));\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n    };\n  };\n\n  ScatterplotLayer.prototype.initializeState = function initializeState () {\n    /* eslint-disable */\n    var ref = this.context;\n    var gl = ref.gl;\n    var model = this._getModel(gl);\n    this.setState({ model: model });\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    attributeManager.addInstanced({\n      instancePositions: { size: 3, update: this.calculateInstancePositions },\n      instanceRadius: { size: 1, update: this.calculateInstanceRadius },\n      instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculateInstanceColors }\n    });\n  };\n\n  ScatterplotLayer.prototype.updateState = function updateState (evt) {\n    Layer.prototype.updateState.call(this, evt);\n    var props = evt.props;\n    var oldProps = evt.oldProps;\n    if (props.drawOutline !== oldProps.drawOutline) {\n      this.state.model.geometry.drawMode = props.drawOutline ? __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].LINE_LOOP : __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN;\n    }\n  };\n\n  ScatterplotLayer.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(Object.assign({}, uniforms, {\n      radius: this.props.radius,\n      radiusMinPixels: this.props.radiusMinPixels,\n      radiusMaxPixels: this.props.radiusMaxPixels\n    }));\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  ScatterplotLayer.prototype._getModel = function _getModel (gl) {\n    var NUM_SEGMENTS = 16;\n    var positions = [];\n    for (var i = 0; i < NUM_SEGMENTS; i++) {\n      positions.push(Math.cos(Math.PI * 2 * i / NUM_SEGMENTS), Math.sin(Math.PI * 2 * i / NUM_SEGMENTS), 0);\n    }\n    /* eslint-disable */\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n    return model;\n  };\n\n  ScatterplotLayer.prototype.calculateInstancePositions = function calculateInstancePositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getPosition = ref.getPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var point = list[i$1];\n\n      var position = getPosition(point);\n      value[i + 0] = position[0] || 0;\n      value[i + 1] = position[1] || 0;\n      value[i + 2] = position[2] || 0;\n      i += size;\n    }\n  };\n\n  ScatterplotLayer.prototype.calculateInstanceRadius = function calculateInstanceRadius (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getRadius = ref.getRadius;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var point = list[i$1];\n\n      var radius = getRadius(point);\n      value[i + 0] = isNaN(radius) ? 1 : radius;\n      i += size;\n    }\n  };\n\n  ScatterplotLayer.prototype.calculateInstanceColors = function calculateInstanceColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getColor = ref.getColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var point = list[i$1];\n\n      var color = getColor(point);\n      value[i + 0] = color[0] || 0;\n      value[i + 1] = color[1] || 0;\n      value[i + 2] = color[2] || 0;\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  return ScatterplotLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ScatterplotLayer;\n\nScatterplotLayer.layerName = 'ScatterplotLayer';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLmpzPzNlMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHsgYXNzZW1ibGVTaGFkZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7IEdMLCBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5jb25zdCBERUZBVUxUX1JBRElVUyA9IDMwO1xuY29uc3QgREVGQVVMVF9DT0xPUiA9IFsyNTUsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdEdldFBvc2l0aW9uID0geCA9PiB4LnBvc2l0aW9uO1xuY29uc3QgZGVmYXVsdEdldFJhZGl1cyA9IHggPT4geC5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG5jb25zdCBkZWZhdWx0R2V0Q29sb3IgPSB4ID0+IHguY29sb3IgfHwgREVGQVVMVF9DT0xPUjtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRQb3NpdGlvbjogZGVmYXVsdEdldFBvc2l0aW9uLFxuICBnZXRSYWRpdXM6IGRlZmF1bHRHZXRSYWRpdXMsXG4gIGdldENvbG9yOiBkZWZhdWx0R2V0Q29sb3IsXG4gIHJhZGl1czogMzAsIC8vICBwb2ludCByYWRpdXMgaW4gbWV0ZXJzXG4gIHJhZGl1c01pblBpeGVsczogMCwgLy8gIG1pbiBwb2ludCByYWRpdXMgaW4gcGl4ZWxzXG4gIHJhZGl1c01heFBpeGVsczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIC8vIG1heCBwb2ludCByYWRpdXMgaW4gcGl4ZWxzXG4gIGRyYXdPdXRsaW5lOiBmYWxzZSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJwbG90TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcykpO1xuICB9XG5cbiAgZ2V0U2hhZGVycyhpZCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBzY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVJhZGl1cztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBNdWx0aXBseSBvdXQgcmFkaXVzIGFuZCBjbGFtcCB0byBsaW1pdHNcXG4gIGZsb2F0IHJhZGl1c1BpeGVscyA9IGNsYW1wKFxcbiAgICBwcm9qZWN0X3NjYWxlKHJhZGl1cyAqIGluc3RhbmNlUmFkaXVzKSxcXG4gICAgcmFkaXVzTWluUGl4ZWxzLCByYWRpdXNNYXhQaXhlbHNcXG4gICk7XFxuXFxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XFxuICB2ZWMzIGNlbnRlciA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMpO1xcbiAgdmVjMyB2ZXJ0ZXggPSBwb3NpdGlvbnMgKiByYWRpdXNQaXhlbHM7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoY2VudGVyICsgdmVydGV4LCAxLjApKTtcXG5cXG4gIC8vIEFwcGx5IG9wYWNpdHkgdG8gaW5zdGFuY2UgY29sb3IsIG9yIHJldHVybiBpbnN0YW5jZSBwaWNraW5nIGNvbG9yXFxuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xcbn1cXG4nLFxuICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG59XFxuJ1xuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChnbCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1vZGVsIH0pO1xuXG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7IHNpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyB9LFxuICAgICAgaW5zdGFuY2VSYWRpdXM6IHsgc2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUmFkaXVzIH0sXG4gICAgICBpbnN0YW5jZUNvbG9yczogeyBzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoZXZ0KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoZXZ0KTtcbiAgICBjb25zdCB7IHByb3BzLCBvbGRQcm9wcyB9ID0gZXZ0O1xuICAgIGlmIChwcm9wcy5kcmF3T3V0bGluZSAhPT0gb2xkUHJvcHMuZHJhd091dGxpbmUpIHtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuZ2VvbWV0cnkuZHJhd01vZGUgPSBwcm9wcy5kcmF3T3V0bGluZSA/IEdMLkxJTkVfTE9PUCA6IEdMLlRSSUFOR0xFX0ZBTjtcbiAgICB9XG4gIH1cblxuICBkcmF3KHsgdW5pZm9ybXMgfSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLnNjcmVlblRvRGV2aWNlUGl4ZWxzKHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgpO1xuICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICByYWRpdXM6IHRoaXMucHJvcHMucmFkaXVzLFxuICAgICAgcmFkaXVzTWluUGl4ZWxzOiB0aGlzLnByb3BzLnJhZGl1c01pblBpeGVscyxcbiAgICAgIHJhZGl1c01heFBpeGVsczogdGhpcy5wcm9wcy5yYWRpdXNNYXhQaXhlbHNcbiAgICB9KSk7XG4gICAgLy8gU2V0dGluZyBsaW5lIHdpZHRoIGJhY2sgdG8gMSBpcyBoZXJlIHRvIHdvcmthcm91bmQgYSBHb29nbGUgQ2hyb21lIGJ1Z1xuICAgIC8vIGdsLmNsZWFyKCkgYW5kIGdsLmlzRW5hYmxlZCgpIHdpbGwgcmV0dXJuIEdMX0lOVkFMSURfVkFMVUUgZXZlbiB3aXRoXG4gICAgLy8gY29ycmVjdCBwYXJhbWV0ZXJcbiAgICAvLyBUaGlzIGlzIG5vdCBoYXBwZW5pbmcgb24gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgZ2wubGluZVdpZHRoKDEuMCk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBOVU1fU0VHTUVOVFMgPSAxNjtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5VTV9TRUdNRU5UUzsgaSsrKSB7XG4gICAgICBwb3NpdGlvbnMucHVzaChNYXRoLmNvcyhNYXRoLlBJICogMiAqIGkgLyBOVU1fU0VHTUVOVFMpLCBNYXRoLnNpbihNYXRoLlBJICogMiAqIGkgLyBOVU1fU0VHTUVOVFMpLCAwKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX0ZBTixcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldFBvc2l0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdmFsdWUsIHNpemUgfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IHBvc2l0aW9uWzBdIHx8IDA7XG4gICAgICB2YWx1ZVtpICsgMV0gPSBwb3NpdGlvblsxXSB8fCAwO1xuICAgICAgdmFsdWVbaSArIDJdID0gcG9zaXRpb25bMl0gfHwgMDtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVJhZGl1cyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldFJhZGl1cyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcmFkaXVzID0gZ2V0UmFkaXVzKHBvaW50KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGlzTmFOKHJhZGl1cykgPyAxIDogcmFkaXVzO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgZ2V0Q29sb3IgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IocG9pbnQpO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF0gfHwgMDtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGNvbG9yWzFdIHx8IDA7XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXSB8fCAwO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gREVGQVVMVF9DT0xPUlszXSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5TY2F0dGVycGxvdExheWVyLmxheWVyTmFtZSA9ICdTY2F0dGVycGxvdExheWVyJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9jb3JlL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvR0E7QUFDQTtBQThHQTtBQUNBOzs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 42 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/screen-grid-layer/screen-grid-layer.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar defaultProps = {\n  // @type {number} opts.unitWidth - width of the unit rectangle\n  unitWidth: 100,\n  // @type {number} opts.unitHeight - height of the unit rectangle\n  unitHeight: 100,\n  minColor: [0, 0, 0, 255],\n  maxColor: [0, 255, 0, 255],\n  getPosition: function (d) { return d.position; },\n  getWeight: function (d) { return 1; }\n};\n\nvar ScreenGridLayer = (function (Layer) {\n  function ScreenGridLayer(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ScreenGridLayer.__proto__ = Layer;\n  ScreenGridLayer.prototype = Object.create( Layer && Layer.prototype );\n  ScreenGridLayer.prototype.constructor = ScreenGridLayer;\n\n  ScreenGridLayer.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME grid-layer-vs\\n\\nattribute vec3 vertices;\\nattribute vec3 instancePositions;\\nattribute float instanceCount;\\nattribute vec3 instancePickingColors;\\n\\nuniform float maxCount;\\nuniform float opacity;\\nuniform vec4 minColor;\\nuniform vec4 maxColor;\\nuniform float renderPickingBuffer;\\nuniform vec3 cellScale;\\nuniform vec3 selectedPickingColor;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  vec4 color = mix(minColor, maxColor, instanceCount / maxCount) / 255.;\\n\\n  vColor = mix(\\n    vec4(color.rgb, color.a * opacity),\\n    vec4(instancePickingColors / 255., 1.),\\n    renderPickingBuffer\\n  );\\n\\n  gl_Position = vec4(instancePositions + vertices * cellScale, 1.);\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n/* fragment shader for the grid-layer */\\n#define SHADER_NAME grid-layer-fs\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n    };\n  };\n\n  ScreenGridLayer.prototype.initializeState = function initializeState () {\n    var ref = this.state;\n    var attributeManager = ref.attributeManager;\n    attributeManager.addInstanced({\n      instancePositions: { size: 3, update: this.calculateInstancePositions },\n      instanceCount: { size: 1, update: this.calculateInstanceCount }\n    });\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    this.setState({ model: this.getModel(gl) });\n  };\n\n  ScreenGridLayer.prototype.updateState = function updateState (ref) {\n    var oldProps = ref.oldProps;\n    var props = ref.props;\n    var changeFlags = ref.changeFlags;\n\n    var cellSizeChanged = props.unitWidth !== oldProps.unitWidth || props.unitHeight !== oldProps.unitHeight;\n\n    if (cellSizeChanged || changeFlags.viewportChanged) {\n      this.updateCell();\n    }\n  };\n\n  ScreenGridLayer.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.props;\n    var minColor = ref$1.minColor;\n    var maxColor = ref$1.maxColor;\n    var ref$2 = this.state;\n    var model = ref$2.model;\n    var cellScale = ref$2.cellScale;\n    var maxCount = ref$2.maxCount;\n    var ref$3 = this.context;\n    var gl = ref$3.gl;\n    gl.depthMask(true);\n    uniforms = Object.assign({}, uniforms, { minColor: minColor, maxColor: maxColor, cellScale: cellScale, maxCount: maxCount });\n    model.render(uniforms);\n  };\n\n  ScreenGridLayer.prototype.getModel = function getModel (gl) {\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n        vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n      }),\n      isInstanced: true\n    });\n  };\n\n  ScreenGridLayer.prototype.updateCell = function updateCell () {\n    var ref = this.context.viewport;\n    var width = ref.width;\n    var height = ref.height;\n    var ref$1 = this.props;\n    var unitWidth = ref$1.unitWidth;\n    var unitHeight = ref$1.unitHeight;\n\n    var MARGIN = 2;\n    var cellScale = new Float32Array([(unitWidth - MARGIN) / width * 2, -(unitHeight - MARGIN) / height * 2, 1]);\n    var numCol = Math.ceil(width / unitWidth);\n    var numRow = Math.ceil(height / unitHeight);\n\n    this.setState({\n      cellScale: cellScale,\n      numCol: numCol,\n      numRow: numRow,\n      numInstances: numCol * numRow\n    });\n\n    var ref$2 = this.state;\n    var attributeManager = ref$2.attributeManager;\n    attributeManager.invalidateAll();\n  };\n\n  ScreenGridLayer.prototype.calculateInstancePositions = function calculateInstancePositions (attribute, ref) {\n    var numInstances = ref.numInstances;\n\n    var ref$1 = this.context.viewport;\n    var width = ref$1.width;\n    var height = ref$1.height;\n    var ref$2 = this.props;\n    var unitWidth = ref$2.unitWidth;\n    var unitHeight = ref$2.unitHeight;\n    var ref$3 = this.state;\n    var numCol = ref$3.numCol;\n    var value = attribute.value;\n    var size = attribute.size;\n\n    for (var i = 0; i < numInstances; i++) {\n      var x = i % numCol;\n      var y = Math.floor(i / numCol);\n      value[i * size + 0] = x * unitWidth / width * 2 - 1;\n      value[i * size + 1] = 1 - y * unitHeight / height * 2;\n      value[i * size + 2] = 0;\n    }\n  };\n\n  ScreenGridLayer.prototype.calculateInstanceCount = function calculateInstanceCount (attribute) {\n    var this$1 = this;\n\n    var ref = this.props;\n    var data = ref.data;\n    var unitWidth = ref.unitWidth;\n    var unitHeight = ref.unitHeight;\n    var getPosition = ref.getPosition;\n    var getWeight = ref.getWeight;\n    var ref$1 = this.state;\n    var numCol = ref$1.numCol;\n    var numRow = ref$1.numRow;\n    var value = attribute.value;\n    var maxCount = 0;\n\n    value.fill(0.0);\n\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var point = list[i$1];\n\n      var pixel = this$1.project(getPosition(point));\n      var colId = Math.floor(pixel[0] / unitWidth);\n      var rowId = Math.floor(pixel[1] / unitHeight);\n      if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {\n        var i = colId + rowId * numCol;\n        value[i] += getWeight(point);\n        if (value[i] > maxCount) {\n          maxCount = value[i];\n        }\n      }\n    }\n\n    this.setState({ maxCount: maxCount });\n  };\n\n  return ScreenGridLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ScreenGridLayer;\n\nScreenGridLayer.layerName = 'ScreenGridLayer';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9jb3JlL3NjcmVlbi1ncmlkLWxheWVyL3NjcmVlbi1ncmlkLWxheWVyLmpzPzk5NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHsgYXNzZW1ibGVTaGFkZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7IEdMLCBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIC8vIEB0eXBlIHtudW1iZXJ9IG9wdHMudW5pdFdpZHRoIC0gd2lkdGggb2YgdGhlIHVuaXQgcmVjdGFuZ2xlXG4gIHVuaXRXaWR0aDogMTAwLFxuICAvLyBAdHlwZSB7bnVtYmVyfSBvcHRzLnVuaXRIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIHVuaXQgcmVjdGFuZ2xlXG4gIHVuaXRIZWlnaHQ6IDEwMCxcbiAgbWluQ29sb3I6IFswLCAwLCAwLCAyNTVdLFxuICBtYXhDb2xvcjogWzAsIDI1NSwgMCwgMjU1XSxcbiAgZ2V0UG9zaXRpb246IGQgPT4gZC5wb3NpdGlvbixcbiAgZ2V0V2VpZ2h0OiBkID0+IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcmVlbkdyaWRMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKSk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBncmlkLWxheWVyLXZzXFxuXFxuYXR0cmlidXRlIHZlYzMgdmVydGljZXM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ291bnQ7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbnVuaWZvcm0gZmxvYXQgbWF4Q291bnQ7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gdmVjNCBtaW5Db2xvcjtcXG51bmlmb3JtIHZlYzQgbWF4Q29sb3I7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcbnVuaWZvcm0gdmVjMyBjZWxsU2NhbGU7XFxudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzQgY29sb3IgPSBtaXgobWluQ29sb3IsIG1heENvbG9yLCBpbnN0YW5jZUNvdW50IC8gbWF4Q291bnQpIC8gMjU1LjtcXG5cXG4gIHZDb2xvciA9IG1peChcXG4gICAgdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEgKiBvcGFjaXR5KSxcXG4gICAgdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLiksXFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcXG4gICk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoaW5zdGFuY2VQb3NpdGlvbnMgKyB2ZXJ0aWNlcyAqIGNlbGxTY2FsZSwgMS4pO1xcbn1cXG4nLFxuICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbi8qIGZyYWdtZW50IHNoYWRlciBmb3IgdGhlIGdyaWQtbGF5ZXIgKi9cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGdyaWQtbGF5ZXItZnNcXG5cXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xcbn1cXG4nXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGF0dHJpYnV0ZU1hbmFnZXIgfSA9IHRoaXMuc3RhdGU7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHsgc2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIH0sXG4gICAgICBpbnN0YW5jZUNvdW50OiB7IHNpemU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvdW50IH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoeyBvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzIH0pIHtcbiAgICBjb25zdCBjZWxsU2l6ZUNoYW5nZWQgPSBwcm9wcy51bml0V2lkdGggIT09IG9sZFByb3BzLnVuaXRXaWR0aCB8fCBwcm9wcy51bml0SGVpZ2h0ICE9PSBvbGRQcm9wcy51bml0SGVpZ2h0O1xuXG4gICAgaWYgKGNlbGxTaXplQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2VsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoeyB1bmlmb3JtcyB9KSB7XG4gICAgY29uc3QgeyBtaW5Db2xvciwgbWF4Q29sb3IgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBtb2RlbCwgY2VsbFNjYWxlLCBtYXhDb3VudCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHsgbWluQ29sb3IsIG1heENvbG9yLCBjZWxsU2NhbGUsIG1heENvdW50IH0pO1xuICAgIG1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX0ZBTixcbiAgICAgICAgdmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDBdKVxuICAgICAgfSksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlQ2VsbCgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICBjb25zdCB7IHVuaXRXaWR0aCwgdW5pdEhlaWdodCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IE1BUkdJTiA9IDI7XG4gICAgY29uc3QgY2VsbFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbKHVuaXRXaWR0aCAtIE1BUkdJTikgLyB3aWR0aCAqIDIsIC0odW5pdEhlaWdodCAtIE1BUkdJTikgLyBoZWlnaHQgKiAyLCAxXSk7XG4gICAgY29uc3QgbnVtQ29sID0gTWF0aC5jZWlsKHdpZHRoIC8gdW5pdFdpZHRoKTtcbiAgICBjb25zdCBudW1Sb3cgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gdW5pdEhlaWdodCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNlbGxTY2FsZSxcbiAgICAgIG51bUNvbCxcbiAgICAgIG51bVJvdyxcbiAgICAgIG51bUluc3RhbmNlczogbnVtQ29sICogbnVtUm93XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGF0dHJpYnV0ZU1hbmFnZXIgfSA9IHRoaXMuc3RhdGU7XG4gICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUsIHsgbnVtSW5zdGFuY2VzIH0pIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICBjb25zdCB7IHVuaXRXaWR0aCwgdW5pdEhlaWdodCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IG51bUNvbCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIG51bUNvbDtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGkgLyBudW1Db2wpO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHggKiB1bml0V2lkdGggLyB3aWR0aCAqIDIgLSAxO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAxXSA9IDEgLSB5ICogdW5pdEhlaWdodCAvIGhlaWdodCAqIDI7XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gMDtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvdW50KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgdW5pdFdpZHRoLCB1bml0SGVpZ2h0LCBnZXRQb3NpdGlvbiwgZ2V0V2VpZ2h0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgbnVtQ29sLCBudW1Sb3cgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBtYXhDb3VudCA9IDA7XG5cbiAgICB2YWx1ZS5maWxsKDAuMCk7XG5cbiAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdGhpcy5wcm9qZWN0KGdldFBvc2l0aW9uKHBvaW50KSk7XG4gICAgICBjb25zdCBjb2xJZCA9IE1hdGguZmxvb3IocGl4ZWxbMF0gLyB1bml0V2lkdGgpO1xuICAgICAgY29uc3Qgcm93SWQgPSBNYXRoLmZsb29yKHBpeGVsWzFdIC8gdW5pdEhlaWdodCk7XG4gICAgICBpZiAoY29sSWQgPj0gMCAmJiBjb2xJZCA8IG51bUNvbCAmJiByb3dJZCA+PSAwICYmIHJvd0lkIDwgbnVtUm93KSB7XG4gICAgICAgIGNvbnN0IGkgPSBjb2xJZCArIHJvd0lkICogbnVtQ29sO1xuICAgICAgICB2YWx1ZVtpXSArPSBnZXRXZWlnaHQocG9pbnQpO1xuICAgICAgICBpZiAodmFsdWVbaV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgIG1heENvdW50ID0gdmFsdWVbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgbWF4Q291bnQgfSk7XG4gIH1cbn1cblxuU2NyZWVuR3JpZExheWVyLmxheWVyTmFtZSA9ICdTY3JlZW5HcmlkTGF5ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXIuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWxIQTtBQUNBO0FBaUhBO0FBQ0E7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 43 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/layers/fp64/arc-layer/arc-layer-64.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 255, 255];\n\nvar defaultGetSourcePosition = function (x) { return x.sourcePosition; };\nvar defaultGetTargetPosition = function (x) { return x.targetPosition; };\nvar defaultGetColor = function (x) { return x.color; };\n\nvar defaultProps = {\n  getSourcePosition: defaultGetSourcePosition,\n  getTargetPosition: defaultGetTargetPosition,\n  getSourceColor: defaultGetColor,\n  getTargetColor: defaultGetColor,\n  strokeWidth: 1\n};\n\nvar ArcLayer64 = (function (Layer) {\n  function ArcLayer64(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ArcLayer64.__proto__ = Layer;\n  ArcLayer64.prototype = Object.create( Layer && Layer.prototype );\n  ArcLayer64.prototype.constructor = ArcLayer64;\n\n  ArcLayer64.prototype.initializeState = function initializeState () {\n    var ref = this.context;\n    var gl = ref.gl;\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n\n    attributeManager.addInstanced({\n      instanceSourcePositionsFP64: {\n        size: 4,\n        update: this.calculateInstanceSourcePositions\n      },\n      instanceTargetPositionsFP64: {\n        size: 4,\n        update: this.calculateInstanceTargetPositions\n      },\n      instanceSourceColors: {\n        size: 4,\n        type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        update: this.calculateInstanceSourceColors\n      },\n      instanceTargetColors: {\n        size: 4,\n        type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        update: this.calculateInstanceTargetColors\n      }\n    });\n\n    this.setState({ model: this.createModel(gl) });\n  };\n\n  ArcLayer64.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  ArcLayer64.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-64-vertex-shader\\n\\nconst float N = 49.0;\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourceColors;\\nattribute vec4 instanceTargetColors;\\nattribute vec3 instancePickingColors;\\nattribute vec4 instanceSourcePositionsFP64;\\nattribute vec4 instanceTargetPositionsFP64;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\\n\\n  vec2 x[2];\\n  vec2_mix_fp64(source, target, ratio, x);\\n  vec2 center[2];\\n  vec2_mix_fp64(source, target, 0.5, center);\\n\\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\\n  vec2 dXCenter = vec2_distance_fp64(x, center);\\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\\n}\\n\\nvoid main(void) {\\n  vec2 projectedSourceCoord[2];\\n  project_position_fp64(instanceSourcePositionsFP64, projectedSourceCoord);\\n  vec2 projectedTargetCoord[2];\\n  project_position_fp64(instanceTargetPositionsFP64, projectedTargetCoord);\\n\\n  float segmentRatio = smoothstep(0.0, 1.0, positions.x / N);\\n\\n  vec2 mixed_temp[2];\\n\\n  vec2_mix_fp64(projectedSourceCoord, projectedTargetCoord, segmentRatio, mixed_temp);\\n\\n  vec2 vertex_pos_modelspace[4];\\n\\n  vertex_pos_modelspace[0] = mixed_temp[0];\\n  vertex_pos_modelspace[1] = mixed_temp[1];\\n\\n  vec2 vertex_height = paraboloid_fp64(projectedSourceCoord, projectedTargetCoord, segmentRatio);\\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) vertex_height = vec2(0.0, 0.0);\\n\\n  vertex_pos_modelspace[2] = sqrt_fp64(vertex_height);\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\\n\\n  vColor = mix(\\n    vec4(color.rgb, color.a * opacity),\\n    vec4(instancePickingColors / 255., 1.),\\n    renderPickingBuffer\\n  );\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n',\n      fp64: true,\n      project64: true\n    };\n  };\n\n  ArcLayer64.prototype.createModel = function createModel (gl) {\n    var positions = [];\n    var NUM_SEGMENTS = 50;\n    for (var i = 0; i < NUM_SEGMENTS; i++) {\n      positions = positions.concat( [i], [i], [i]);\n    }\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINE_STRIP,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  };\n\n  ArcLayer64.prototype.calculateInstanceSourcePositions = function calculateInstanceSourcePositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourcePosition = ref.getSourcePosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var sourcePosition = getSourcePosition(object);\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[0]), value[i + 0] = assign[0], value[i + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[1]), value[i + 2] = assign$1[0], value[i + 3] = assign$1[1]);\n      i += size;\n    }\n  };\n\n  ArcLayer64.prototype.calculateInstanceTargetPositions = function calculateInstanceTargetPositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getTargetPosition = ref.getTargetPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var targetPosition = getTargetPosition(object);\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[0]), value[i + 0] = assign[0], value[i + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[1]), value[i + 2] = assign$1[0], value[i + 3] = assign$1[1]);\n      i += size;\n    }\n  };\n\n  ArcLayer64.prototype.calculateInstanceSourceColors = function calculateInstanceSourceColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourceColor = ref.getSourceColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var color = getSourceColor(object) || DEFAULT_COLOR;\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  ArcLayer64.prototype.calculateInstanceTargetColors = function calculateInstanceTargetColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getTargetColor = ref.getTargetColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var color = getTargetColor(object) || DEFAULT_COLOR;\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  return ArcLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ArcLayer64;\n\nArcLayer64.layerName = 'ArcLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2FyYy1sYXllci9hcmMtbGF5ZXItNjQuanM/OGVjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgZnA2NGlmeSB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7IEdMLCBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdEdldFNvdXJjZVBvc2l0aW9uID0geCA9PiB4LnNvdXJjZVBvc2l0aW9uO1xuY29uc3QgZGVmYXVsdEdldFRhcmdldFBvc2l0aW9uID0geCA9PiB4LnRhcmdldFBvc2l0aW9uO1xuY29uc3QgZGVmYXVsdEdldENvbG9yID0geCA9PiB4LmNvbG9yO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGdldFNvdXJjZVBvc2l0aW9uOiBkZWZhdWx0R2V0U291cmNlUG9zaXRpb24sXG4gIGdldFRhcmdldFBvc2l0aW9uOiBkZWZhdWx0R2V0VGFyZ2V0UG9zaXRpb24sXG4gIGdldFNvdXJjZUNvbG9yOiBkZWZhdWx0R2V0Q29sb3IsXG4gIGdldFRhcmdldENvbG9yOiBkZWZhdWx0R2V0Q29sb3IsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNMYXllcjY0IGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnNGUDY0OiB7XG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9uc1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zRlA2NDoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnNcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVNvdXJjZUNvbG9yczoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VDb2xvcnNcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVRhcmdldENvbG9yczoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRDb2xvcnNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5jcmVhdGVNb2RlbChnbCkgfSk7XG4gIH1cblxuICBkcmF3KHsgdW5pZm9ybXMgfSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLnNjcmVlblRvRGV2aWNlUGl4ZWxzKHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgpO1xuICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICAvLyBTZXR0aW5nIGxpbmUgd2lkdGggYmFjayB0byAxIGlzIGhlcmUgdG8gd29ya2Fyb3VuZCBhIEdvb2dsZSBDaHJvbWUgYnVnXG4gICAgLy8gZ2wuY2xlYXIoKSBhbmQgZ2wuaXNFbmFibGVkKCkgd2lsbCByZXR1cm4gR0xfSU5WQUxJRF9WQUxVRSBldmVuIHdpdGhcbiAgICAvLyBjb3JyZWN0IHBhcmFtZXRlclxuICAgIC8vIFRoaXMgaXMgbm90IGhhcHBlbmluZyBvbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICBnbC5saW5lV2lkdGgoMS4wKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGFyYy1sYXllci02NC12ZXJ0ZXgtc2hhZGVyXFxuXFxuY29uc3QgZmxvYXQgTiA9IDQ5LjA7XFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU291cmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlVGFyZ2V0Q29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVNvdXJjZVBvc2l0aW9uc0ZQNjQ7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnNGUDY0O1xcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52ZWMyIHBhcmFib2xvaWRfZnA2NCh2ZWMyIHNvdXJjZVsyXSwgdmVjMiB0YXJnZXRbMl0sIGZsb2F0IHJhdGlvKSB7XFxuXFxuICB2ZWMyIHhbMl07XFxuICB2ZWMyX21peF9mcDY0KHNvdXJjZSwgdGFyZ2V0LCByYXRpbywgeCk7XFxuICB2ZWMyIGNlbnRlclsyXTtcXG4gIHZlYzJfbWl4X2ZwNjQoc291cmNlLCB0YXJnZXQsIDAuNSwgY2VudGVyKTtcXG5cXG4gIHZlYzIgZFNvdXJjZUNlbnRlciA9IHZlYzJfZGlzdGFuY2VfZnA2NChzb3VyY2UsIGNlbnRlcik7XFxuICB2ZWMyIGRYQ2VudGVyID0gdmVjMl9kaXN0YW5jZV9mcDY0KHgsIGNlbnRlcik7XFxuICByZXR1cm4gbXVsX2ZwNjQoc3VtX2ZwNjQoZFNvdXJjZUNlbnRlciwgZFhDZW50ZXIpLCBzdWJfZnA2NChkU291cmNlQ2VudGVyLCBkWENlbnRlcikpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdmVjMiBwcm9qZWN0ZWRTb3VyY2VDb29yZFsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVNvdXJjZVBvc2l0aW9uc0ZQNjQsIHByb2plY3RlZFNvdXJjZUNvb3JkKTtcXG4gIHZlYzIgcHJvamVjdGVkVGFyZ2V0Q29vcmRbMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnNGUDY0LCBwcm9qZWN0ZWRUYXJnZXRDb29yZCk7XFxuXFxuICBmbG9hdCBzZWdtZW50UmF0aW8gPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBwb3NpdGlvbnMueCAvIE4pO1xcblxcbiAgdmVjMiBtaXhlZF90ZW1wWzJdO1xcblxcbiAgdmVjMl9taXhfZnA2NChwcm9qZWN0ZWRTb3VyY2VDb29yZCwgcHJvamVjdGVkVGFyZ2V0Q29vcmQsIHNlZ21lbnRSYXRpbywgbWl4ZWRfdGVtcCk7XFxuXFxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcXG5cXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IG1peGVkX3RlbXBbMF07XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBtaXhlZF90ZW1wWzFdO1xcblxcbiAgdmVjMiB2ZXJ0ZXhfaGVpZ2h0ID0gcGFyYWJvbG9pZF9mcDY0KHByb2plY3RlZFNvdXJjZUNvb3JkLCBwcm9qZWN0ZWRUYXJnZXRDb29yZCwgc2VnbWVudFJhdGlvKTtcXG4gIGlmICh2ZXJ0ZXhfaGVpZ2h0LnggPCAwLjAgfHwgKHZlcnRleF9oZWlnaHQueCA9PSAwLjAgJiYgdmVydGV4X2hlaWdodC55IDw9IDAuMCkpIHZlcnRleF9oZWlnaHQgPSB2ZWMyKDAuMCwgMC4wKTtcXG5cXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHNxcnRfZnA2NCh2ZXJ0ZXhfaGVpZ2h0KTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICB2ZWM0IGNvbG9yID0gbWl4KGluc3RhbmNlU291cmNlQ29sb3JzLCBpbnN0YW5jZVRhcmdldENvbG9ycywgc2VnbWVudFJhdGlvKSAvIDI1NS47XFxuXFxuICB2Q29sb3IgPSBtaXgoXFxuICAgIHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogb3BhY2l0eSksXFxuICAgIHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pLFxcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXFxuICApO1xcbn1cXG4nLFxuICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbicsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZU1vZGVsKGdsKSB7XG4gICAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IE5VTV9TRUdNRU5UUyA9IDUwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlVNX1NFR01FTlRTOyBpKyspIHtcbiAgICAgIHBvc2l0aW9ucyA9IFsuLi5wb3NpdGlvbnMsIGksIGksIGldO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IEdMLkxJTkVfU1RSSVAsXG4gICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldFNvdXJjZVBvc2l0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdmFsdWUsIHNpemUgfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuICAgICAgW3ZhbHVlW2kgKyAwXSwgdmFsdWVbaSArIDFdXSA9IGZwNjRpZnkoc291cmNlUG9zaXRpb25bMF0pO1xuICAgICAgW3ZhbHVlW2kgKyAyXSwgdmFsdWVbaSArIDNdXSA9IGZwNjRpZnkoc291cmNlUG9zaXRpb25bMV0pO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0UG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgZ2V0VGFyZ2V0UG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICBbdmFsdWVbaSArIDBdLCB2YWx1ZVtpICsgMV1dID0gZnA2NGlmeSh0YXJnZXRQb3NpdGlvblswXSk7XG4gICAgICBbdmFsdWVbaSArIDJdLCB2YWx1ZVtpICsgM11dID0gZnA2NGlmeSh0YXJnZXRQb3NpdGlvblsxXSk7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRTb3VyY2VDb2xvciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0U291cmNlQ29sb3Iob2JqZWN0KSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gREVGQVVMVF9DT0xPUlszXSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgZ2V0VGFyZ2V0Q29sb3IgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldFRhcmdldENvbG9yKG9iamVjdCkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IERFRkFVTFRfQ09MT1JbM10gOiBjb2xvclszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuQXJjTGF5ZXI2NC5sYXllck5hbWUgPSAnQXJjTGF5ZXI2NCc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9sYXllcnMvZnA2NC9hcmMtbGF5ZXIvYXJjLWxheWVyLTY0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEvSEE7QUFDQTtBQThIQTtBQUNBOzs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 44 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************************!*\
  !*** ./src/layers/fp64/choropleth-layer/choropleth-layer-64.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_geojson_normalize__ = __webpack_require__(/*! geojson-normalize */ 22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_geojson_normalize___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_geojson_normalize__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_earcut__ = __webpack_require__(/*! earcut */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 255, 255];\n\nvar defaultProps = {\n  getColor: function (feature) { return feature.properties.color || DEFAULT_COLOR; },\n  drawCountour: false,\n  strokeWidth: 1\n};\n\nvar ChoroplethLayer64 = (function (Layer) {\n  function ChoroplethLayer64(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ChoroplethLayer64.__proto__ = Layer;\n  ChoroplethLayer64.prototype = Object.create( Layer && Layer.prototype );\n  ChoroplethLayer64.prototype.constructor = ChoroplethLayer64;\n\n  ChoroplethLayer64.prototype.initializeState = function initializeState () {\n    var ref = this.context;\n    var gl = ref.gl;\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n\n    attributeManager.addDynamic({\n      // Primtive attributes\n      indices: { size: 1, update: this.calculateIndices, isIndexed: true },\n      positionsFP64: { size: 4, update: this.calculatePositionsFP64 },\n      heightsFP64: { size: 2, update: this.calculateHeightsFP64 },\n      colors: {\n        size: 4,\n        type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        update: this.calculateColors\n      },\n      // Instanced attributes\n      pickingColors: { size: 3, update: this.calculatePickingColors, noAlloc: true }\n    });\n\n    var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;\n\n    this.setState({\n      model: this.getModel(gl),\n      numInstances: 0,\n      IndexType: IndexType\n    });\n  };\n\n  ChoroplethLayer64.prototype.updateState = function updateState (ref) {\n    var oldProps = ref.oldProps;\n    var props = ref.props;\n    var changeFlags = ref.changeFlags;\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    if (changeFlags.dataChanged) {\n      this.state.choropleths = extractChoropleths(props.data);\n      attributeManager.invalidateAll();\n    }\n\n    if (oldProps.opacity !== props.opacity) {\n      this.setUniforms({ opacity: props.opacity });\n    }\n  };\n\n  ChoroplethLayer64.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  ChoroplethLayer64.prototype.pick = function pick (opts) {\n    Layer.prototype.pick.call(this, opts);\n    var info = opts.info;\n    var index = this.decodePickingColor(info.color);\n    var feature = index >= 0 ? this.props.data.features[index] : null;\n    info.feature = feature;\n    info.object = feature;\n  };\n\n  ChoroplethLayer64.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-64-vertex-shader\\n\\nattribute vec4 positionsFP64;\\nattribute vec2 heightsFP64;\\n\\nattribute vec3 positions;\\nattribute vec4 colors;\\nattribute vec3 pickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\nvarying vec4 vColor;\\n\\nvec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\\n  vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\\n  vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\\n  return mix(color4, pickingColor4, renderPickingBuffer);\\n}\\n\\nvoid main(void) {\\n  // For some reason, need to add one to elevation to show up in untilted mode\\n  vec2 projectedCoord[2];\\n  project_position_fp64(positionsFP64, projectedCoord);\\n\\n  vec2 vertex_pos_modelspace[4];\\n\\n  vertex_pos_modelspace[0] = projectedCoord[0];\\n  vertex_pos_modelspace[1] = projectedCoord[1];\\n  vertex_pos_modelspace[2] = heightsFP64;\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(pickingColors / 255., 1.);\\n\\n  vColor = mix(\\n    color,\\n    pickingColor,\\n    renderPickingBuffer\\n  );\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n',\n      fp64: true,\n      project64: true\n    };\n  };\n\n  ChoroplethLayer64.prototype.getModel = function getModel (gl) {\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n        drawMode: this.props.drawContour ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].TRIANGLES\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  };\n\n  ChoroplethLayer64.prototype.calculateIndices = function calculateIndices (attribute) {\n    var this$1 = this;\n\n    // adjust index offset for multiple choropleths\n    var offsets = this.state.choropleths.reduce(function (acc, choropleth) { return acc.concat( [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) { return count + polygon.length; }, 0)]); }, [0]);\n    var ref = this.state;\n    var IndexType = ref.IndexType;\n    if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {\n      throw new Error('Vertex count exceeds browser\\'s limit');\n    }\n\n    var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) { return this$1.props.drawContour ?\n    // 1. get sequentially ordered indices of each choropleth contour\n    // 2. offset them by the number of indices in previous choropleths\n    calculateContourIndices(choropleth).map(function (index) { return index + offsets[choroplethIndex]; }) :\n    // 1. get triangulated indices for the internal areas\n    // 2. offset them by the number of indices in previous choropleths\n    calculateSurfaceIndices(choropleth).map(function (index) { return index + offsets[choroplethIndex]; }); });\n\n    attribute.value = new IndexType(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(indices));\n    attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n    this.state.model.setVertexCount(attribute.value.length / attribute.size);\n  };\n\n  ChoroplethLayer64.prototype.calculatePositionsFP64 = function calculatePositionsFP64 (attribute) {\n    var vertices = __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(this.state.choropleths);\n    attribute.value = new Float32Array(vertices.length / 3 * 4);\n    for (var index = 0; index < vertices.length / 3; index++) {\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(vertices[index * 3]), attribute.value[index * 4] = assign[0], attribute.value[index * 4 + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(vertices[index * 3 + 1]), attribute.value[index * 4 + 2] = assign$1[0], attribute.value[index * 4 + 3] = assign$1[1]);\n    }\n  };\n\n  ChoroplethLayer64.prototype.calculateHeightsFP64 = function calculateHeightsFP64 (attribute) {\n    var vertices = __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(this.state.choropleths);\n    attribute.value = new Float32Array(vertices.length / 3 * 2);\n    for (var index = 0; index < vertices.length / 3; index++) {\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(vertices[index * 3 + 2]), attribute.value[index * 2] = assign[0], attribute.value[index * 2 + 1] = assign[1]);\n    }\n  };\n\n  ChoroplethLayer64.prototype.calculateColors = function calculateColors (attribute) {\n    var ref = this.props;\n    var features = ref.data.features;\n    var getColor = ref.getColor;\n\n    var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n      var feature = features[choropleth.featureIndex];\n      var color = getColor(feature) || DEFAULT_COLOR;\n\n      if (isNaN(color[3])) {\n        color[3] = DEFAULT_COLOR[3];\n      }\n\n      return choropleth.map(function (polygon) { return polygon.map(function (vertex) { return color; }); });\n    });\n\n    attribute.value = new Uint8Array(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(colors));\n  };\n\n  // Override the default picking colors calculation\n  ChoroplethLayer64.prototype.calculatePickingColors = function calculatePickingColors (attribute) {\n    var this$1 = this;\n\n\n    var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n      var featureIndex = choropleth.featureIndex;\n      var color = this$1.props.drawContour ? this$1.nullPickingColor() : this$1.encodePickingColor(featureIndex);\n      return choropleth.map(function (polygon) { return polygon.map(function (vertex) { return color; }); });\n    });\n\n    attribute.value = new Uint8Array(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(colors));\n  };\n\n  return ChoroplethLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ChoroplethLayer64;\n\nChoroplethLayer64.layerName = 'ChoroplethLayer64';\n\n/*\n * converts list of features from a GeoJSON object to a list of GeoJSON\n * polygon-style coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction extractChoropleths(data) {\n  var normalizedGeojson = __WEBPACK_IMPORTED_MODULE_5_geojson_normalize___default()(data);\n  var result = [];\n\n  normalizedGeojson.features.map(function (feature, featureIndex) {\n    var choropleths = featureToChoropleths(feature);\n    choropleths.forEach(function (choropleth) {\n      choropleth.featureIndex = featureIndex;\n    });\n    result.push.apply(result, choropleths);\n  });\n  return result;\n}\n\n/*\n * converts one GeoJSON features from object to a list of GeoJSON polygon-style\n * coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction featureToChoropleths(feature) {\n  var ref = feature.geometry;\n  var coordinates = ref.coordinates;\n  var type = ref.type;\n  var choropleths;\n\n  switch (type) {\n    case 'MultiPolygon':\n      choropleths = coordinates;\n      break;\n    case 'Polygon':\n      choropleths = [coordinates];\n      break;\n    case 'LineString':\n      // create a LineStringLayer for LineString and MultiLineString?\n      choropleths = [[coordinates]];\n      break;\n    case 'MultiLineString':\n      choropleths = coordinates.map(function (coords) { return [coords]; });\n      break;\n    default:\n      choropleths = [];\n  }\n  return choropleths.map(function (choropleth) { return choropleth.map(function (polygon) { return polygon.map(function (coordinate) { return [coordinate[0], coordinate[1], coordinate[2] || 0]; }); }); });\n}\n\n/*\n * get vertex indices for drawing choropleth contour\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateContourIndices(choropleth) {\n  var offset = 0;\n\n  return choropleth.reduce(function (acc, polygon) {\n    var numVertices = polygon.length;\n\n    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]\n    var indices = acc.concat( [offset]);\n    for (var i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n    indices.push(offset + numVertices - 1);\n\n    offset += numVertices;\n    return indices;\n  }, []);\n}\n\n/*\n * get vertex indices for drawing choropleth mesh\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateSurfaceIndices(choropleth) {\n  var holes = null;\n\n  if (choropleth.length > 1) {\n    holes = choropleth.reduce(function (acc, polygon) { return acc.concat( [acc[acc.length - 1] + polygon.length]); }, [0]).slice(1, choropleth.length);\n  }\n\n  return __WEBPACK_IMPORTED_MODULE_6_earcut___default()(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(choropleth), holes, 3);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2Nob3JvcGxldGgtbGF5ZXIvY2hvcm9wbGV0aC1sYXllci02NC5qcz9iZGE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5pbXBvcnQgbm9ybWFsaXplIGZyb20gJ2dlb2pzb24tbm9ybWFsaXplJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRDb2xvcjogZmVhdHVyZSA9PiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3IgfHwgREVGQVVMVF9DT0xPUixcbiAgZHJhd0NvdW50b3VyOiBmYWxzZSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENob3JvcGxldGhMYXllcjY0IGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGREeW5hbWljKHtcbiAgICAgIC8vIFByaW10aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGluZGljZXM6IHsgc2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIGlzSW5kZXhlZDogdHJ1ZSB9LFxuICAgICAgcG9zaXRpb25zRlA2NDogeyBzaXplOiA0LCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zRlA2NCB9LFxuICAgICAgaGVpZ2h0c0ZQNjQ6IHsgc2l6ZTogMiwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUhlaWdodHNGUDY0IH0sXG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc1xuICAgICAgfSxcbiAgICAgIC8vIEluc3RhbmNlZCBhdHRyaWJ1dGVzXG4gICAgICBwaWNraW5nQ29sb3JzOiB7IHNpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLCBub0FsbG9jOiB0cnVlIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IEluZGV4VHlwZSA9IGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpLFxuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgSW5kZXhUeXBlXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7IG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MgfSkge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlTWFuYWdlciB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMgPSBleHRyYWN0Q2hvcm9wbGV0aHMocHJvcHMuZGF0YSk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMub3BhY2l0eSAhPT0gcHJvcHMub3BhY2l0eSkge1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7IG9wYWNpdHk6IHByb3BzLm9wYWNpdHkgfSk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7IHVuaWZvcm1zIH0pIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy5zY3JlZW5Ub0RldmljZVBpeGVscyh0aGlzLnByb3BzLnN0cm9rZVdpZHRoKTtcbiAgICBnbC5saW5lV2lkdGgobGluZVdpZHRoKTtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgLy8gU2V0dGluZyBsaW5lIHdpZHRoIGJhY2sgdG8gMSBpcyBoZXJlIHRvIHdvcmthcm91bmQgYSBHb29nbGUgQ2hyb21lIGJ1Z1xuICAgIC8vIGdsLmNsZWFyKCkgYW5kIGdsLmlzRW5hYmxlZCgpIHdpbGwgcmV0dXJuIEdMX0lOVkFMSURfVkFMVUUgZXZlbiB3aXRoXG4gICAgLy8gY29ycmVjdCBwYXJhbWV0ZXJcbiAgICAvLyBUaGlzIGlzIG5vdCBoYXBwZW5pbmcgb24gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgZ2wubGluZVdpZHRoKDEuMCk7XG4gIH1cblxuICBwaWNrKG9wdHMpIHtcbiAgICBzdXBlci5waWNrKG9wdHMpO1xuICAgIGNvbnN0IHsgaW5mbyB9ID0gb3B0cztcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZGVjb2RlUGlja2luZ0NvbG9yKGluZm8uY29sb3IpO1xuICAgIGNvbnN0IGZlYXR1cmUgPSBpbmRleCA+PSAwID8gdGhpcy5wcm9wcy5kYXRhLmZlYXR1cmVzW2luZGV4XSA6IG51bGw7XG4gICAgaW5mby5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICBpbmZvLm9iamVjdCA9IGZlYXR1cmU7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBjaG9yb3BsZXRoLWxheWVyLTY0LXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbnNGUDY0O1xcbmF0dHJpYnV0ZSB2ZWMyIGhlaWdodHNGUDY0O1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcnM7XFxuYXR0cmlidXRlIHZlYzMgcGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZlYzQgZ2V0Q29sb3IodmVjNCBjb2xvciwgZmxvYXQgb3BhY2l0eSwgdmVjMyBwaWNraW5nQ29sb3IsIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXIpIHtcXG4gIHZlYzQgY29sb3I0ID0gdmVjNChjb2xvci54eXogLyAyNTUuLCBjb2xvci53IC8gMjU1LiAqIG9wYWNpdHkpO1xcbiAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IgLyAyNTUuLCAxLik7XFxuICByZXR1cm4gbWl4KGNvbG9yNCwgcGlja2luZ0NvbG9yNCwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBGb3Igc29tZSByZWFzb24sIG5lZWQgdG8gYWRkIG9uZSB0byBlbGV2YXRpb24gdG8gc2hvdyB1cCBpbiB1bnRpbHRlZCBtb2RlXFxuICB2ZWMyIHByb2plY3RlZENvb3JkWzJdO1xcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KHBvc2l0aW9uc0ZQNjQsIHByb2plY3RlZENvb3JkKTtcXG5cXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xcblxcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gcHJvamVjdGVkQ29vcmRbMF07XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBwcm9qZWN0ZWRDb29yZFsxXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IGhlaWdodHNGUDY0O1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcXG5cXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGNvbG9ycy5yZ2IsIGNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KHBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XFxuXFxuICB2Q29sb3IgPSBtaXgoXFxuICAgIGNvbG9yLFxcbiAgICBwaWNraW5nQ29sb3IsXFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcXG4gICk7XFxufVxcbicsXG4gICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBjaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbicsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IEdMLkxJTkVTIDogR0wuVFJJQU5HTEVTXG4gICAgICB9KSxcbiAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgaXNJbmRleGVkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbmRpY2VzKGF0dHJpYnV0ZSkge1xuICAgIC8vIGFkanVzdCBpbmRleCBvZmZzZXQgZm9yIG11bHRpcGxlIGNob3JvcGxldGhzXG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMucmVkdWNlKChhY2MsIGNob3JvcGxldGgpID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBjaG9yb3BsZXRoLnJlZHVjZSgoY291bnQsIHBvbHlnb24pID0+IGNvdW50ICsgcG9seWdvbi5sZW5ndGgsIDApXSwgWzBdKTtcbiAgICBjb25zdCB7IEluZGV4VHlwZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoSW5kZXhUeXBlID09PSBVaW50MTZBcnJheSAmJiBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV0gPiA2NTUzNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcCgoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB0aGlzLnByb3BzLmRyYXdDb250b3VyID9cbiAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGNob3JvcGxldGggY29udG91clxuICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKGNob3JvcGxldGgpLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldHNbY2hvcm9wbGV0aEluZGV4XSkgOlxuICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGNob3JvcGxldGhzXG4gICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY2hvcm9wbGV0aCkubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdKSk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgSW5kZXhUeXBlKGZsYXR0ZW5EZWVwKGluZGljZXMpKTtcbiAgICBhdHRyaWJ1dGUudGFyZ2V0ID0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUpO1xuICB9XG5cbiAgY2FsY3VsYXRlUG9zaXRpb25zRlA2NChhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGZsYXR0ZW5EZWVwKHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMpO1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMubGVuZ3RoIC8gMyAqIDQpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpbmRleCsrKSB7XG4gICAgICBbYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNF0sIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAxXV0gPSBmcDY0aWZ5KHZlcnRpY2VzW2luZGV4ICogM10pO1xuICAgICAgW2F0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAyXSwgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNCArIDNdXSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUhlaWdodHNGUDY0KGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGluZGV4KyspIHtcbiAgICAgIFthdHRyaWJ1dGUudmFsdWVbaW5kZXggKiAyXSwgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogMiArIDFdXSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzICsgMl0pO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGE6IHsgZmVhdHVyZXMgfSwgZ2V0Q29sb3IgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcCgoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbY2hvcm9wbGV0aC5mZWF0dXJlSW5kZXhdO1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihmZWF0dXJlKSB8fCBERUZBVUxUX0NPTE9SO1xuXG4gICAgICBpZiAoaXNOYU4oY29sb3JbM10pKSB7XG4gICAgICAgIGNvbG9yWzNdID0gREVGQVVMVF9DT0xPUlszXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKHBvbHlnb24gPT4gcG9seWdvbi5tYXAodmVydGV4ID0+IGNvbG9yKSk7XG4gICAgfSk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDhBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG4gIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlKSB7XG5cbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcCgoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGZlYXR1cmVJbmRleCB9ID0gY2hvcm9wbGV0aDtcbiAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IHRoaXMubnVsbFBpY2tpbmdDb2xvcigpIDogdGhpcy5lbmNvZGVQaWNraW5nQ29sb3IoZmVhdHVyZUluZGV4KTtcbiAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChwb2x5Z29uID0+IHBvbHlnb24ubWFwKHZlcnRleCA9PiBjb2xvcikpO1xuICAgIH0pO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG4gIH1cbn1cblxuQ2hvcm9wbGV0aExheWVyNjQubGF5ZXJOYW1lID0gJ0Nob3JvcGxldGhMYXllcjY0JztcblxuLypcbiAqIGNvbnZlcnRzIGxpc3Qgb2YgZmVhdHVyZXMgZnJvbSBhIEdlb0pTT04gb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OXG4gKiBwb2x5Z29uLXN0eWxlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGdlb2pzb24gb2JqZWN0XG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENob3JvcGxldGhzKGRhdGEpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEdlb2pzb24gPSBub3JtYWxpemUoZGF0YSk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzLm1hcCgoZmVhdHVyZSwgZmVhdHVyZUluZGV4KSA9PiB7XG4gICAgY29uc3QgY2hvcm9wbGV0aHMgPSBmZWF0dXJlVG9DaG9yb3BsZXRocyhmZWF0dXJlKTtcbiAgICBjaG9yb3BsZXRocy5mb3JFYWNoKGNob3JvcGxldGggPT4ge1xuICAgICAgY2hvcm9wbGV0aC5mZWF0dXJlSW5kZXggPSBmZWF0dXJlSW5kZXg7XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2goLi4uY2hvcm9wbGV0aHMpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIGNvbnZlcnRzIG9uZSBHZW9KU09OIGZlYXR1cmVzIGZyb20gb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OIHBvbHlnb24tc3R5bGVcbiAqIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGdlb2pzb24gb2JqZWN0XG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZVRvQ2hvcm9wbGV0aHMoZmVhdHVyZSkge1xuICBjb25zdCB7IGNvb3JkaW5hdGVzLCB0eXBlIH0gPSBmZWF0dXJlLmdlb21ldHJ5O1xuICBsZXQgY2hvcm9wbGV0aHM7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIGNob3JvcGxldGhzID0gY29vcmRpbmF0ZXM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgIGNob3JvcGxldGhzID0gW2Nvb3JkaW5hdGVzXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgLy8gY3JlYXRlIGEgTGluZVN0cmluZ0xheWVyIGZvciBMaW5lU3RyaW5nIGFuZCBNdWx0aUxpbmVTdHJpbmc/XG4gICAgICBjaG9yb3BsZXRocyA9IFtbY29vcmRpbmF0ZXNdXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICBjaG9yb3BsZXRocyA9IGNvb3JkaW5hdGVzLm1hcChjb29yZHMgPT4gW2Nvb3Jkc10pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNob3JvcGxldGhzID0gW107XG4gIH1cbiAgcmV0dXJuIGNob3JvcGxldGhzLm1hcChjaG9yb3BsZXRoID0+IGNob3JvcGxldGgubWFwKHBvbHlnb24gPT4gcG9seWdvbi5tYXAoY29vcmRpbmF0ZSA9PiBbY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSB8fCAwXSkpKTtcbn1cblxuLypcbiAqIGdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjaG9yb3BsZXRoIGNvbnRvdXJcbiAqIEBwYXJhbSB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW119IGNob3JvcGxldGhcbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyhjaG9yb3BsZXRoKSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIHJldHVybiBjaG9yb3BsZXRoLnJlZHVjZSgoYWNjLCBwb2x5Z29uKSA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIGdsLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMiwgbi0yLCBuLTFdXG4gICAgY29uc3QgaW5kaWNlcyA9IFsuLi5hY2MsIG9mZnNldF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0ICsgbnVtVmVydGljZXMgLSAxKTtcblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSwgW10pO1xufVxuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggbWVzaFxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgbGV0IGhvbGVzID0gbnVsbDtcblxuICBpZiAoY2hvcm9wbGV0aC5sZW5ndGggPiAxKSB7XG4gICAgaG9sZXMgPSBjaG9yb3BsZXRoLnJlZHVjZSgoYWNjLCBwb2x5Z29uKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdLCBbMF0pLnNsaWNlKDEsIGNob3JvcGxldGgubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBlYXJjdXQoZmxhdHRlbkRlZXAoY2hvcm9wbGV0aCksIGhvbGVzLCAzKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xheWVycy9mcDY0L2Nob3JvcGxldGgtbGF5ZXIvY2hvcm9wbGV0aC1sYXllci02NC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNUpBO0FBQ0E7QUEySkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 45 */
/* exports provided: default */
/* exports used: default */
/*!***********************************************************************************!*\
  !*** ./src/layers/fp64/extruded-choropleth-layer/extruded-choropleth-layer-64.js ***!
  \***********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(/*! earcut */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_gl_matrix__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [180, 180, 200];\nvar DEFAULT_AMBIENT_COLOR = [255, 255, 255];\nvar DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT = 0.1;\nvar DEFAULT_POINTLIGHT_LOCATION = [40.4406, -79.9959, 100];\nvar DEFAULT_POINTLIGHT_COLOR = [255, 255, 255];\nvar DEFAULT_POINTLIGHT_ATTENUATION = 1.0;\nvar DEFAULT_MATERIAL_SPECULAR_COLOR = [255, 255, 255];\nvar DEFAULT_MATERIAL_SHININESS = 1;\n\nvar defaultProps = {\n  opacity: 1,\n  elevation: 1\n};\n\nvar ExtrudedChoroplethLayer64 = (function (Layer) {\n  function ExtrudedChoroplethLayer64(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) ExtrudedChoroplethLayer64.__proto__ = Layer;\n  ExtrudedChoroplethLayer64.prototype = Object.create( Layer && Layer.prototype );\n  ExtrudedChoroplethLayer64.prototype.constructor = ExtrudedChoroplethLayer64;\n\n  ExtrudedChoroplethLayer64.prototype.initializeState = function initializeState () {\n    var ref = this.state;\n    var attributeManager = ref.attributeManager;\n    attributeManager.add({\n      indices: { size: 1, isIndexed: true, update: this.calculateIndices },\n      positions: { size: 4, update: this.calculatePositions },\n      heights: { size: 2, update: this.calculateHeights },\n      normals: { size: 3, update: this.calculateNormals },\n      colors: { size: 3, update: this.calculateColors }\n    });\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    this.setState({\n      numInstances: 0,\n      model: this.getModel(gl)\n    });\n  };\n\n  ExtrudedChoroplethLayer64.prototype.updateState = function updateState (ref) {\n    var changeFlags = ref.changeFlags;\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    if (changeFlags.dataChanged) {\n      this.extractExtrudedChoropleth();\n      attributeManager.invalidateAll();\n    }\n\n    var ref$2 = this.props;\n    var elevation = ref$2.elevation;\n    var color = ref$2.color;\n    var ambientColor = ref$2.ambientColor;\n    var pointLightColor = ref$2.pointLightColor;\n    var pointLightLocation = ref$2.pointLightLocation;\n    var pointLightAmbientCoefficient = ref$2.pointLightAmbientCoefficient;\n    var pointLightAttenuation = ref$2.pointLightAttenuation;\n    var materialSpecularColor = ref$2.materialSpecularColor;\n    var materialShininess = ref$2.materialShininess;\n\n    this.setUniforms({\n      elevation: Number.isFinite(elevation) ? elevation : 1,\n      colors: color || DEFAULT_COLOR,\n      uAmbientColor: ambientColor || DEFAULT_AMBIENT_COLOR,\n      uPointLightAmbientCoefficient: pointLightAmbientCoefficient || DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT,\n      uPointLightLocation: pointLightLocation || DEFAULT_POINTLIGHT_LOCATION,\n      uPointLightColor: pointLightColor || DEFAULT_POINTLIGHT_COLOR,\n      uPointLightAttenuation: pointLightAttenuation || DEFAULT_POINTLIGHT_ATTENUATION,\n      uMaterialSpecularColor: materialSpecularColor || DEFAULT_MATERIAL_SPECULAR_COLOR,\n      uMaterialShininess: materialShininess || DEFAULT_MATERIAL_SHININESS\n    });\n  };\n\n  ExtrudedChoroplethLayer64.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    this.state.model.render(uniforms);\n  };\n\n  ExtrudedChoroplethLayer64.prototype.pick = function pick (opts) {\n    Layer.prototype.pick.call(this, opts);\n    var info = opts.info;\n    var index = this.decodePickingColor(info.color);\n    var feature = index >= 0 ? this.props.data.features[index] : null;\n    info.feature = feature;\n    info.object = feature;\n  };\n\n  ExtrudedChoroplethLayer64.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME extruded-choropleths-layer-vertex-shader\\n\\nuniform float opacity;\\nuniform vec3 colors;\\nuniform float elevation;\\n\\nuniform vec3 uAmbientColor;\\nuniform float uPointLightAmbientCoefficient;\\nuniform vec3 uPointLightLocation;\\nuniform vec3 uPointLightColor;\\nuniform float uPointLightAttenuation;\\n\\nuniform vec3 uMaterialSpecularColor;\\nuniform float uMaterialShininess;\\n\\nattribute vec4 positions;\\nattribute vec2 heights;\\nattribute vec3 normals;\\n\\nvarying vec4 vColor;\\n\\nvec3 applyLighting(vec3 position_modelspace, vec3 normal_modelspace, vec3 color) {\\n\\n  vec3 pointLightLocation_modelspace = vec3(project_position(uPointLightLocation));\\n  vec3 lightDirection = normalize(pointLightLocation_modelspace - position_modelspace);\\n\\n  vec3 ambient = uPointLightAmbientCoefficient * color / 255.0 * uAmbientColor / 255.0;\\n\\n  float diffuseCoefficient = max(dot(normal_modelspace, lightDirection), 0.0);\\n  vec3 diffuse = diffuseCoefficient * uPointLightColor / 255. * color / 255.;\\n\\n  return ambient + uPointLightAttenuation * diffuse;\\n}\\n\\nvoid main(void) {\\n  vec2 projected_xy[2];\\n  project_position_fp64(positions, projected_xy);\\n  vec2 scaled_height = mul_fp64(heights, vec2(projectionPixelsPerUnit.x * elevation, 0.0));\\n\\n  vec2 vertex_pos_modelspace[4];\\n  vertex_pos_modelspace[0] = projected_xy[0];\\n  vertex_pos_modelspace[1] = projected_xy[1];\\n  vertex_pos_modelspace[2] = sum_fp64(scaled_height, vec2(1.0, 0.0));\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  vec3 color = applyLighting(\\n  \\tvec3(\\n  \\t  vertex_pos_modelspace[0].x,\\n  \\t  vertex_pos_modelspace[1].x,\\n  \\t  vertex_pos_modelspace[2].x),\\n  \\tnormals,\\n  \\tcolors\\n  );\\n  vColor = vec4(color, opacity);\\n}\\n// `;\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n/* fragment shader for the building-layer */\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n// `;\\n',\n      fp64: true,\n      project64: true\n    };\n  };\n\n  ExtrudedChoroplethLayer64.prototype.getModel = function getModel (gl) {\n    // Make sure we have 32 bit support\n    // TODO - this could be done automatically by luma in \"draw\"\n    // when it detects 32 bit indices\n    if (!gl.getExtension('OES_element_index_uint')) {\n      throw new Error('Extruded choropleth layer needs 32 bit indices');\n    }\n\n    // Buildings are 3d so depth test should be enabled\n    // TODO - it is a little heavy handed to have a layer set this\n    // Alternatively, check depth test and warn if not set, or add a prop\n    // setDepthTest that is on by default.\n    gl.enable(__WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].DEPTH_TEST);\n    gl.depthFunc(__WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LEQUAL);\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n        drawMode: this.props.drawWireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].TRIANGLES\n      }),\n      vertexCount: 0,\n      isIndexed: true\n    });\n  };\n\n  // each top vertex is on 3 surfaces\n  // each bottom vertex is on 2 surfaces\n  ExtrudedChoroplethLayer64.prototype.calculatePositions = function calculatePositions (attribute) {\n    var this$1 = this;\n\n    var ref = this.state;\n    var positions = ref.positions;\n    if (!positions) {\n      positions = __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(this.state.groupedVertices.map(function (vertices) {\n        var topVertices = Array.prototype.concat.apply([], vertices);\n        var baseVertices = topVertices.map(function (v) { return [v[0], v[1], 0]; });\n        return this$1.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n      }));\n    }\n\n    attribute.value = new Float32Array(positions.length / 3 * 4);\n\n    for (var i = 0; i < positions.length / 3; i++) {\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 0]), attribute.value[i * 4 + 0] = assign[0], attribute.value[i * 4 + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 1]), attribute.value[i * 4 + 2] = assign$1[0], attribute.value[i * 4 + 3] = assign$1[1]);\n    }\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateHeights = function calculateHeights (attribute) {\n    var this$1 = this;\n\n    var ref = this.state;\n    var positions = ref.positions;\n    if (!positions) {\n      positions = __WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(this.state.groupedVertices.map(function (vertices) {\n        var topVertices = Array.prototype.concat.apply([], vertices);\n        var baseVertices = topVertices.map(function (v) { return [v[0], v[1], 0]; });\n        return this$1.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n      }));\n    }\n\n    attribute.value = new Float32Array(positions.length / 3 * 2);\n    for (var i = 0; i < positions.length / 3; i++) {\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 2] + 0.1), attribute.value[i * 2 + 0] = assign[0], attribute.value[i * 2 + 1] = assign[1]);\n    }\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateNormals = function calculateNormals (attribute) {\n    var this$1 = this;\n\n    var up = [0, 1, 0];\n\n    var normals = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n      var topNormals = new Array(countVertices(vertices)).fill(up);\n      var sideNormals = vertices.map(function (polygon) { return this$1.calculateSideNormals(polygon); });\n      var sideNormalsForward = sideNormals.map(function (n) { return n[0]; });\n      var sideNormalsBackward = sideNormals.map(function (n) { return n[1]; });\n\n      return this$1.props.drawWireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];\n    });\n\n    attribute.value = new Float32Array(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(normals));\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateSideNormals = function calculateSideNormals (vertices) {\n    var numVertices = vertices.length;\n    var normals = [];\n\n    for (var i = 0; i < numVertices - 1; i++) {\n      var n = getNormal(vertices[i], vertices[i + 1]);\n      normals.push(n);\n    }\n\n    return [normals.concat( [normals[0]]), [normals[0] ].concat( normals)];\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateIndices = function calculateIndices (attribute) {\n    var this$1 = this;\n\n    // adjust index offset for multiple buildings\n    var multiplier = this.props.drawWireframe ? 2 : 5;\n    var offsets = this.state.groupedVertices.reduce(function (acc, vertices) { return acc.concat( [acc[acc.length - 1] + countVertices(vertices) * multiplier]); }, [0]);\n\n    var indices = this.state.groupedVertices.map(function (vertices, buildingIndex) { return this$1.props.drawWireframe ?\n    // 1. get sequentially ordered indices of each building wireframe\n    // 2. offset them by the number of indices in previous buildings\n    this$1.calculateContourIndices(vertices, offsets[buildingIndex]) :\n    // 1. get triangulated indices for the internal areas\n    // 2. offset them by the number of indices in previous buildings\n    this$1.calculateSurfaceIndices(vertices, offsets[buildingIndex]); });\n\n    attribute.value = new Uint32Array(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(indices));\n    attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n    this.state.model.setVertexCount(attribute.value.length / attribute.size);\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateColors = function calculateColors (attribute) {\n    var this$1 = this;\n\n    var colors = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n      var ref = this$1.props;\n      var color = ref.color;\n      var baseColor = Array.isArray(color) ? color[0] : color;\n      var topColor = Array.isArray(color) ? color[color.length - 1] : color;\n      var numVertices = countVertices(vertices);\n\n      var topColors = new Array(numVertices).fill(topColor);\n      var baseColors = new Array(numVertices).fill(baseColor);\n      return this$1.props.drawWireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n    });\n    attribute.value = new Float32Array(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(colors));\n  };\n\n  ExtrudedChoroplethLayer64.prototype.extractExtrudedChoropleth = function extractExtrudedChoropleth () {\n    var this$1 = this;\n\n    var ref = this.props;\n    var data = ref.data;\n    // Generate a flat list of buildings\n    this.state.buildings = [];\n    var loop = function () {\n      var building = list[i];\n\n      var properties = building.properties;\n      var geometry = building.geometry;\n      var coordinates = geometry.coordinates;\n      var type = geometry.type;\n      if (!properties.height) {\n        properties.height = Math.random() * 1000;\n      }\n      switch (type) {\n        case 'MultiPolygon':\n          // Maps to multiple buildings\n          var buildings = coordinates.map(function (coords) { return ({ coordinates: coords, properties: properties }); });\n          (ref$1 = this$1.state.buildings).push.apply(ref$1, buildings);\n          break;\n        case 'Polygon':\n          // Maps to a single building\n          this$1.state.buildings.push({ coordinates: coordinates, properties: properties });\n          break;\n        default:\n        // We are ignoring Points for now\n      }\n    };\n\n    for (var i = 0, list = data.features; i < list.length; i += 1) loop();\n\n    // Generate vertices for the building list\n    this.state.groupedVertices = this.state.buildings.map(function (building) { return building.coordinates.map(function (polygon) { return polygon.map(function (coordinate) { return [coordinate[0], coordinate[1], building.properties.height || 10]; }); }); });\n    var ref$1;\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateContourIndices = function calculateContourIndices (vertices, offset) {\n    var stride = countVertices(vertices);\n\n    return vertices.map(function (polygon) {\n      var indices = [offset];\n      var numVertices = polygon.length;\n\n      // building top\n      // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n      for (var i = 1; i < numVertices - 1; i++) {\n        indices.push(i + offset, i + offset);\n      }\n      indices.push(offset);\n\n      // building sides\n      for (var i$1 = 0; i$1 < numVertices - 1; i$1++) {\n        indices.push(i$1 + offset, i$1 + stride + offset);\n      }\n\n      offset += numVertices;\n      return indices;\n    });\n  };\n\n  ExtrudedChoroplethLayer64.prototype.calculateSurfaceIndices = function calculateSurfaceIndices (vertices, offset) {\n    var stride = countVertices(vertices);\n    var holes = null;\n    var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];\n\n    if (vertices.length > 1) {\n      holes = vertices.reduce(function (acc, polygon) { return acc.concat( [acc[acc.length - 1] + polygon.length]); }, [0]).slice(1, vertices.length);\n    }\n\n    var topIndices = __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__WEBPACK_IMPORTED_MODULE_4_lodash_flattendeep___default()(vertices), holes, 3).map(function (index) { return index + offset; });\n\n    var sideIndices = vertices.map(function (polygon) {\n      var numVertices = polygon.length;\n      // building top\n      var indices = [];\n\n      // building sides\n      for (var i = 0; i < numVertices - 1; i++) {\n        indices.push.apply(indices, drawRectangle(i));\n      }\n\n      offset += numVertices;\n      return indices;\n    });\n\n    return [topIndices, sideIndices];\n\n    function drawRectangle(i) {\n      return quad.map(function (v) { return i + v[0] + stride * v[1] + offset; });\n    }\n  };\n\n  return ExtrudedChoroplethLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = ExtrudedChoroplethLayer64;\n\nExtrudedChoroplethLayer64.layerName = 'ExtrudedChoroplethLayer64';\n\n/*\n * helpers\n */\n// get normal vector of line segment\nfunction getNormal(p1, p2) {\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    return [1, 0, 0];\n  }\n\n  var degrees2radians = Math.PI / 180;\n\n  var lon1 = degrees2radians * p1[0];\n  var lon2 = degrees2radians * p2[0];\n  var lat1 = degrees2radians * p1[1];\n  var lat2 = degrees2radians * p2[1];\n\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n  return __WEBPACK_IMPORTED_MODULE_6_gl_matrix__[\"vec3\"].normalize([], [b, 0, -a]);\n}\n\n// count number of vertices in geojson polygon\nfunction countVertices(vertices) {\n  return vertices.reduce(function (count, polygon) { return count + polygon.length; }, 0);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXIvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC5qcz8zMjkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzE4MCwgMTgwLCAyMDBdO1xuY29uc3QgREVGQVVMVF9BTUJJRU5UX0NPTE9SID0gWzI1NSwgMjU1LCAyNTVdO1xuY29uc3QgREVGQVVMVF9QT0lOVExJR0hUX0FNQklFTlRfQ09FRkZJQ0lFTlQgPSAwLjE7XG5jb25zdCBERUZBVUxUX1BPSU5UTElHSFRfTE9DQVRJT04gPSBbNDAuNDQwNiwgLTc5Ljk5NTksIDEwMF07XG5jb25zdCBERUZBVUxUX1BPSU5UTElHSFRfQ09MT1IgPSBbMjU1LCAyNTUsIDI1NV07XG5jb25zdCBERUZBVUxUX1BPSU5UTElHSFRfQVRURU5VQVRJT04gPSAxLjA7XG5jb25zdCBERUZBVUxUX01BVEVSSUFMX1NQRUNVTEFSX0NPTE9SID0gWzI1NSwgMjU1LCAyNTVdO1xuY29uc3QgREVGQVVMVF9NQVRFUklBTF9TSElOSU5FU1MgPSAxO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIG9wYWNpdHk6IDEsXG4gIGVsZXZhdGlvbjogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NCBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgIGluZGljZXM6IHsgc2l6ZTogMSwgaXNJbmRleGVkOiB0cnVlLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcyB9LFxuICAgICAgcG9zaXRpb25zOiB7IHNpemU6IDQsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnMgfSxcbiAgICAgIGhlaWdodHM6IHsgc2l6ZTogMiwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUhlaWdodHMgfSxcbiAgICAgIG5vcm1hbHM6IHsgc2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMgfSxcbiAgICAgIGNvbG9yczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlQ29sb3JzIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsKGdsKVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoeyBjaGFuZ2VGbGFncyB9KSB7XG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5leHRyYWN0RXh0cnVkZWRDaG9yb3BsZXRoKCk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBlbGV2YXRpb24sXG4gICAgICBjb2xvciwgYW1iaWVudENvbG9yLCBwb2ludExpZ2h0Q29sb3IsXG4gICAgICBwb2ludExpZ2h0TG9jYXRpb24sIHBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQsXG4gICAgICBwb2ludExpZ2h0QXR0ZW51YXRpb24sIG1hdGVyaWFsU3BlY3VsYXJDb2xvciwgbWF0ZXJpYWxTaGluaW5lc3NcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc2V0VW5pZm9ybXMoe1xuICAgICAgZWxldmF0aW9uOiBOdW1iZXIuaXNGaW5pdGUoZWxldmF0aW9uKSA/IGVsZXZhdGlvbiA6IDEsXG4gICAgICBjb2xvcnM6IGNvbG9yIHx8IERFRkFVTFRfQ09MT1IsXG4gICAgICB1QW1iaWVudENvbG9yOiBhbWJpZW50Q29sb3IgfHwgREVGQVVMVF9BTUJJRU5UX0NPTE9SLFxuICAgICAgdVBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQ6IHBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQgfHwgREVGQVVMVF9QT0lOVExJR0hUX0FNQklFTlRfQ09FRkZJQ0lFTlQsXG4gICAgICB1UG9pbnRMaWdodExvY2F0aW9uOiBwb2ludExpZ2h0TG9jYXRpb24gfHwgREVGQVVMVF9QT0lOVExJR0hUX0xPQ0FUSU9OLFxuICAgICAgdVBvaW50TGlnaHRDb2xvcjogcG9pbnRMaWdodENvbG9yIHx8IERFRkFVTFRfUE9JTlRMSUdIVF9DT0xPUixcbiAgICAgIHVQb2ludExpZ2h0QXR0ZW51YXRpb246IHBvaW50TGlnaHRBdHRlbnVhdGlvbiB8fCBERUZBVUxUX1BPSU5UTElHSFRfQVRURU5VQVRJT04sXG4gICAgICB1TWF0ZXJpYWxTcGVjdWxhckNvbG9yOiBtYXRlcmlhbFNwZWN1bGFyQ29sb3IgfHwgREVGQVVMVF9NQVRFUklBTF9TUEVDVUxBUl9DT0xPUixcbiAgICAgIHVNYXRlcmlhbFNoaW5pbmVzczogbWF0ZXJpYWxTaGluaW5lc3MgfHwgREVGQVVMVF9NQVRFUklBTF9TSElOSU5FU1NcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoeyB1bmlmb3JtcyB9KSB7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICB9XG5cbiAgcGljayhvcHRzKSB7XG4gICAgc3VwZXIucGljayhvcHRzKTtcbiAgICBjb25zdCB7IGluZm8gfSA9IG9wdHM7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihpbmZvLmNvbG9yKTtcbiAgICBjb25zdCBmZWF0dXJlID0gaW5kZXggPj0gMCA/IHRoaXMucHJvcHMuZGF0YS5mZWF0dXJlc1tpbmRleF0gOiBudWxsO1xuICAgIGluZm8uZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgaW5mby5vYmplY3QgPSBmZWF0dXJlO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgZXh0cnVkZWQtY2hvcm9wbGV0aHMtbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIHZlYzMgY29sb3JzO1xcbnVuaWZvcm0gZmxvYXQgZWxldmF0aW9uO1xcblxcbnVuaWZvcm0gdmVjMyB1QW1iaWVudENvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdVBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQ7XFxudW5pZm9ybSB2ZWMzIHVQb2ludExpZ2h0TG9jYXRpb247XFxudW5pZm9ybSB2ZWMzIHVQb2ludExpZ2h0Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1UG9pbnRMaWdodEF0dGVudWF0aW9uO1xcblxcbnVuaWZvcm0gdmVjMyB1TWF0ZXJpYWxTcGVjdWxhckNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdU1hdGVyaWFsU2hpbmluZXNzO1xcblxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMiBoZWlnaHRzO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52ZWMzIGFwcGx5TGlnaHRpbmcodmVjMyBwb3NpdGlvbl9tb2RlbHNwYWNlLCB2ZWMzIG5vcm1hbF9tb2RlbHNwYWNlLCB2ZWMzIGNvbG9yKSB7XFxuXFxuICB2ZWMzIHBvaW50TGlnaHRMb2NhdGlvbl9tb2RlbHNwYWNlID0gdmVjMyhwcm9qZWN0X3Bvc2l0aW9uKHVQb2ludExpZ2h0TG9jYXRpb24pKTtcXG4gIHZlYzMgbGlnaHREaXJlY3Rpb24gPSBub3JtYWxpemUocG9pbnRMaWdodExvY2F0aW9uX21vZGVsc3BhY2UgLSBwb3NpdGlvbl9tb2RlbHNwYWNlKTtcXG5cXG4gIHZlYzMgYW1iaWVudCA9IHVQb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50ICogY29sb3IgLyAyNTUuMCAqIHVBbWJpZW50Q29sb3IgLyAyNTUuMDtcXG5cXG4gIGZsb2F0IGRpZmZ1c2VDb2VmZmljaWVudCA9IG1heChkb3Qobm9ybWFsX21vZGVsc3BhY2UsIGxpZ2h0RGlyZWN0aW9uKSwgMC4wKTtcXG4gIHZlYzMgZGlmZnVzZSA9IGRpZmZ1c2VDb2VmZmljaWVudCAqIHVQb2ludExpZ2h0Q29sb3IgLyAyNTUuICogY29sb3IgLyAyNTUuO1xcblxcbiAgcmV0dXJuIGFtYmllbnQgKyB1UG9pbnRMaWdodEF0dGVudWF0aW9uICogZGlmZnVzZTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzIgcHJvamVjdGVkX3h5WzJdO1xcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KHBvc2l0aW9ucywgcHJvamVjdGVkX3h5KTtcXG4gIHZlYzIgc2NhbGVkX2hlaWdodCA9IG11bF9mcDY0KGhlaWdodHMsIHZlYzIocHJvamVjdGlvblBpeGVsc1BlclVuaXQueCAqIGVsZXZhdGlvbiwgMC4wKSk7XFxuXFxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHByb2plY3RlZF94eVswXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHByb2plY3RlZF94eVsxXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHN1bV9mcDY0KHNjYWxlZF9oZWlnaHQsIHZlYzIoMS4wLCAwLjApKTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICB2ZWMzIGNvbG9yID0gYXBwbHlMaWdodGluZyhcXG4gIFxcdHZlYzMoXFxuICBcXHQgIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXS54LFxcbiAgXFx0ICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0ueCxcXG4gIFxcdCAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngpLFxcbiAgXFx0bm9ybWFscyxcXG4gIFxcdGNvbG9yc1xcbiAgKTtcXG4gIHZDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbn1cXG4vLyBgO1xcbicsXG4gICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuLyogZnJhZ21lbnQgc2hhZGVyIGZvciB0aGUgYnVpbGRpbmctbGF5ZXIgKi9cXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xcbn1cXG4vLyBgO1xcbicsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGdldE1vZGVsKGdsKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgMzIgYml0IHN1cHBvcnRcbiAgICAvLyBUT0RPIC0gdGhpcyBjb3VsZCBiZSBkb25lIGF1dG9tYXRpY2FsbHkgYnkgbHVtYSBpbiBcImRyYXdcIlxuICAgIC8vIHdoZW4gaXQgZGV0ZWN0cyAzMiBiaXQgaW5kaWNlc1xuICAgIGlmICghZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXh0cnVkZWQgY2hvcm9wbGV0aCBsYXllciBuZWVkcyAzMiBiaXQgaW5kaWNlcycpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkaW5ncyBhcmUgM2Qgc28gZGVwdGggdGVzdCBzaG91bGQgYmUgZW5hYmxlZFxuICAgIC8vIFRPRE8gLSBpdCBpcyBhIGxpdHRsZSBoZWF2eSBoYW5kZWQgdG8gaGF2ZSBhIGxheWVyIHNldCB0aGlzXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgY2hlY2sgZGVwdGggdGVzdCBhbmQgd2FybiBpZiBub3Qgc2V0LCBvciBhZGQgYSBwcm9wXG4gICAgLy8gc2V0RGVwdGhUZXN0IHRoYXQgaXMgb24gYnkgZGVmYXVsdC5cbiAgICBnbC5lbmFibGUoR0wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGVwdGhGdW5jKEdMLkxFUVVBTCk7XG5cbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBHTC5MSU5FUyA6IEdMLlRSSUFOR0xFU1xuICAgICAgfSksXG4gICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgIGlzSW5kZXhlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZWFjaCB0b3AgdmVydGV4IGlzIG9uIDMgc3VyZmFjZXNcbiAgLy8gZWFjaCBib3R0b20gdmVydGV4IGlzIG9uIDIgc3VyZmFjZXNcbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGxldCB7IHBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIXBvc2l0aW9ucykge1xuICAgICAgcG9zaXRpb25zID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKHZlcnRpY2VzID0+IHtcbiAgICAgICAgY29uc3QgdG9wVmVydGljZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB2ZXJ0aWNlcyk7XG4gICAgICAgIGNvbnN0IGJhc2VWZXJ0aWNlcyA9IHRvcFZlcnRpY2VzLm1hcCh2ID0+IFt2WzBdLCB2WzFdLCAwXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBbdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlc10gOiBbdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzLCBiYXNlVmVydGljZXNdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zLmxlbmd0aCAvIDMgKiA0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgW2F0dHJpYnV0ZS52YWx1ZVtpICogNCArIDBdLCBhdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAxXV0gPSBmcDY0aWZ5KHBvc2l0aW9uc1tpICogMyArIDBdKTtcbiAgICAgIFthdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAyXSwgYXR0cmlidXRlLnZhbHVlW2kgKiA0ICsgM11dID0gZnA2NGlmeShwb3NpdGlvbnNbaSAqIDMgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSGVpZ2h0cyhhdHRyaWJ1dGUpIHtcbiAgICBsZXQgeyBwb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFwb3NpdGlvbnMpIHtcbiAgICAgIHBvc2l0aW9ucyA9IGZsYXR0ZW5EZWVwKHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLm1hcCh2ZXJ0aWNlcyA9PiB7XG4gICAgICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdmVydGljZXMpO1xuICAgICAgICBjb25zdCBiYXNlVmVydGljZXMgPSB0b3BWZXJ0aWNlcy5tYXAodiA9PiBbdlswXSwgdlsxXSwgMF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kcmF3V2lyZWZyYW1lID8gW3RvcFZlcnRpY2VzLCBiYXNlVmVydGljZXNdIDogW3RvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICBbYXR0cmlidXRlLnZhbHVlW2kgKiAyICsgMF0sIGF0dHJpYnV0ZS52YWx1ZVtpICogMiArIDFdXSA9IGZwNjRpZnkocG9zaXRpb25zW2kgKiAzICsgMl0gKyAwLjEpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZU5vcm1hbHMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgdXAgPSBbMCwgMSwgMF07XG5cbiAgICBjb25zdCBub3JtYWxzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkgPT4ge1xuICAgICAgY29uc3QgdG9wTm9ybWFscyA9IG5ldyBBcnJheShjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSkuZmlsbCh1cCk7XG4gICAgICBjb25zdCBzaWRlTm9ybWFscyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHRoaXMuY2FsY3VsYXRlU2lkZU5vcm1hbHMocG9seWdvbikpO1xuICAgICAgY29uc3Qgc2lkZU5vcm1hbHNGb3J3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblswXSk7XG4gICAgICBjb25zdCBzaWRlTm9ybWFsc0JhY2t3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblsxXSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBbdG9wTm9ybWFscywgdG9wTm9ybWFsc10gOiBbdG9wTm9ybWFscywgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmRdO1xuICAgIH0pO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShmbGF0dGVuRGVlcChub3JtYWxzKSk7XG4gIH1cblxuICBjYWxjdWxhdGVTaWRlTm9ybWFscyh2ZXJ0aWNlcykge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IG4gPSBnZXROb3JtYWwodmVydGljZXNbaV0sIHZlcnRpY2VzW2kgKyAxXSk7XG4gICAgICBub3JtYWxzLnB1c2gobik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtbLi4ubm9ybWFscywgbm9ybWFsc1swXV0sIFtub3JtYWxzWzBdLCAuLi5ub3JtYWxzXV07XG4gIH1cblxuICBjYWxjdWxhdGVJbmRpY2VzKGF0dHJpYnV0ZSkge1xuICAgIC8vIGFkanVzdCBpbmRleCBvZmZzZXQgZm9yIG11bHRpcGxlIGJ1aWxkaW5nc1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyAyIDogNTtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMucmVkdWNlKChhY2MsIHZlcnRpY2VzKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykgKiBtdWx0aXBsaWVyXSwgWzBdKTtcblxuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5tYXAoKHZlcnRpY2VzLCBidWlsZGluZ0luZGV4KSA9PiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgP1xuICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggYnVpbGRpbmcgd2lyZWZyYW1lXG4gICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGJ1aWxkaW5nc1xuICAgIHRoaXMuY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldHNbYnVpbGRpbmdJbmRleF0pIDpcbiAgICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBidWlsZGluZ3NcbiAgICB0aGlzLmNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW2J1aWxkaW5nSW5kZXhdKSk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDMyQXJyYXkoZmxhdHRlbkRlZXAoaW5kaWNlcykpO1xuICAgIGF0dHJpYnV0ZS50YXJnZXQgPSBHTC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFZlcnRleENvdW50KGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSk7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGJhc2VDb2xvciA9IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3JbMF0gOiBjb2xvcjtcbiAgICAgIGNvbnN0IHRvcENvbG9yID0gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvcltjb2xvci5sZW5ndGggLSAxXSA6IGNvbG9yO1xuICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICAgICAgY29uc3QgdG9wQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKHRvcENvbG9yKTtcbiAgICAgIGNvbnN0IGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoYmFzZUNvbG9yKTtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmRyYXdXaXJlZnJhbWUgPyBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6IFt0b3BDb2xvcnMsIHRvcENvbG9ycywgdG9wQ29sb3JzLCBiYXNlQ29sb3JzLCBiYXNlQ29sb3JzXTtcbiAgICB9KTtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xuICB9XG5cbiAgZXh0cmFjdEV4dHJ1ZGVkQ2hvcm9wbGV0aCgpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXMucHJvcHM7XG4gICAgLy8gR2VuZXJhdGUgYSBmbGF0IGxpc3Qgb2YgYnVpbGRpbmdzXG4gICAgdGhpcy5zdGF0ZS5idWlsZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ1aWxkaW5nIG9mIGRhdGEuZmVhdHVyZXMpIHtcbiAgICAgIGNvbnN0IHsgcHJvcGVydGllcywgZ2VvbWV0cnkgfSA9IGJ1aWxkaW5nO1xuICAgICAgY29uc3QgeyBjb29yZGluYXRlcywgdHlwZSB9ID0gZ2VvbWV0cnk7XG4gICAgICBpZiAoIXByb3BlcnRpZXMuaGVpZ2h0KSB7XG4gICAgICAgIHByb3BlcnRpZXMuaGVpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAvLyBNYXBzIHRvIG11bHRpcGxlIGJ1aWxkaW5nc1xuICAgICAgICAgIGNvbnN0IGJ1aWxkaW5ncyA9IGNvb3JkaW5hdGVzLm1hcChjb29yZHMgPT4gKHsgY29vcmRpbmF0ZXM6IGNvb3JkcywgcHJvcGVydGllcyB9KSk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5idWlsZGluZ3MucHVzaCguLi5idWlsZGluZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAvLyBNYXBzIHRvIGEgc2luZ2xlIGJ1aWxkaW5nXG4gICAgICAgICAgdGhpcy5zdGF0ZS5idWlsZGluZ3MucHVzaCh7IGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBXZSBhcmUgaWdub3JpbmcgUG9pbnRzIGZvciBub3dcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSB2ZXJ0aWNlcyBmb3IgdGhlIGJ1aWxkaW5nIGxpc3RcbiAgICB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcyA9IHRoaXMuc3RhdGUuYnVpbGRpbmdzLm1hcChidWlsZGluZyA9PiBidWlsZGluZy5jb29yZGluYXRlcy5tYXAocG9seWdvbiA9PiBwb2x5Z29uLm1hcChjb29yZGluYXRlID0+IFtjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBidWlsZGluZy5wcm9wZXJ0aWVzLmhlaWdodCB8fCAxMF0pKSk7XG4gIH1cblxuICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgICByZXR1cm4gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFtvZmZzZXRdO1xuICAgICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBHTC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTEsIG4tMSwgMF1cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaW5kaWNlcy5wdXNoKG9mZnNldCk7XG5cbiAgICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgc3RyaWRlICsgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gICAgbGV0IGhvbGVzID0gbnVsbDtcbiAgICBjb25zdCBxdWFkID0gW1swLCAxXSwgWzAsIDNdLCBbMSwgMl0sIFsxLCAyXSwgWzAsIDNdLCBbMSwgNF1dO1xuXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGhvbGVzID0gdmVydGljZXMucmVkdWNlKChhY2MsIHBvbHlnb24pID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aF0sIFswXSkuc2xpY2UoMSwgdmVydGljZXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3BJbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW5EZWVwKHZlcnRpY2VzKSwgaG9sZXMsIDMpLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldCk7XG5cbiAgICBjb25zdCBzaWRlSW5kaWNlcyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHtcbiAgICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG4gICAgICAvLyBidWlsZGluZyB0b3BcbiAgICAgIGNvbnN0IGluZGljZXMgPSBbXTtcblxuICAgICAgLy8gYnVpbGRpbmcgc2lkZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKC4uLmRyYXdSZWN0YW5nbGUoaSkpO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9KTtcblxuICAgIHJldHVybiBbdG9wSW5kaWNlcywgc2lkZUluZGljZXNdO1xuXG4gICAgZnVuY3Rpb24gZHJhd1JlY3RhbmdsZShpKSB7XG4gICAgICByZXR1cm4gcXVhZC5tYXAodiA9PiBpICsgdlswXSArIHN0cmlkZSAqIHZbMV0gKyBvZmZzZXQpO1xuICAgIH1cbiAgfVxufVxuXG5FeHRydWRlZENob3JvcGxldGhMYXllcjY0LmxheWVyTmFtZSA9ICdFeHRydWRlZENob3JvcGxldGhMYXllcjY0JztcblxuLypcbiAqIGhlbHBlcnNcbiAqL1xuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIGlmIChwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwXTtcbiAgfVxuXG4gIGNvbnN0IGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5cbiAgY29uc3QgbG9uMSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxWzBdO1xuICBjb25zdCBsb24yID0gZGVncmVlczJyYWRpYW5zICogcDJbMF07XG4gIGNvbnN0IGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMVsxXTtcbiAgY29uc3QgbGF0MiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyWzFdO1xuXG4gIGNvbnN0IGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgY29uc3QgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLSBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuXG4gIHJldHVybiB2ZWMzLm5vcm1hbGl6ZShbXSwgW2IsIDAsIC1hXSk7XG59XG5cbi8vIGNvdW50IG51bWJlciBvZiB2ZXJ0aWNlcyBpbiBnZW9qc29uIHBvbHlnb25cbmZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGljZXMpIHtcbiAgcmV0dXJuIHZlcnRpY2VzLnJlZHVjZSgoY291bnQsIHBvbHlnb24pID0+IGNvdW50ICsgcG9seWdvbi5sZW5ndGgsIDApO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2ZwNjQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBcEJBO0FBQ0E7O0FBcUJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeFJBO0FBQ0E7QUF1UkE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 46 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************!*\
  !*** ./src/layers/fp64/line-layer/line-layer-64.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_path__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 255, 0, 255];\n\nvar defaultGetSourcePosition = function (x) { return x.sourcePosition; };\nvar defaultGetTargetPosition = function (x) { return x.targetPosition; };\nvar defaultGetColor = function (x) { return x.color || DEFAULT_COLOR; };\n\nvar defaultProps = {\n  getSourcePosition: defaultGetSourcePosition,\n  getTargetPosition: defaultGetTargetPosition,\n  getColor: defaultGetColor,\n  strokeWidth: 1\n};\n\nvar LineLayer64 = (function (Layer) {\n  function LineLayer64(props) {\n    Layer.call(this, Object.assign({}, defaultProps, props));\n  }\n\n  if ( Layer ) LineLayer64.__proto__ = Layer;\n  LineLayer64.prototype = Object.create( Layer && Layer.prototype );\n  LineLayer64.prototype.constructor = LineLayer64;\n\n  LineLayer64.prototype.initializeState = function initializeState () {\n    var ref = this.context;\n    var gl = ref.gl;\n    this.setState({ model: this.createModel(gl) });\n\n    var ref$1 = this.state;\n    var attributeManager = ref$1.attributeManager;\n    attributeManager.addInstanced({\n      instanceSourcePositionsFP64: {\n        size: 4,\n        update: this.calculateInstanceSourcePositions\n      },\n      instanceTargetPositionsFP64: {\n        size: 4,\n        update: this.calculateInstanceTargetPositions\n      },\n      instanceElevations: {\n        size: 2,\n        update: this.calculateInstanceElevations\n      },\n      instanceColors: {\n        size: 4,\n        type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n        update: this.calculateInstanceColors\n      }\n    });\n  };\n\n  LineLayer64.prototype.draw = function draw (ref) {\n    var uniforms = ref.uniforms;\n\n    var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n    gl.lineWidth(lineWidth);\n    this.state.model.render(uniforms);\n    // Setting line width back to 1 is here to workaround a Google Chrome bug\n    // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n    // correct parameter\n    // This is not happening on Safari and Firefox\n    gl.lineWidth(1.0);\n  };\n\n  LineLayer64.prototype.getShaders = function getShaders () {\n    return {\n      vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME line-layer-64-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourcePositionsFP64;\\nattribute vec4 instanceTargetPositionsFP64;\\nattribute vec2 instanceElevations;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  // Position\\n  vec2 projectedSourceCoord[2];\\n  project_position_fp64(instanceSourcePositionsFP64, projectedSourceCoord);\\n  vec2 projectedTargetCoord[2];\\n  project_position_fp64(instanceTargetPositionsFP64, projectedTargetCoord);\\n\\n  // linear interpolation of source & target to pick right coord\\n  float segmentIndex = positions.x;\\n  vec2 mixed_temp[2];\\n\\n  vec2_mix_fp64(projectedSourceCoord, projectedTargetCoord, segmentIndex, mixed_temp);\\n\\n  float mixedElevation =\\n    mix(instanceElevations.x, instanceElevations.y, segmentIndex);\\n\\n  vec2 vertex_pos_modelspace[4];\\n\\n  vertex_pos_modelspace[0] = mixed_temp[0];\\n  vertex_pos_modelspace[1] = mixed_temp[1];\\n  vertex_pos_modelspace[2] = vec2(project_scale(mixedElevation), 0.0);\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  // Color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n\\n  vColor = mix(\\n    color,\\n    pickingColor,\\n    renderPickingBuffer\\n  );\\n}\\n',\n      fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME line-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n',\n      fp64: true,\n      project64: true\n    };\n  };\n\n  LineLayer64.prototype.createModel = function createModel (gl) {\n    var positions = [0, 0, 0, 1, 1, 1];\n\n    var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\" /* assembleShaders */])(gl, this.getShaders());\n\n    return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n      gl: gl,\n      id: this.props.id,\n      vs: shaders.vs,\n      fs: shaders.fs,\n      geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n        drawMode: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINE_STRIP,\n        positions: new Float32Array(positions)\n      }),\n      isInstanced: true\n    });\n  };\n\n  LineLayer64.prototype.calculateInstanceSourcePositions = function calculateInstanceSourcePositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourcePosition = ref.getSourcePosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var sourcePosition = getSourcePosition(object);\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[0]), value[i + 0] = assign[0], value[i + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[1]), value[i + 2] = assign$1[0], value[i + 3] = assign$1[1]);\n      i += size;\n    }\n  };\n\n  LineLayer64.prototype.calculateInstanceTargetPositions = function calculateInstanceTargetPositions (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getTargetPosition = ref.getTargetPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var targetPosition = getTargetPosition(object);\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[0]), value[i + 0] = assign[0], value[i + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[1]), value[i + 2] = assign$1[0], value[i + 3] = assign$1[1]);\n      i += size;\n    }\n  };\n\n  LineLayer64.prototype.calculateInstanceElevations = function calculateInstanceElevations (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getSourcePosition = ref.getSourcePosition;\n    var getTargetPosition = ref.getTargetPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var sourcePosition = getSourcePosition(object);\n      var targetPosition = getTargetPosition(object);\n      value[i + 0] = sourcePosition[2] || 0;\n      value[i + 1] = targetPosition[2] || 0;\n      i += size;\n    }\n  };\n\n  LineLayer64.prototype.calculateInstanceColors = function calculateInstanceColors (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getColor = ref.getColor;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var object = list[i$1];\n\n      var color = getColor(object);\n      value[i + 0] = color[0];\n      value[i + 1] = color[1];\n      value[i + 2] = color[2];\n      value[i + 3] = isNaN(color[3]) ? DEFAULT_COLOR[3] : color[3];\n      i += size;\n    }\n  };\n\n  return LineLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* Layer */]));\n\n/* harmony default export */ exports[\"a\"] = LineLayer64;\n\nLineLayer64.layerName = 'LineLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L2xpbmUtbGF5ZXIvbGluZS1sYXllci02NC5qcz81MTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMjU1LCAwLCAyNTVdO1xuXG5jb25zdCBkZWZhdWx0R2V0U291cmNlUG9zaXRpb24gPSB4ID0+IHguc291cmNlUG9zaXRpb247XG5jb25zdCBkZWZhdWx0R2V0VGFyZ2V0UG9zaXRpb24gPSB4ID0+IHgudGFyZ2V0UG9zaXRpb247XG5jb25zdCBkZWZhdWx0R2V0Q29sb3IgPSB4ID0+IHguY29sb3IgfHwgREVGQVVMVF9DT0xPUjtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRTb3VyY2VQb3NpdGlvbjogZGVmYXVsdEdldFNvdXJjZVBvc2l0aW9uLFxuICBnZXRUYXJnZXRQb3NpdGlvbjogZGVmYXVsdEdldFRhcmdldFBvc2l0aW9uLFxuICBnZXRDb2xvcjogZGVmYXVsdEdldENvbG9yLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUxheWVyNjQgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcykpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWw6IHRoaXMuY3JlYXRlTW9kZWwoZ2wpIH0pO1xuXG4gICAgY29uc3QgeyBhdHRyaWJ1dGVNYW5hZ2VyIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlU291cmNlUG9zaXRpb25zRlA2NDoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnNcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVRhcmdldFBvc2l0aW9uc0ZQNjQ6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0UG9zaXRpb25zXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VFbGV2YXRpb25zOiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUVsZXZhdGlvbnNcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZUNvbG9yczoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoeyB1bmlmb3JtcyB9KSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMuc2NyZWVuVG9EZXZpY2VQaXhlbHModGhpcy5wcm9wcy5zdHJva2VXaWR0aCk7XG4gICAgZ2wubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIC8vIFNldHRpbmcgbGluZSB3aWR0aCBiYWNrIHRvIDEgaXMgaGVyZSB0byB3b3JrYXJvdW5kIGEgR29vZ2xlIENocm9tZSBidWdcbiAgICAvLyBnbC5jbGVhcigpIGFuZCBnbC5pc0VuYWJsZWQoKSB3aWxsIHJldHVybiBHTF9JTlZBTElEX1ZBTFVFIGV2ZW4gd2l0aFxuICAgIC8vIGNvcnJlY3QgcGFyYW1ldGVyXG4gICAgLy8gVGhpcyBpcyBub3QgaGFwcGVuaW5nIG9uIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgIGdsLmxpbmVXaWR0aCgxLjApO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgbGluZS1sYXllci02NC12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU291cmNlUG9zaXRpb25zRlA2NDtcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVRhcmdldFBvc2l0aW9uc0ZQNjQ7XFxuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VFbGV2YXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIFBvc2l0aW9uXFxuICB2ZWMyIHByb2plY3RlZFNvdXJjZUNvb3JkWzJdO1xcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KGluc3RhbmNlU291cmNlUG9zaXRpb25zRlA2NCwgcHJvamVjdGVkU291cmNlQ29vcmQpO1xcbiAgdmVjMiBwcm9qZWN0ZWRUYXJnZXRDb29yZFsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVRhcmdldFBvc2l0aW9uc0ZQNjQsIHByb2plY3RlZFRhcmdldENvb3JkKTtcXG5cXG4gIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9mIHNvdXJjZSAmIHRhcmdldCB0byBwaWNrIHJpZ2h0IGNvb3JkXFxuICBmbG9hdCBzZWdtZW50SW5kZXggPSBwb3NpdGlvbnMueDtcXG4gIHZlYzIgbWl4ZWRfdGVtcFsyXTtcXG5cXG4gIHZlYzJfbWl4X2ZwNjQocHJvamVjdGVkU291cmNlQ29vcmQsIHByb2plY3RlZFRhcmdldENvb3JkLCBzZWdtZW50SW5kZXgsIG1peGVkX3RlbXApO1xcblxcbiAgZmxvYXQgbWl4ZWRFbGV2YXRpb24gPVxcbiAgICBtaXgoaW5zdGFuY2VFbGV2YXRpb25zLngsIGluc3RhbmNlRWxldmF0aW9ucy55LCBzZWdtZW50SW5kZXgpO1xcblxcbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XFxuXFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBtaXhlZF90ZW1wWzBdO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gbWl4ZWRfdGVtcFsxXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocHJvamVjdF9zY2FsZShtaXhlZEVsZXZhdGlvbiksIDAuMCk7XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcXG5cXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xcblxcbiAgLy8gQ29sb3JcXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XFxuXFxuICB2Q29sb3IgPSBtaXgoXFxuICAgIGNvbG9yLFxcbiAgICBwaWNraW5nQ29sb3IsXFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcXG4gICk7XFxufVxcbicsXG4gICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBsaW5lLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbicsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZU1vZGVsKGdsKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWzAsIDAsIDAsIDEsIDEsIDFdO1xuXG4gICAgY29uc3Qgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICBnbCxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogR0wuTElORV9TVFJJUCxcbiAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgZ2V0U291cmNlUG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICBbdmFsdWVbaSArIDBdLCB2YWx1ZVtpICsgMV1dID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblswXSk7XG4gICAgICBbdmFsdWVbaSArIDJdLCB2YWx1ZVtpICsgM11dID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblsxXSk7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRUYXJnZXRQb3NpdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgIFt2YWx1ZVtpICsgMF0sIHZhbHVlW2kgKyAxXV0gPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzBdKTtcbiAgICAgIFt2YWx1ZVtpICsgMl0sIHZhbHVlW2kgKyAzXV0gPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzFdKTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUVsZXZhdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRTb3VyY2VQb3NpdGlvbiwgZ2V0VGFyZ2V0UG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2YWx1ZSwgc2l6ZSB9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGdldFRhcmdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICB2YWx1ZVtpICsgMF0gPSBzb3VyY2VQb3NpdGlvblsyXSB8fCAwO1xuICAgICAgdmFsdWVbaSArIDFdID0gdGFyZ2V0UG9zaXRpb25bMl0gfHwgMDtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIGdldENvbG9yIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdmFsdWUsIHNpemUgfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihvYmplY3QpO1xuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gREVGQVVMVF9DT0xPUlszXSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5MaW5lTGF5ZXI2NC5sYXllck5hbWUgPSAnTGluZUxheWVyNjQnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2ZwNjQvbGluZS1sYXllci9saW5lLWxheWVyLTY0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeEhBO0FBQ0E7QUF1SEE7QUFDQTs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 47 */
/* exports provided: default */
/* exports used: default */
/*!*******************************************************************!*\
  !*** ./src/layers/fp64/scatterplot-layer/scatterplot-layer-64.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_scatterplot_layer__ = __webpack_require__(/*! ../../core/scatterplot-layer */ 17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_path__);\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\nvar ScatterplotLayer64 = (function (ScatterplotLayer) {\n  function ScatterplotLayer64 () {\n    ScatterplotLayer.apply(this, arguments);\n  }\n\n  if ( ScatterplotLayer ) ScatterplotLayer64.__proto__ = ScatterplotLayer;\n  ScatterplotLayer64.prototype = Object.create( ScatterplotLayer && ScatterplotLayer.prototype );\n  ScatterplotLayer64.prototype.constructor = ScatterplotLayer64;\n\n  ScatterplotLayer64.prototype.getShaders = function getShaders (id) {\n    return {\n      vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-64-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec4 instancePositions64xy;\\nattribute vec2 instancePositions64z;\\nattribute float instanceRadius;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\n// Only one-dimensional arrays may be declared in GLSL ES 1.0. specs p.24\\nuniform float opacity;\\nuniform float radius;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  // Multiply out radius and clamp to limits\\n  float radiusPixels = clamp(\\n    project_scale(radius * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n\\n  vec2 projected_coord_xy[2];\\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\\n\\n  vec2 vertex_pos_localspace[4];\\n  vec4_fp64(vec4(positions * radiusPixels, 0.0), vertex_pos_localspace);\\n\\n  vec2 vertex_pos_modelspace[4];\\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2], vec2(instancePositions64z.x + 1.0, instancePositions64z.y));\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n}\\n',\n      fs: ScatterplotLayer.prototype.getShaders.call(this).fs,\n      fp64: true,\n      project64: true\n    };\n  };\n\n  ScatterplotLayer64.prototype.initializeState = function initializeState () {\n    // We use the model and all attributes except \"instancePositions\" of the base layer\n    ScatterplotLayer.prototype.initializeState.call(this);\n\n    // Add the 64 bit positions\n    var ref = this.state;\n    var attributeManager = ref.attributeManager;\n    attributeManager.addInstanced({\n      instancePositions64xy: { size: 4, update: this.calculateInstancePositions64xy },\n      instancePositions64z: { size: 2, update: this.calculateInstancePositions64z }\n      // Reusing from base class\n      // instanceRadius: {size: 1, update: this.calculateInstanceRadius},\n      // instanceColors: {size: 4, type: GL.UNSIGNED_BYTE, update: this.calculateInstanceColors}\n    });\n  };\n\n  ScatterplotLayer64.prototype.calculateInstancePositions64xy = function calculateInstancePositions64xy (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getPosition = ref.getPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var point = list[i$1];\n\n      var position = getPosition(point);\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0]), value[i + 0] = assign[0], value[i + 1] = assign[1]);\n      var assign$1;\n      (assign$1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1]), value[i + 2] = assign$1[0], value[i + 3] = assign$1[1]);\n      i += size;\n    }\n  };\n\n  ScatterplotLayer64.prototype.calculateInstancePositions64z = function calculateInstancePositions64z (attribute) {\n    var ref = this.props;\n    var data = ref.data;\n    var getPosition = ref.getPosition;\n    var value = attribute.value;\n    var size = attribute.size;\n    var i = 0;\n    for (var i$1 = 0, list = data; i$1 < list.length; i$1 += 1) {\n      var point = list[i$1];\n\n      var position = getPosition(point);\n      var assign;\n      (assign = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(position[2] || 0), value[i + 0] = assign[0], value[i + 1] = assign[1]);\n      i += size;\n    }\n  };\n\n  return ScatterplotLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__core_scatterplot_layer__[\"a\" /* default */]));\n\n/* harmony default export */ exports[\"a\"] = ScatterplotLayer64;\n\nScatterplotLayer64.layerName = 'ScatterplotLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xheWVycy9mcDY0L3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLTY0LmpzP2Y3MjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IFNjYXR0ZXJwbG90TGF5ZXIgZnJvbSAnLi4vLi4vY29yZS9zY2F0dGVycGxvdC1sYXllcic7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJwbG90TGF5ZXI2NCBleHRlbmRzIFNjYXR0ZXJwbG90TGF5ZXIge1xuXG4gIC8vIE92ZXJyaWRlIHRoZSBzdXBlciBjbGFzcyB2ZXJ0ZXggc2hhZGVyXG4gIGdldFNoYWRlcnMoaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItNjQtdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5cXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVBvc2l0aW9uczY0eHk7XFxuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VQb3NpdGlvbnM2NHo7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG4vLyBPbmx5IG9uZS1kaW1lbnNpb25hbCBhcnJheXMgbWF5IGJlIGRlY2xhcmVkIGluIEdMU0wgRVMgMS4wLiBzcGVjcyBwLjI0XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBNdWx0aXBseSBvdXQgcmFkaXVzIGFuZCBjbGFtcCB0byBsaW1pdHNcXG4gIGZsb2F0IHJhZGl1c1BpeGVscyA9IGNsYW1wKFxcbiAgICBwcm9qZWN0X3NjYWxlKHJhZGl1cyAqIGluc3RhbmNlUmFkaXVzKSxcXG4gICAgcmFkaXVzTWluUGl4ZWxzLCByYWRpdXNNYXhQaXhlbHNcXG4gICk7XFxuXFxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVBvc2l0aW9uczY0eHksIHByb2plY3RlZF9jb29yZF94eSk7XFxuXFxuICB2ZWMyIHZlcnRleF9wb3NfbG9jYWxzcGFjZVs0XTtcXG4gIHZlYzRfZnA2NCh2ZWM0KHBvc2l0aW9ucyAqIHJhZGl1c1BpeGVscywgMC4wKSwgdmVydGV4X3Bvc19sb2NhbHNwYWNlKTtcXG5cXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzBdLCBwcm9qZWN0ZWRfY29vcmRfeHlbMF0pO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzFdLCBwcm9qZWN0ZWRfY29vcmRfeHlbMV0pO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzJdLCB2ZWMyKGluc3RhbmNlUG9zaXRpb25zNjR6LnggKyAxLjAsIGluc3RhbmNlUG9zaXRpb25zNjR6LnkpKTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICAvLyBBcHBseSBvcGFjaXR5IHRvIGluc3RhbmNlIGNvbG9yLCBvciByZXR1cm4gaW5zdGFuY2UgcGlja2luZyBjb2xvclxcbiAgdmVjNCBjb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcXG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcXG59XFxuJyxcbiAgICAgIGZzOiBzdXBlci5nZXRTaGFkZXJzKCkuZnMsXG4gICAgICBmcDY0OiB0cnVlLFxuICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAvLyBXZSB1c2UgdGhlIG1vZGVsIGFuZCBhbGwgYXR0cmlidXRlcyBleGNlcHQgXCJpbnN0YW5jZVBvc2l0aW9uc1wiIG9mIHRoZSBiYXNlIGxheWVyXG4gICAgc3VwZXIuaW5pdGlhbGl6ZVN0YXRlKCk7XG5cbiAgICAvLyBBZGQgdGhlIDY0IGJpdCBwb3NpdGlvbnNcbiAgICBjb25zdCB7IGF0dHJpYnV0ZU1hbmFnZXIgfSA9IHRoaXMuc3RhdGU7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM2NHh5OiB7IHNpemU6IDQsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHkgfSxcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR6OiB7IHNpemU6IDIsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eiB9XG4gICAgICAvLyBSZXVzaW5nIGZyb20gYmFzZSBjbGFzc1xuICAgICAgLy8gaW5zdGFuY2VSYWRpdXM6IHtzaXplOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VSYWRpdXN9LFxuICAgICAgLy8gaW5zdGFuY2VDb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnN9XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHkoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRQb3NpdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICBbdmFsdWVbaSArIDBdLCB2YWx1ZVtpICsgMV1dID0gZnA2NGlmeShwb3NpdGlvblswXSk7XG4gICAgICBbdmFsdWVbaSArIDJdLCB2YWx1ZVtpICsgM11dID0gZnA2NGlmeShwb3NpdGlvblsxXSk7XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHooYXR0cmlidXRlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRQb3NpdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBzaXplIH0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG4gICAgICBbdmFsdWVbaSArIDBdLCB2YWx1ZVtpICsgMV1dID0gZnA2NGlmeShwb3NpdGlvblsyXSB8fCAwKTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuU2NhdHRlcnBsb3RMYXllcjY0LmxheWVyTmFtZSA9ICdTY2F0dGVycGxvdExheWVyNjQnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF5ZXJzL2ZwNjQvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItNjQuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBakRBO0FBQ0E7QUFnREE7QUFDQTs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 48 */
/* exports provided: drawLayers, pickLayers */
/* exports used: drawLayers, pickLayers */
/*!**********************************!*\
  !*** ./src/lib/draw-and-pick.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__ = __webpack_require__(/*! ./viewport-uniforms */ 53);\n/* harmony export (immutable) */ exports[\"a\"] = drawLayers;\n/* harmony export (immutable) */ exports[\"b\"] = pickLayers;\n/* global window */\n\n\n\nfunction drawLayers(ref) {\n  var layers = ref.layers;\n\n  var layerIndex = 0;\n  for (var i = 0, list = layers; i < list.length; i += 1) {\n    var layer = list[i];\n\n    if (layer.props.visible) {\n      layer.drawLayer({\n        uniforms: Object.assign({}, layer.context.uniforms, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__[\"a\" /* getUniformsFromViewport */])(layer.context.viewport, layer.props), { layerIndex: layerIndex })\n      });\n      layerIndex++;\n    }\n  }\n}\n\n/* eslint-disable max-depth, max-statements */\nfunction pickLayers(gl, ref) {\n  var layers = ref.layers;\n  var pickingFBO = ref.pickingFBO;\n  var uniforms = ref.uniforms; if ( uniforms === void 0 ) uniforms = {};\n  var x = ref.x;\n  var y = ref.y;\n  var mode = ref.mode;\n\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n  var deviceX = x * pixelRatio;\n  var deviceY = gl.canvas.height - y * pixelRatio;\n\n  // TODO - just return glContextWithState once luma updates\n  var pickedInfos = [];\n\n  // Make sure we clear scissor test and fbo bindings in case of exceptions\n  // We are only interested in one pixel, no need to render anything else\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glContextWithState\"])(gl, {\n    frameBuffer: pickingFBO,\n    framebuffer: pickingFBO,\n    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }\n  }, function () {\n\n    var layerIndex = 0;\n    var zOrder = 0;\n\n    for (var i = layers.length - 1; i >= 0; --i) {\n      var layer = layers[i];\n\n      if (layer.props.visible) {\n        layerIndex++;\n      }\n\n      if (layer.props.visible && layer.props.pickable) {\n\n        // Clear the frame buffer, render and sample\n        gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n        var info = createInfo({\n          layer: layer,\n          pixel: [x, y],\n          devicePixel: [deviceX, deviceY],\n          pixelRatio: pixelRatio\n        });\n\n        layer.pickLayer({\n          info: info,\n          uniforms: Object.assign({}, layer.context.uniforms, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__[\"a\" /* getUniformsFromViewport */])(layer.context.viewport, layer.props), { layerIndex: layerIndex }),\n          pickEnableUniforms: { renderPickingBuffer: 1, pickingEnabled: 1 },\n          pickDisableUniforms: { renderPickingBuffer: 0, pickingEnabled: 0 },\n          deviceX: deviceX, deviceY: deviceY,\n          mode: mode\n        });\n\n        if (info.index >= 0) {\n          info.picked = true;\n          info.zOrder = zOrder++;\n          // If props.data is an indexable array, get the object\n          if (Array.isArray(layer.props.data)) {\n            info.object = layer.props.data[info.index];\n          }\n        }\n\n        pickedInfos.push(info);\n      }\n    }\n  });\n\n  // Calling callbacks can have async interactions with React\n  // which nullifies layer.state.\n  var unhandledPickInfos = [];\n  for (var i = 0, list = pickedInfos; i < list.length; i += 1) {\n    var info = list[i];\n\n    var handled = null;\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);break;\n      case 'hover':\n        handled = info.layer.props.onHover(info);break;\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  }\n\n  return unhandledPickInfos;\n}\n/* eslint-enable max-depth, max-statements */\n\nfunction createInfo(ref) {\n  var info = ref.info;\n  var layer = ref.layer;\n  var pixel = ref.pixel;\n  var devicePixel = ref.devicePixel;\n  var pixelRatio = ref.pixelRatio;\n\n  // Assign a number of potentially useful props to the \"info\" object\n  return {\n    layer: layer,\n    index: -1,\n    picked: false,\n    x: pixel[0],\n    y: pixel[1],\n    pixel: pixel,\n    devicePixel: devicePixel,\n    pixelRatio: pixelRatio,\n    lngLat: layer.unproject(pixel)\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9kcmF3LWFuZC1waWNrLmpzP2RkNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHsgR0wsIGdsQ29udGV4dFdpdGhTdGF0ZSB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHsgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQgfSBmcm9tICcuL3ZpZXdwb3J0LXVuaWZvcm1zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoeyBsYXllcnMgfSkge1xuICBsZXQgbGF5ZXJJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJzKSB7XG4gICAgaWYgKGxheWVyLnByb3BzLnZpc2libGUpIHtcbiAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBsYXllci5jb250ZXh0LnVuaWZvcm1zLCBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksIHsgbGF5ZXJJbmRleCB9KVxuICAgICAgfSk7XG4gICAgICBsYXllckluZGV4Kys7XG4gICAgfVxuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrTGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgdW5pZm9ybXMgPSB7fSxcbiAgeCxcbiAgeSxcbiAgbW9kZVxufSkge1xuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgZGV2aWNlWCA9IHggKiBwaXhlbFJhdGlvO1xuICBjb25zdCBkZXZpY2VZID0gZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvO1xuXG4gIC8vIFRPRE8gLSBqdXN0IHJldHVybiBnbENvbnRleHRXaXRoU3RhdGUgb25jZSBsdW1hIHVwZGF0ZXNcbiAgY29uc3QgcGlja2VkSW5mb3MgPSBbXTtcblxuICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgc2Npc3NvciB0ZXN0IGFuZCBmYm8gYmluZGluZ3MgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb25lIHBpeGVsLCBubyBuZWVkIHRvIHJlbmRlciBhbnl0aGluZyBlbHNlXG4gIGdsQ29udGV4dFdpdGhTdGF0ZShnbCwge1xuICAgIGZyYW1lQnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIGZyYW1lYnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIHNjaXNzb3JUZXN0OiB7IHg6IGRldmljZVgsIHk6IGRldmljZVksIHc6IDEsIGg6IDEgfVxuICB9LCAoKSA9PiB7XG5cbiAgICBsZXQgbGF5ZXJJbmRleCA9IDA7XG4gICAgbGV0IHpPcmRlciA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgaWYgKGxheWVyLnByb3BzLnZpc2libGUpIHtcbiAgICAgICAgbGF5ZXJJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSAmJiBsYXllci5wcm9wcy5waWNrYWJsZSkge1xuXG4gICAgICAgIC8vIENsZWFyIHRoZSBmcmFtZSBidWZmZXIsIHJlbmRlciBhbmQgc2FtcGxlXG4gICAgICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGNyZWF0ZUluZm8oe1xuICAgICAgICAgIGxheWVyLFxuICAgICAgICAgIHBpeGVsOiBbeCwgeV0sXG4gICAgICAgICAgZGV2aWNlUGl4ZWw6IFtkZXZpY2VYLCBkZXZpY2VZXSxcbiAgICAgICAgICBwaXhlbFJhdGlvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheWVyLnBpY2tMYXllcih7XG4gICAgICAgICAgaW5mbyxcbiAgICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXIuY29udGV4dC51bmlmb3JtcywgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQobGF5ZXIuY29udGV4dC52aWV3cG9ydCwgbGF5ZXIucHJvcHMpLCB7IGxheWVySW5kZXggfSksXG4gICAgICAgICAgcGlja0VuYWJsZVVuaWZvcm1zOiB7IHJlbmRlclBpY2tpbmdCdWZmZXI6IDEsIHBpY2tpbmdFbmFibGVkOiAxIH0sXG4gICAgICAgICAgcGlja0Rpc2FibGVVbmlmb3JtczogeyByZW5kZXJQaWNraW5nQnVmZmVyOiAwLCBwaWNraW5nRW5hYmxlZDogMCB9LFxuICAgICAgICAgIGRldmljZVgsIGRldmljZVksXG4gICAgICAgICAgbW9kZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5mby5pbmRleCA+PSAwKSB7XG4gICAgICAgICAgaW5mby5waWNrZWQgPSB0cnVlO1xuICAgICAgICAgIGluZm8uek9yZGVyID0gek9yZGVyKys7XG4gICAgICAgICAgLy8gSWYgcHJvcHMuZGF0YSBpcyBhbiBpbmRleGFibGUgYXJyYXksIGdldCB0aGUgb2JqZWN0XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXIucHJvcHMuZGF0YSkpIHtcbiAgICAgICAgICAgIGluZm8ub2JqZWN0ID0gbGF5ZXIucHJvcHMuZGF0YVtpbmZvLmluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwaWNrZWRJbmZvcy5wdXNoKGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ2FsbGluZyBjYWxsYmFja3MgY2FuIGhhdmUgYXN5bmMgaW50ZXJhY3Rpb25zIHdpdGggUmVhY3RcbiAgLy8gd2hpY2ggbnVsbGlmaWVzIGxheWVyLnN0YXRlLlxuICBjb25zdCB1bmhhbmRsZWRQaWNrSW5mb3MgPSBbXTtcbiAgZm9yIChjb25zdCBpbmZvIG9mIHBpY2tlZEluZm9zKSB7XG4gICAgbGV0IGhhbmRsZWQgPSBudWxsO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkNsaWNrKGluZm8pO2JyZWFrO1xuICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkhvdmVyKGluZm8pO2JyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgIH1cblxuICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHtcbiAgaW5mbyxcbiAgbGF5ZXIsXG4gIHBpeGVsLFxuICBkZXZpY2VQaXhlbCxcbiAgcGl4ZWxSYXRpb1xufSkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBsYXllcixcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBkZXZpY2VQaXhlbCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIGxuZ0xhdDogbGF5ZXIudW5wcm9qZWN0KHBpeGVsKVxuICB9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL2RyYXctYW5kLXBpY2suanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 49 */
/* unknown exports provided */
/*!*************************!*\
  !*** ./src/lib/init.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__package_json__ = __webpack_require__(/*! ../../package.json */ 63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__package_json__);\n// Version detection\n\n\nvar STARTUP_MESSAGE = 'set deck.log.priority=2 to trace attribute updates';\n\n/* global console */\n/* eslint-disable no-console */\nconsole.log((\"deck.gl \" + __WEBPACK_IMPORTED_MODULE_0__package_json__[\"version\"] + \" - \" + STARTUP_MESSAGE));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9pbml0LmpzPzI3OGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVmVyc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuXG5jb25zdCBTVEFSVFVQX01FU1NBR0UgPSAnc2V0IGRlY2subG9nLnByaW9yaXR5PTIgdG8gdHJhY2UgYXR0cmlidXRlIHVwZGF0ZXMnO1xuXG4vKiBnbG9iYWwgY29uc29sZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuY29uc29sZS5sb2coYGRlY2suZ2wgJHsgdmVyc2lvbiB9IC0gJHsgU1RBUlRVUF9NRVNTQUdFIH1gKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi9pbml0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 50 */
/* exports provided: default */
/* exports used: default */
/*!**********************************!*\
  !*** ./src/lib/layer-manager.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(/*! ./layer */ 20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(/*! ./utils */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(/*! assert */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__draw_and_pick__ = __webpack_require__(/*! ./draw-and-pick */ 48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__viewports__ = __webpack_require__(/*! ./viewports */ 13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_luma_gl__);\n\n// IMLEMENTATION NOTES: Why new layers are created on every render\n//\n// The key here is to understand the declarative / functional\n// programming nature of \"reactive\" applications.\n//\n// - In a reactive application, the entire \"UI tree\"\n//   is re-rendered every time something in the application changes.\n//\n// - The UI framework (such as React or deck.gl) then diffs the rendered\n//   tree of UI elements (React Elements or deck.gl Layers) against the\n//   previously tree and makes optimized changes (to the DOM or to WebGL state).\n//\n// - Deck.gl layers are not based on React.\n//   But it should be possible to wrap deck.gl layers in React components to\n//   enable use of JSX.\n//\n// The deck.gl model that for the app creates a new set of on layers on every\n// render.\n// Internally, the new layers are efficiently matched against existing layers\n// using layer ids.\n//\n// All calculated state (programs, attributes etc) are stored in a state object\n// and this state object is moved forward to the match layer on every render\n// cycle.  The new layer ends up with the state of the old layer (and the\n// props of the new layer), while the old layer is simply discarded for\n// garbage collecion.\n//\n/* eslint-disable no-try-catch */\n\n\n\n\n// import {Viewport} from 'viewport-mercator-project';\n\n\n\n\nvar LayerManager = function LayerManager(ref) {\n  var gl = ref.gl;\n\n  this.prevLayers = [];\n  this.layers = [];\n  // Tracks if any layers were drawn last update\n  // Needed to ensure that screen is cleared when no layers are shown\n  this.drewLayers = false;\n  this.oldContext = {};\n  this.context = {\n    gl: gl,\n    uniforms: {},\n    viewport: null,\n    viewportChanged: true,\n    pickingFBO: null\n  };\n  this.redrawNeeded = true;\n  Object.seal(this.context);\n};\n\nLayerManager.prototype.setViewport = function setViewport (viewport) {\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(viewport instanceof __WEBPACK_IMPORTED_MODULE_4__viewports__[\"b\" /* Viewport */], 'Invalid viewport');\n\n  // TODO - viewport change detection breaks METER_OFFSETS mode\n  // const oldViewport = this.context.viewport;\n  // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n  var viewportChanged = true;\n\n  if (viewportChanged) {\n    Object.assign(this.oldContext, this.context);\n    this.context.viewport = viewport;\n    this.context.viewportChanged = true;\n    this.context.uniforms = {};\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(4, viewport);\n  }\n\n  return this;\n};\n\nLayerManager.prototype.updateLayers = function updateLayers (ref) {\n    var this$1 = this;\n    var newLayers = ref.newLayers;\n\n  /* eslint-disable */\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.updateLayers: viewport not set');\n\n  // Filter out any null layers\n  newLayers = newLayers.filter(function (newLayer) { return newLayer !== null; });\n\n  for (var i = 0, list = newLayers; i < list.length; i += 1) {\n    var layer = list[i];\n\n      layer.context = this$1.context;\n  }\n\n  this.prevLayers = this.layers;\n  var ref$1 = this._updateLayers({\n    oldLayers: this.prevLayers,\n    newLayers: newLayers\n  });\n    var error = ref$1.error;\n    var generatedLayers = ref$1.generatedLayers;\n\n  this.layers = generatedLayers;\n  // Throw first error found, if any\n  if (error) {\n    throw error;\n  }\n  return this;\n};\n\nLayerManager.prototype.drawLayers = function drawLayers$1 () {\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.drawLayers: viewport not set');\n\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__[\"a\" /* drawLayers */])({ layers: this.layers });\n\n  return this;\n};\n\nLayerManager.prototype.pickLayer = function pickLayer (ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var mode = ref.mode;\n\n  var ref$1 = this.context;\n    var gl = ref$1.gl;\n    var uniforms = ref$1.uniforms;\n\n  // Set up a frame buffer if needed\n  if (this.context.pickingFBO === null || gl.canvas.width !== this.context.pickingFBO.width || gl.canvas.height !== this.context.pickingFBO.height) {\n    this.context.pickingFBO = new __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"FramebufferObject\"](gl, {\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n  }\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__[\"b\" /* pickLayers */])(gl, {\n    x: x,\n    y: y,\n    uniforms: {\n      renderPickingBuffer: true,\n      picking_uEnable: true\n    },\n    layers: this.layers,\n    mode: mode,\n    pickingFBO: this.context.pickingFBO\n  });\n};\n\nLayerManager.prototype.needsRedraw = function needsRedraw (ref) {\n    var this$1 = this;\n    if ( ref === void 0 ) ref = {};\n    var clearRedrawFlags = ref.clearRedrawFlags; if ( clearRedrawFlags === void 0 ) clearRedrawFlags = false;\n\n  if (!this.context.viewport) {\n    return false;\n  }\n\n  var redraw = false;\n\n  // Make sure that buffer is cleared once when layer list becomes empty\n  if (this.layers.length === 0 && this.drewLayers) {\n    redraw = true;\n    return true;\n  }\n\n  if (this.redrawNeeded) {\n    this.redrawNeeded = false;\n    redraw = true;\n  }\n\n  for (var i = 0, list = this$1.layers; i < list.length; i += 1) {\n    var layer = list[i];\n\n      redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });\n    this$1.drewLayers = true;\n  }\n  return redraw;\n};\n\n// PRIVATE METHODS\n\n// Match all layers, checking for caught errors\n// To avoid having an exception in one layer disrupt other layers\nLayerManager.prototype._updateLayers = function _updateLayers (ref) {\n    var oldLayers = ref.oldLayers;\n    var newLayers = ref.newLayers;\n\n  // Create old layer map\n  var oldLayerMap = {};\n  for (var i = 0, list = oldLayers; i < list.length; i += 1) {\n    var oldLayer = list[i];\n\n      if (oldLayerMap[oldLayer.id]) {\n      __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, (\"Multipe old layers with same id \" + (layerName(oldLayer))));\n    } else {\n      oldLayerMap[oldLayer.id] = oldLayer;\n    }\n  }\n\n  // Allocate array for generated layers\n  var generatedLayers = [];\n\n  // Match sublayers\n  var error = this._matchSublayers({\n    newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers\n  });\n\n  var error2 = this._finalizeOldLayers(oldLayers);\n  var firstError = error || error2;\n  return { error: firstError, generatedLayers: generatedLayers };\n};\n\n/* eslint-disable max-statements */\nLayerManager.prototype._matchSublayers = function _matchSublayers (ref) {\n    var this$1 = this;\n    var newLayers = ref.newLayers;\n    var oldLayerMap = ref.oldLayerMap;\n    var generatedLayers = ref.generatedLayers;\n\n  // Filter out any null layers\n  newLayers = newLayers.filter(function (newLayer) { return newLayer !== null; });\n\n  var error = null;\n  for (var i = 0, list = newLayers; i < list.length; i += 1) {\n    var newLayer = list[i];\n\n      newLayer.context = this$1.context;\n\n    try {\n      // 1. given a new coming layer, find its matching layer\n      var oldLayer = oldLayerMap[newLayer.id];\n      oldLayerMap[newLayer.id] = null;\n\n      if (oldLayer === null) {\n        __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, (\"Multipe new layers with same id \" + (layerName(newLayer))));\n      }\n\n      // Only transfer state at this stage. We must not generate exceptions\n      // until all layers' state have been transferred\n      if (oldLayer) {\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(3, (\"matched \" + (layerName(newLayer))), oldLayer, '=>', newLayer);\n        this$1._transferLayerState(oldLayer, newLayer);\n        this$1._updateLayer(newLayer);\n      } else {\n        this$1._initializeNewLayer(newLayer);\n      }\n      generatedLayers.push(newLayer);\n\n      // Call layer lifecycle method: render sublayers\n      var sublayers = newLayer.renderLayers();\n      // End layer lifecycle method: render sublayers\n\n      if (sublayers) {\n        sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];\n        this$1._matchSublayers({\n          newLayers: sublayers,\n          oldLayerMap: oldLayerMap,\n          generatedLayers: generatedLayers\n        });\n      }\n    } catch (err) {\n      __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, (\"deck.gl error during matching of \" + (layerName(newLayer)) + \" \" + err), err);\n      // Save first error\n      error = error || err;\n    }\n  }\n  return error;\n};\n\nLayerManager.prototype._transferLayerState = function _transferLayerState (oldLayer, newLayer) {\n  var state = oldLayer.state;\n    var props = oldLayer.props;\n\n  // sanity check\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(state, 'deck.gl sanity check - Matching layer has no state');\n  __WEBPACK_IMPORTED_MODULE_2_assert___default()(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');\n\n  // Move state\n  newLayer.state = state;\n  state.layer = newLayer;\n\n  // Update model layer reference\n  if (state.model) {\n    state.model.userData.layer = newLayer;\n  }\n  // Keep a temporary ref to the old props, for prop comparison\n  newLayer.oldProps = props;\n  oldLayer.state = null;\n};\n\n// Update the old layers that were not matched\nLayerManager.prototype._finalizeOldLayers = function _finalizeOldLayers (oldLayers) {\n    var this$1 = this;\n\n  var error = null;\n  // Unmatched layers still have state, it will be discarded\n  for (var i = 0, list = oldLayers; i < list.length; i += 1) {\n    var layer = list[i];\n\n      if (layer.state) {\n      error = error || this$1._finalizeLayer(layer);\n    }\n  }\n  return error;\n};\n\n// Initializes a single layer, calling layer methods\nLayerManager.prototype._initializeNewLayer = function _initializeNewLayer (layer) {\n  var error = null;\n  // Check if new layer, and initialize it's state\n  if (!layer.state) {\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(1, (\"initializing \" + (layerName(layer))));\n    try {\n      layer.initializeLayer({\n        oldProps: {},\n        props: layer.props,\n        oldContext: this.oldContext,\n        context: this.context,\n        changeFlags: layer.diffProps({}, layer.props, this.context)\n      });\n    } catch (err) {\n      __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, (\"deck.gl error during initialization of \" + (layerName(layer)) + \" \" + err), err);\n      // Save first error\n      error = error || err;\n    }\n    // Set back pointer (used in picking)\n    if (layer.state) {\n      layer.state.layer = layer;\n      // Save layer on model for picking purposes\n      // TODO - store on model.userData rather than directly on model\n    }\n    if (layer.state && layer.state.model) {\n      layer.state.model.userData.layer = layer;\n    }\n  }\n  return error;\n};\n\n// Updates a single layer, calling layer methods\nLayerManager.prototype._updateLayer = function _updateLayer (layer) {\n  var oldProps = layer.oldProps;\n    var props = layer.props;\n  var error = null;\n  if (oldProps) {\n    try {\n      layer.updateLayer({\n        oldProps: oldProps,\n        props: props,\n        context: this.context,\n        oldContext: this.oldContext,\n        changeFlags: layer.diffProps(oldProps, layer.props, this.context)\n      });\n    } catch (err) {\n      __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, (\"deck.gl error during update of \" + (layerName(layer))), err);\n      // Save first error\n      error = err;\n    }\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(2, (\"updating \" + (layerName(layer))));\n  }\n  return error;\n};\n\n// Finalizes a single layer\nLayerManager.prototype._finalizeLayer = function _finalizeLayer (layer) {\n  var error = null;\n  var state = layer.state;\n  if (state) {\n    try {\n      layer.finalizeLayer();\n    } catch (err) {\n      __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, (\"deck.gl error during finalization of \" + (layerName(layer))), err);\n      // Save first error\n      error = err;\n    }\n    layer.state = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(1, (\"finalizing \" + (layerName(layer))));\n  }\n  return error;\n};\n\n/* harmony default export */ exports[\"a\"] = LayerManager;\n\nfunction layerName(layer) {\n  if (layer instanceof __WEBPACK_IMPORTED_MODULE_0__layer__[\"a\" /* default */]) {\n    return (\"\" + layer);\n  }\n  return !layer ? 'null layer' : 'invalid layer';\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9sYXllci1tYW5hZ2VyLmpzPzg3OWMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBJTUxFTUVOVEFUSU9OIE5PVEVTOiBXaHkgbmV3IGxheWVycyBhcmUgY3JlYXRlZCBvbiBldmVyeSByZW5kZXJcbi8vXG4vLyBUaGUga2V5IGhlcmUgaXMgdG8gdW5kZXJzdGFuZCB0aGUgZGVjbGFyYXRpdmUgLyBmdW5jdGlvbmFsXG4vLyBwcm9ncmFtbWluZyBuYXR1cmUgb2YgXCJyZWFjdGl2ZVwiIGFwcGxpY2F0aW9ucy5cbi8vXG4vLyAtIEluIGEgcmVhY3RpdmUgYXBwbGljYXRpb24sIHRoZSBlbnRpcmUgXCJVSSB0cmVlXCJcbi8vICAgaXMgcmUtcmVuZGVyZWQgZXZlcnkgdGltZSBzb21ldGhpbmcgaW4gdGhlIGFwcGxpY2F0aW9uIGNoYW5nZXMuXG4vL1xuLy8gLSBUaGUgVUkgZnJhbWV3b3JrIChzdWNoIGFzIFJlYWN0IG9yIGRlY2suZ2wpIHRoZW4gZGlmZnMgdGhlIHJlbmRlcmVkXG4vLyAgIHRyZWUgb2YgVUkgZWxlbWVudHMgKFJlYWN0IEVsZW1lbnRzIG9yIGRlY2suZ2wgTGF5ZXJzKSBhZ2FpbnN0IHRoZVxuLy8gICBwcmV2aW91c2x5IHRyZWUgYW5kIG1ha2VzIG9wdGltaXplZCBjaGFuZ2VzICh0byB0aGUgRE9NIG9yIHRvIFdlYkdMIHN0YXRlKS5cbi8vXG4vLyAtIERlY2suZ2wgbGF5ZXJzIGFyZSBub3QgYmFzZWQgb24gUmVhY3QuXG4vLyAgIEJ1dCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gd3JhcCBkZWNrLmdsIGxheWVycyBpbiBSZWFjdCBjb21wb25lbnRzIHRvXG4vLyAgIGVuYWJsZSB1c2Ugb2YgSlNYLlxuLy9cbi8vIFRoZSBkZWNrLmdsIG1vZGVsIHRoYXQgZm9yIHRoZSBhcHAgY3JlYXRlcyBhIG5ldyBzZXQgb2Ygb24gbGF5ZXJzIG9uIGV2ZXJ5XG4vLyByZW5kZXIuXG4vLyBJbnRlcm5hbGx5LCB0aGUgbmV3IGxheWVycyBhcmUgZWZmaWNpZW50bHkgbWF0Y2hlZCBhZ2FpbnN0IGV4aXN0aW5nIGxheWVyc1xuLy8gdXNpbmcgbGF5ZXIgaWRzLlxuLy9cbi8vIEFsbCBjYWxjdWxhdGVkIHN0YXRlIChwcm9ncmFtcywgYXR0cmlidXRlcyBldGMpIGFyZSBzdG9yZWQgaW4gYSBzdGF0ZSBvYmplY3Rcbi8vIGFuZCB0aGlzIHN0YXRlIG9iamVjdCBpcyBtb3ZlZCBmb3J3YXJkIHRvIHRoZSBtYXRjaCBsYXllciBvbiBldmVyeSByZW5kZXJcbi8vIGN5Y2xlLiAgVGhlIG5ldyBsYXllciBlbmRzIHVwIHdpdGggdGhlIHN0YXRlIG9mIHRoZSBvbGQgbGF5ZXIgKGFuZCB0aGVcbi8vIHByb3BzIG9mIHRoZSBuZXcgbGF5ZXIpLCB3aGlsZSB0aGUgb2xkIGxheWVyIGlzIHNpbXBseSBkaXNjYXJkZWQgZm9yXG4vLyBnYXJiYWdlIGNvbGxlY2lvbi5cbi8vXG4vKiBlc2xpbnQtZGlzYWJsZSBuby10cnktY2F0Y2ggKi9cbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgZHJhd0xheWVycywgcGlja0xheWVycyB9IGZyb20gJy4vZHJhdy1hbmQtcGljayc7XG4vLyBpbXBvcnQge1ZpZXdwb3J0fSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IFZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydHMnO1xuXG5pbXBvcnQgeyBGcmFtZWJ1ZmZlck9iamVjdCB9IGZyb20gJ2x1bWEuZ2wnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllck1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7IGdsIH0pIHtcbiAgICB0aGlzLnByZXZMYXllcnMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIC8vIFRyYWNrcyBpZiBhbnkgbGF5ZXJzIHdlcmUgZHJhd24gbGFzdCB1cGRhdGVcbiAgICAvLyBOZWVkZWQgdG8gZW5zdXJlIHRoYXQgc2NyZWVuIGlzIGNsZWFyZWQgd2hlbiBubyBsYXllcnMgYXJlIHNob3duXG4gICAgdGhpcy5kcmV3TGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5vbGRDb250ZXh0ID0ge307XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgZ2wsXG4gICAgICB1bmlmb3Jtczoge30sXG4gICAgICB2aWV3cG9ydDogbnVsbCxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZDogdHJ1ZSxcbiAgICAgIHBpY2tpbmdGQk86IG51bGxcbiAgICB9O1xuICAgIHRoaXMucmVkcmF3TmVlZGVkID0gdHJ1ZTtcbiAgICBPYmplY3Quc2VhbCh0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICBhc3NlcnQodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCwgJ0ludmFsaWQgdmlld3BvcnQnKTtcblxuICAgIC8vIFRPRE8gLSB2aWV3cG9ydCBjaGFuZ2UgZGV0ZWN0aW9uIGJyZWFrcyBNRVRFUl9PRkZTRVRTIG1vZGVcbiAgICAvLyBjb25zdCBvbGRWaWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICAvLyBjb25zdCB2aWV3cG9ydENoYW5nZWQgPSAhb2xkVmlld3BvcnQgfHwgIXZpZXdwb3J0LmVxdWFscyhvbGRWaWV3cG9ydCk7XG5cbiAgICBjb25zdCB2aWV3cG9ydENoYW5nZWQgPSB0cnVlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9sZENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydENoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250ZXh0LnVuaWZvcm1zID0ge307XG4gICAgICBsb2coNCwgdmlld3BvcnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJzKHsgbmV3TGF5ZXJzIH0pIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsICdMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIGxheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgY29uc3QgeyBlcnJvciwgZ2VuZXJhdGVkTGF5ZXJzIH0gPSB0aGlzLl91cGRhdGVMYXllcnMoe1xuICAgICAgb2xkTGF5ZXJzOiB0aGlzLnByZXZMYXllcnMsXG4gICAgICBuZXdMYXllcnNcbiAgICB9KTtcblxuICAgIHRoaXMubGF5ZXJzID0gZ2VuZXJhdGVkTGF5ZXJzO1xuICAgIC8vIFRocm93IGZpcnN0IGVycm9yIGZvdW5kLCBpZiBhbnlcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRyYXdMYXllcnMoKSB7XG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCwgJ0xheWVyTWFuYWdlci5kcmF3TGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICBkcmF3TGF5ZXJzKHsgbGF5ZXJzOiB0aGlzLmxheWVycyB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGlja0xheWVyKHsgeCwgeSwgbW9kZSB9KSB7XG4gICAgY29uc3QgeyBnbCwgdW5pZm9ybXMgfSA9IHRoaXMuY29udGV4dDtcblxuICAgIC8vIFNldCB1cCBhIGZyYW1lIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICBpZiAodGhpcy5jb250ZXh0LnBpY2tpbmdGQk8gPT09IG51bGwgfHwgZ2wuY2FudmFzLndpZHRoICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy53aWR0aCB8fCBnbC5jYW52YXMuaGVpZ2h0ICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gbmV3IEZyYW1lYnVmZmVyT2JqZWN0KGdsLCB7XG4gICAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwaWNrTGF5ZXJzKGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHJlbmRlclBpY2tpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgIHBpY2tpbmdfdUVuYWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxheWVyczogdGhpcy5sYXllcnMsXG4gICAgICBtb2RlLFxuICAgICAgcGlja2luZ0ZCTzogdGhpcy5jb250ZXh0LnBpY2tpbmdGQk9cbiAgICB9KTtcbiAgfVxuXG4gIG5lZWRzUmVkcmF3KHsgY2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5jb250ZXh0LnZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDAgJiYgdGhpcy5kcmV3TGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVkcmF3TmVlZGVkKSB7XG4gICAgICB0aGlzLnJlZHJhd05lZWRlZCA9IGZhbHNlO1xuICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoeyBjbGVhclJlZHJhd0ZsYWdzIH0pO1xuICAgICAgdGhpcy5kcmV3TGF5ZXJzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIE1hdGNoIGFsbCBsYXllcnMsIGNoZWNraW5nIGZvciBjYXVnaHQgZXJyb3JzXG4gIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG4gIF91cGRhdGVMYXllcnMoeyBvbGRMYXllcnMsIG5ld0xheWVycyB9KSB7XG4gICAgLy8gQ3JlYXRlIG9sZCBsYXllciBtYXBcbiAgICBjb25zdCBvbGRMYXllck1hcCA9IHt9O1xuICAgIGZvciAoY29uc3Qgb2xkTGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAob2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBNdWx0aXBlIG9sZCBsYXllcnMgd2l0aCBzYW1lIGlkICR7IGxheWVyTmFtZShvbGRMYXllcikgfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdID0gb2xkTGF5ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb2NhdGUgYXJyYXkgZm9yIGdlbmVyYXRlZCBsYXllcnNcbiAgICBjb25zdCBnZW5lcmF0ZWRMYXllcnMgPSBbXTtcblxuICAgIC8vIE1hdGNoIHN1YmxheWVyc1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hTdWJsYXllcnMoe1xuICAgICAgbmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBlcnJvcjIgPSB0aGlzLl9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllcnMpO1xuICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBlcnJvciB8fCBlcnJvcjI7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZpcnN0RXJyb3IsIGdlbmVyYXRlZExheWVycyB9O1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX21hdGNoU3VibGF5ZXJzKHsgbmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzIH0pIHtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5ld0xheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbmV3TGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gMS4gZ2l2ZW4gYSBuZXcgY29taW5nIGxheWVyLCBmaW5kIGl0cyBtYXRjaGluZyBsYXllclxuICAgICAgICBjb25zdCBvbGRMYXllciA9IG9sZExheWVyTWFwW25ld0xheWVyLmlkXTtcbiAgICAgICAgb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdID0gbnVsbDtcblxuICAgICAgICBpZiAob2xkTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAkeyBsYXllck5hbWUobmV3TGF5ZXIpIH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAvLyB1bnRpbCBhbGwgbGF5ZXJzJyBzdGF0ZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgaWYgKG9sZExheWVyKSB7XG4gICAgICAgICAgbG9nKDMsIGBtYXRjaGVkICR7IGxheWVyTmFtZShuZXdMYXllcikgfWAsIG9sZExheWVyLCAnPT4nLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVOZXdMYXllcihuZXdMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzLnB1c2gobmV3TGF5ZXIpO1xuXG4gICAgICAgIC8vIENhbGwgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuICAgICAgICBsZXQgc3VibGF5ZXJzID0gbmV3TGF5ZXIucmVuZGVyTGF5ZXJzKCk7XG4gICAgICAgIC8vIEVuZCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG5cbiAgICAgICAgaWYgKHN1YmxheWVycykge1xuICAgICAgICAgIHN1YmxheWVycyA9IEFycmF5LmlzQXJyYXkoc3VibGF5ZXJzKSA/IHN1YmxheWVycyA6IFtzdWJsYXllcnNdO1xuICAgICAgICAgIHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgICAgICAgIG5ld0xheWVyczogc3VibGF5ZXJzLFxuICAgICAgICAgICAgb2xkTGF5ZXJNYXAsXG4gICAgICAgICAgICBnZW5lcmF0ZWRMYXllcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIGVycm9yIGR1cmluZyBtYXRjaGluZyBvZiAkeyBsYXllck5hbWUobmV3TGF5ZXIpIH0gJHsgZXJyIH1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBfdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcikge1xuICAgIGNvbnN0IHsgc3RhdGUsIHByb3BzIH0gPSBvbGRMYXllcjtcblxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGFzc2VydChzdGF0ZSwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaGFzIG5vIHN0YXRlJyk7XG4gICAgYXNzZXJ0KG9sZExheWVyICE9PSBuZXdMYXllciwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaXMgc2FtZScpO1xuXG4gICAgLy8gTW92ZSBzdGF0ZVxuICAgIG5ld0xheWVyLnN0YXRlID0gc3RhdGU7XG4gICAgc3RhdGUubGF5ZXIgPSBuZXdMYXllcjtcblxuICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICBpZiAoc3RhdGUubW9kZWwpIHtcbiAgICAgIHN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbmV3TGF5ZXI7XG4gICAgfVxuICAgIC8vIEtlZXAgYSB0ZW1wb3JhcnkgcmVmIHRvIHRoZSBvbGQgcHJvcHMsIGZvciBwcm9wIGNvbXBhcmlzb25cbiAgICBuZXdMYXllci5vbGRQcm9wcyA9IHByb3BzO1xuICAgIG9sZExheWVyLnN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcbiAgX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycykge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgLy8gVW5tYXRjaGVkIGxheWVycyBzdGlsbCBoYXZlIHN0YXRlLCBpdCB3aWxsIGJlIGRpc2NhcmRlZFxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAobGF5ZXIuc3RhdGUpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCB0aGlzLl9maW5hbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfaW5pdGlhbGl6ZU5ld0xheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBDaGVjayBpZiBuZXcgbGF5ZXIsIGFuZCBpbml0aWFsaXplIGl0J3Mgc3RhdGVcbiAgICBpZiAoIWxheWVyLnN0YXRlKSB7XG4gICAgICBsb2coMSwgYGluaXRpYWxpemluZyAkeyBsYXllck5hbWUobGF5ZXIpIH1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmluaXRpYWxpemVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHM6IHt9LFxuICAgICAgICAgIHByb3BzOiBsYXllci5wcm9wcyxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMoe30sIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbiBvZiAkeyBsYXllck5hbWUobGF5ZXIpIH0gJHsgZXJyIH1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgICAgLy8gU2V0IGJhY2sgcG9pbnRlciAodXNlZCBpbiBwaWNraW5nKVxuICAgICAgaWYgKGxheWVyLnN0YXRlKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIC8vIFNhdmUgbGF5ZXIgb24gbW9kZWwgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAgICAgLy8gVE9ETyAtIHN0b3JlIG9uIG1vZGVsLnVzZXJEYXRhIHJhdGhlciB0aGFuIGRpcmVjdGx5IG9uIG1vZGVsXG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIuc3RhdGUgJiYgbGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgbGF5ZXIuc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF91cGRhdGVMYXllcihsYXllcikge1xuICAgIGNvbnN0IHsgb2xkUHJvcHMsIHByb3BzIH0gPSBsYXllcjtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIudXBkYXRlTGF5ZXIoe1xuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY2hhbmdlRmxhZ3M6IGxheWVyLmRpZmZQcm9wcyhvbGRQcm9wcywgbGF5ZXIucHJvcHMsIHRoaXMuY29udGV4dClcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIHVwZGF0ZSBvZiAkeyBsYXllck5hbWUobGF5ZXIpIH1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgbG9nKDIsIGB1cGRhdGluZyAkeyBsYXllck5hbWUobGF5ZXIpIH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gRmluYWxpemVzIGEgc2luZ2xlIGxheWVyXG4gIF9maW5hbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBsYXllcjtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmZpbmFsaXplTGF5ZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZGVjay5nbCBlcnJvciBkdXJpbmcgZmluYWxpemF0aW9uIG9mICR7IGxheWVyTmFtZShsYXllcikgfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICBsYXllci5zdGF0ZSA9IG51bGw7XG4gICAgICBsb2coMSwgYGZpbmFsaXppbmcgJHsgbGF5ZXJOYW1lKGxheWVyKSB9YCk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXllck5hbWUobGF5ZXIpIHtcbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICByZXR1cm4gYCR7IGxheWVyIH1gO1xuICB9XG4gIHJldHVybiAhbGF5ZXIgPyAnbnVsbCBsYXllcicgOiAnaW52YWxpZCBsYXllcic7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 51 */
/* exports provided: compareProps, areEqualShallow */
/* exports used: compareProps */
/*!******************************************!*\
  !*** ./src/lib/utils/compare-objects.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(/*! assert */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);\n/* harmony export (immutable) */ exports[\"a\"] = compareProps;\n/* unused harmony export areEqualShallow */\n\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n/* eslint-disable max-statements, complexity */\nfunction compareProps(ref) {\n  if ( ref === void 0 ) ref = {};\n  var oldProps = ref.oldProps;\n  var newProps = ref.newProps;\n  var ignoreProps = ref.ignoreProps; if ( ignoreProps === void 0 ) ignoreProps = {};\n\n  __WEBPACK_IMPORTED_MODULE_0_assert___default()(oldProps !== undefined && newProps !== undefined, 'compareProps args');\n\n  if (oldProps === newProps) {\n    return null;\n  }\n\n  if (typeof oldProps !== 'object' || oldProps === null) {\n    return 'old props is not an object';\n  }\n  if (typeof newProps !== 'object' || newProps === null) {\n    return 'new props is not an object';\n  }\n\n  // Test if new props different from old props\n  for (var key in oldProps) {\n    if (!(key in ignoreProps)) {\n      if (!newProps.hasOwnProperty(key)) {\n        return (\"prop \" + key + \" dropped: \" + (oldProps[key]) + \" -> (undefined)\");\n      } else if (oldProps[key] !== newProps[key]) {\n        return (\"prop \" + key + \" changed: \" + (oldProps[key]) + \" -> \" + (newProps[key]));\n      }\n    }\n  }\n\n  // Test if any new props have been added\n  for (var key$1 in newProps) {\n    if (!(key$1 in ignoreProps)) {\n      if (!oldProps.hasOwnProperty(key$1)) {\n        return (\"prop \" + key$1 + \" added: (undefined) -> \" + (newProps[key$1]));\n      }\n    }\n  }\n\n  return null;\n}\n/* eslint-enable max-statements, complexity */\n\n// Shallow compare\n/* eslint-disable complexity */\nfunction areEqualShallow(a, b, ref) {\n  if ( ref === void 0 ) ref = {};\n  var ignore = ref.ignore; if ( ignore === void 0 ) ignore = {};\n\n\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) {\n    return false;\n  }\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (var key in a) {\n    if (!(key in ignore) && (!(key in b) || a[key] !== b[key])) {\n      return false;\n    }\n  }\n  for (var key$1 in b) {\n    if (!(key$1 in ignore) && !(key$1 in a)) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi91dGlscy9jb21wYXJlLW9iamVjdHMuanM/NmIzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lm9sZFByb3BzIC0gb2JqZWN0IHdpdGggb2xkIGtleS92YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdC5uZXdQcm9wcyAtIG9iamVjdCB3aXRoIG5ldyBrZXkvdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQuaWdub3JlUHJvcHM9e30gLSBvYmplY3QsIGtleXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbXBhcmVkXG4gKiBAcmV0dXJucyB7bnVsbHxTdHJpbmd9IC0gbnVsbCB3aGVuIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKiAgIGlmIHVuZXF1YWwsIHJldHVybnMgYSBzdHJpbmcgZXhwbGFpbmluZyB3aGF0IGNoYW5nZWQuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVByb3BzKHsgb2xkUHJvcHMsIG5ld1Byb3BzLCBpZ25vcmVQcm9wcyA9IHt9IH0gPSB7fSkge1xuICBhc3NlcnQob2xkUHJvcHMgIT09IHVuZGVmaW5lZCAmJiBuZXdQcm9wcyAhPT0gdW5kZWZpbmVkLCAnY29tcGFyZVByb3BzIGFyZ3MnKTtcblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIG9sZFByb3BzICE9PSAnb2JqZWN0JyB8fCBvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnb2xkIHByb3BzIGlzIG5vdCBhbiBvYmplY3QnO1xuICB9XG4gIGlmICh0eXBlb2YgbmV3UHJvcHMgIT09ICdvYmplY3QnIHx8IG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuICduZXcgcHJvcHMgaXMgbm90IGFuIG9iamVjdCc7XG4gIH1cblxuICAvLyBUZXN0IGlmIG5ldyBwcm9wcyBkaWZmZXJlbnQgZnJvbSBvbGQgcHJvcHNcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9wICR7IGtleSB9IGRyb3BwZWQ6ICR7IG9sZFByb3BzW2tleV0gfSAtPiAodW5kZWZpbmVkKWA7XG4gICAgICB9IGVsc2UgaWYgKG9sZFByb3BzW2tleV0gIT09IG5ld1Byb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGBwcm9wICR7IGtleSB9IGNoYW5nZWQ6ICR7IG9sZFByb3BzW2tleV0gfSAtPiAkeyBuZXdQcm9wc1trZXldIH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgaWYgYW55IG5ldyBwcm9wcyBoYXZlIGJlZW4gYWRkZWRcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW9sZFByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9wICR7IGtleSB9IGFkZGVkOiAodW5kZWZpbmVkKSAtPiAkeyBuZXdQcm9wc1trZXldIH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuXG4vLyBTaGFsbG93IGNvbXBhcmVcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmVFcXVhbFNoYWxsb3coYSwgYiwgeyBpZ25vcmUgPSB7fSB9ID0ge30pIHtcblxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCBhID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0JyB8fCBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmUpICYmICghKGtleSBpbiBiKSB8fCBhW2tleV0gIT09IGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gYikge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmUpICYmICEoa2V5IGluIGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3V0aWxzL2NvbXBhcmUtb2JqZWN0cy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 52 */
/* exports provided: default */
/* exports used: default */
/*!******************************!*\
  !*** ./src/lib/utils/log.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(/*! assert */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);\n/* harmony export (immutable) */ exports[\"a\"] = log;\n/* eslint-disable no-console */\n/* global console, window */\n\n\nfunction log(priority) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  __WEBPACK_IMPORTED_MODULE_0_assert___default()(Number.isFinite(priority), 'log priority must be a number');\n  if (priority <= log.priority) {\n    console.debug.apply(console, args);\n  }\n}\n\nvar cache = {};\n\nfunction once(priority, arg) {\n  var args = [], len = arguments.length - 2;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n  if (!cache[arg]) {\n    log.apply(void 0, [ priority, arg ].concat( args ));\n  }\n  cache[arg] = true;\n}\n\nlog.priority = 0;\nlog.log = log;\nlog.once = once;\n\n// Expose to browser\nif (typeof window !== 'undefined') {\n  window.deck = window.deck || { log: log };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi91dGlscy9sb2cuanM/ZWE4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4vKiBnbG9iYWwgY29uc29sZSwgd2luZG93ICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZyhwcmlvcml0eSwgLi4uYXJncykge1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHByaW9yaXR5KSwgJ2xvZyBwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmIChwcmlvcml0eSA8PSBsb2cucHJpb3JpdHkpIHtcbiAgICBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpO1xuICB9XG59XG5cbmNvbnN0IGNhY2hlID0ge307XG5cbmZ1bmN0aW9uIG9uY2UocHJpb3JpdHksIGFyZywgLi4uYXJncykge1xuICBpZiAoIWNhY2hlW2FyZ10pIHtcbiAgICBsb2cocHJpb3JpdHksIGFyZywgLi4uYXJncyk7XG4gIH1cbiAgY2FjaGVbYXJnXSA9IHRydWU7XG59XG5cbmxvZy5wcmlvcml0eSA9IDA7XG5sb2cubG9nID0gbG9nO1xubG9nLm9uY2UgPSBvbmNlO1xuXG4vLyBFeHBvc2UgdG8gYnJvd3NlclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5kZWNrID0gd2luZG93LmRlY2sgfHwgeyBsb2cgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi91dGlscy9sb2cuanMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 53 */
/* exports provided: getUniformsFromViewport */
/* exports used: getUniformsFromViewport */
/*!**************************************!*\
  !*** ./src/lib/viewport-uniforms.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(/*! assert */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(/*! ./constants */ 19);\n/* harmony export (immutable) */ exports[\"a\"] = getUniformsFromViewport;\n\n\n\n\n\nfunction fp64ify(a) {\n  var hiPart = Math.fround(a);\n  var loPart = a - Math.fround(a);\n  return [hiPart, loPart];\n}\n\n// To quickly set a vector to zero\nvar ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction calculateMatrixAndOffset(ref) {\n  var projectionMode = ref.projectionMode;\n  var positionOrigin = ref.positionOrigin;\n  var viewport = ref.viewport;\n  var modelMatrix = ref.modelMatrix;\n\n  var viewMatrixUncentered = viewport.viewMatrixUncentered;\n  var viewMatrix = viewport.viewMatrix;\n  var projectionMatrix = viewport.projectionMatrix;\n\n  var projectionCenter;\n  var modelViewProjectionMatrix;\n\n  var viewProjectionMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](projectionMatrix).multiplyRight(viewMatrix);\n\n  switch (projectionMode) {\n\n    case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].LNGLAT:\n      projectionCenter = ZERO_VECTOR;\n      modelViewProjectionMatrix = viewProjectionMatrix;\n      if (modelMatrix) {\n        // Apply model matrix if supplied\n        // modelViewProjectionMatrix = modelViewProjectionMatrix.clone();\n        modelViewProjectionMatrix.multiplyRight(modelMatrix);\n      }\n      break;\n\n    case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].METER_OFFSETS:\n      // Calculate transformed projectionCenter (in 64 bit precision)\n      // This is the key to offset mode precision (avoids doing this\n      // addition in 32 bit precision)\n      var positionPixels = viewport.projectFlat(positionOrigin);\n      projectionCenter = viewProjectionMatrix.transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n\n      modelViewProjectionMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](projectionMatrix)\n      // Always apply uncentered projection matrix (shader adds center)\n      .multiplyRight(viewMatrixUncentered)\n      // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n      .multiplyRight(VECTOR_TO_POINT_MATRIX);\n\n      if (modelMatrix) {\n        // Apply model matrix if supplied\n        modelViewProjectionMatrix.multiplyRight(modelMatrix);\n      }\n      break;\n\n    default:\n      throw new Error('Unknown projection mode');\n  }\n\n  return {\n    modelViewProjectionMatrix: modelViewProjectionMatrix,\n    projectionCenter: projectionCenter\n  };\n}\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nfunction getUniformsFromViewport(viewport, ref) {\n  if ( ref === void 0 ) ref = {};\n  var modelMatrix = ref.modelMatrix; if ( modelMatrix === void 0 ) modelMatrix = null;\n  var projectionMode = ref.projectionMode; if ( projectionMode === void 0 ) projectionMode = __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].LNGLAT;\n  var positionOrigin = ref.positionOrigin; if ( positionOrigin === void 0 ) positionOrigin = [0, 0];\n\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(viewport.scale, 'Viewport scale missing');\n\n  var ref$1 = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport });\n  var projectionCenter = ref$1.projectionCenter;\n  var modelViewProjectionMatrix = ref$1.modelViewProjectionMatrix;\n\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');\n\n  // Calculate projection pixels per unit\n  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');\n\n  // calculate WebGL matrices\n\n  // Convert to Float32\n  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);\n\n  // \"Float64Array\"\n  // Transpose the projection matrix to column major for GLSL.\n  var glProjectionMatrixFP64 = new Float32Array(32);\n  for (var i = 0; i < 4; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var assign;\n      (assign = fp64ify(modelViewProjectionMatrix[j * 4 + i]), glProjectionMatrixFP64[(i * 4 + j) * 2] = assign[0], glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = assign[1]);\n    }\n  }\n\n  return {\n    // Projection mode values\n    projectionMode: projectionMode,\n    projectionCenter: projectionCenter,\n\n    // modelMatrix: modelMatrix || new Matrix4().identity(),\n\n    // Main projection matrices\n    projectionMatrix: glProjectionMatrix,\n    projectionMatrixUncentered: glProjectionMatrix,\n    projectionFP64: glProjectionMatrixFP64,\n    projectionPixelsPerUnit: projectionPixelsPerUnit,\n\n    // This is the mercator scale (2 ** zoom)\n    projectionScale: viewport.scale,\n\n    // Deprecated?\n    projectionScaleFP64: fp64ify(viewport.scale)\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi92aWV3cG9ydC11bmlmb3Jtcy5qcz84YTcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgQ09PUkRJTkFURV9TWVNURU0gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmZ1bmN0aW9uIGZwNjRpZnkoYSkge1xuICBjb25zdCBoaVBhcnQgPSBNYXRoLmZyb3VuZChhKTtcbiAgY29uc3QgbG9QYXJ0ID0gYSAtIE1hdGguZnJvdW5kKGEpO1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMCwgMF07XG4vLyA0eDQgbWF0cml4IHRoYXQgZHJvcHMgNHRoIGNvbXBvbmVudCBvZiB2ZWN0b3JcbmNvbnN0IFZFQ1RPUl9UT19QT0lOVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMF07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7XG4gIHByb2plY3Rpb25Nb2RlLFxuICBwb3NpdGlvbk9yaWdpbixcbiAgdmlld3BvcnQsXG4gIG1vZGVsTWF0cml4XG59KSB7XG4gIGNvbnN0IHsgdmlld01hdHJpeFVuY2VudGVyZWQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXggfSA9IHZpZXdwb3J0O1xuXG4gIGxldCBwcm9qZWN0aW9uQ2VudGVyO1xuICBsZXQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcblxuICBjb25zdCB2aWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpLm11bHRpcGx5UmlnaHQodmlld01hdHJpeCk7XG5cbiAgc3dpdGNoIChwcm9qZWN0aW9uTW9kZSkge1xuXG4gICAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgICBwcm9qZWN0aW9uQ2VudGVyID0gWkVST19WRUNUT1I7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdmlld1Byb2plY3Rpb25NYXRyaXg7XG4gICAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICAgIC8vIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LmNsb25lKCk7XG4gICAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUzpcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm1lZCBwcm9qZWN0aW9uQ2VudGVyIChpbiA2NCBiaXQgcHJlY2lzaW9uKVxuICAgICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvbiAoYXZvaWRzIGRvaW5nIHRoaXNcbiAgICAgIC8vIGFkZGl0aW9uIGluIDMyIGJpdCBwcmVjaXNpb24pXG4gICAgICBjb25zdCBwb3NpdGlvblBpeGVscyA9IHZpZXdwb3J0LnByb2plY3RGbGF0KHBvc2l0aW9uT3JpZ2luKTtcbiAgICAgIHByb2plY3Rpb25DZW50ZXIgPSB2aWV3UHJvamVjdGlvbk1hdHJpeC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcblxuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpXG4gICAgICAvLyBBbHdheXMgYXBwbHkgdW5jZW50ZXJlZCBwcm9qZWN0aW9uIG1hdHJpeCAoc2hhZGVyIGFkZHMgY2VudGVyKVxuICAgICAgLm11bHRpcGx5UmlnaHQodmlld01hdHJpeFVuY2VudGVyZWQpXG4gICAgICAvLyBaZXJvIG91dCA0dGggY29vcmRpbmF0ZSAoXCJhZnRlclwiIG1vZGVsIG1hdHJpeCkgLSBhdm9pZHMgZnVydGhlciB0cmFuc2xhdGlvbnNcbiAgICAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuXG4gICAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkNlbnRlclxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdW5pZm9ybXMgZm9yIHNoYWRlcnMgYmFzZWQgb24gY3VycmVudCBwcm9qZWN0aW9uXG4gKiBpbmNsdWRlczogcHJvamVjdGlvbiBtYXRyaXggc3VpdGFibGUgZm9yIHNoYWRlcnNcbiAqXG4gKiBUT0RPIC0gRW5zdXJlIHRoaXMgd29ya3Mgd2l0aCBhbnkgdmlld3BvcnQsIG5vdCBqdXN0IFdlYk1lcmNhdG9yVmlld3BvcnRzXG4gKlxuICogQHBhcmFtIHtXZWJNZXJjYXRvclZpZXdwb3J0fSB2aWV3cG9ydCAtXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gNHg0IHByb2plY3Rpb24gbWF0cml4IHRoYXQgY2FuIGJlIHVzZWQgaW4gc2hhZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQodmlld3BvcnQsIHtcbiAgbW9kZWxNYXRyaXggPSBudWxsLFxuICBwcm9qZWN0aW9uTW9kZSA9IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCxcbiAgcG9zaXRpb25PcmlnaW4gPSBbMCwgMF1cbn0gPSB7fSkge1xuICBhc3NlcnQodmlld3BvcnQuc2NhbGUsICdWaWV3cG9ydCBzY2FsZSBtaXNzaW5nJyk7XG5cbiAgY29uc3QgeyBwcm9qZWN0aW9uQ2VudGVyLCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4IH0gPSBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoeyBwcm9qZWN0aW9uTW9kZSwgcG9zaXRpb25PcmlnaW4sIG1vZGVsTWF0cml4LCB2aWV3cG9ydCB9KTtcblxuICBhc3NlcnQobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCwgJ1ZpZXdwb3J0IG1pc3NpbmcgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCcpO1xuXG4gIC8vIENhbGN1bGF0ZSBwcm9qZWN0aW9uIHBpeGVscyBwZXIgdW5pdFxuICBjb25zdCBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCkucGl4ZWxzUGVyTWV0ZXI7XG4gIGFzc2VydChwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCwgJ1ZpZXdwb3J0IG1pc3NpbmcgcGl4ZWxzUGVyTWV0ZXInKTtcblxuICAvLyBjYWxjdWxhdGUgV2ViR0wgbWF0cmljZXNcblxuICAvLyBDb252ZXJ0IHRvIEZsb2F0MzJcbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAvLyBcIkZsb2F0NjRBcnJheVwiXG4gIC8vIFRyYW5zcG9zZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggdG8gY29sdW1uIG1ham9yIGZvciBHTFNMLlxuICBjb25zdCBnbFByb2plY3Rpb25NYXRyaXhGUDY0ID0gbmV3IEZsb2F0MzJBcnJheSgzMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgIFtnbFByb2plY3Rpb25NYXRyaXhGUDY0WyhpICogNCArIGopICogMl0sIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyICsgMV1dID0gZnA2NGlmeShtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4W2ogKiA0ICsgaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gUHJvamVjdGlvbiBtb2RlIHZhbHVlc1xuICAgIHByb2plY3Rpb25Nb2RlLFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG5cbiAgICAvLyBtb2RlbE1hdHJpeDogbW9kZWxNYXRyaXggfHwgbmV3IE1hdHJpeDQoKS5pZGVudGl0eSgpLFxuXG4gICAgLy8gTWFpbiBwcm9qZWN0aW9uIG1hdHJpY2VzXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQsXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtZXJjYXRvciBzY2FsZSAoMiAqKiB6b29tKVxuICAgIHByb2plY3Rpb25TY2FsZTogdmlld3BvcnQuc2NhbGUsXG5cbiAgICAvLyBEZXByZWNhdGVkP1xuICAgIHByb2plY3Rpb25TY2FsZUZQNjQ6IGZwNjRpZnkodmlld3BvcnQuc2NhbGUpXG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFJQTtBQUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 54 */
/* exports provided: default */
/*!****************************************************!*\
  !*** ./src/lib/viewports/orthographic-viewport.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n\n\n\nvar OrthographicViewport = (function (Viewport) {\n  function OrthographicViewport(ref) {\n    var width = ref.width;\n    var height = ref.height;\n    var eye = ref.eye;\n    var lookAt = ref.lookAt; if ( lookAt === void 0 ) lookAt = [0, 0, 0];\n    var up = ref.up; if ( up === void 0 ) up = [0, 1, 0];\n    var near = ref.near; if ( near === void 0 ) near = 1;\n    var far = ref.far; if ( far === void 0 ) far = 100;\n    var fovy = ref.fovy; if ( fovy === void 0 ) fovy = 75;\n    var left = ref.left;\n    var top = ref.top;\n    var right = ref.right; if ( right === void 0 ) right = null;\n    var bottom = ref.bottom; if ( bottom === void 0 ) bottom = null;\n\n    right = Number.isFinite(right) ? right : left + width;\n    bottom = Number.isFinite(bottom) ? right : top + height;\n    Viewport.call(this, {\n      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].lookAt([], eye, lookAt, up),\n      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].ortho([], left, right, bottom, top, near, far),\n      width: width,\n      height: height\n    });\n  }\n\n  if ( Viewport ) OrthographicViewport.__proto__ = Viewport;\n  OrthographicViewport.prototype = Object.create( Viewport && Viewport.prototype );\n  OrthographicViewport.prototype.constructor = OrthographicViewport;\n\n  return OrthographicViewport;\n}(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */]));\n\n/* unused harmony default export */ var _unused_webpack_default_export = OrthographicViewport;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi92aWV3cG9ydHMvb3J0aG9ncmFwaGljLXZpZXdwb3J0LmpzPzAxYTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xuaW1wb3J0IHsgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ3JhcGhpY1ZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gdmlld3BvcnQgYXJndW1lbnRzXG4gICAgd2lkdGgsIC8vIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2Ygdmlld3BvcnRcbiAgICAvLyB2aWV3IG1hdHJpeCBhcmd1bWVudHNcbiAgICBleWUsIC8vIERlZmluZXMgZXllIHBvc2l0aW9uXG4gICAgbG9va0F0ID0gWzAsIDAsIDBdLCAvLyBXaGljaCBwb2ludCBpcyBjYW1lcmEgbG9va2luZyBhdCwgZGVmYXVsdCBvcmlnaW5cbiAgICB1cCA9IFswLCAxLCAwXSwgLy8gRGVmaW5lcyB1cCBkaXJlY3Rpb24sIGRlZmF1bHQgcG9zaXRpdmUgeSBheGlzXG4gICAgLy8gcHJvamVjdGlvbiBtYXRyaXggYXJndW1lbnRzXG4gICAgbmVhciA9IDEsIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICBmYXIgPSAxMDAsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuICAgIGZvdnkgPSA3NSwgLy8gRmllbGQgb2YgdmlldyBjb3ZlcmVkIGJ5IGNhbWVyYVxuICAgIGxlZnQsIC8vIExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgICB0b3AsIC8vIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZFxuICAgIHJpZ2h0ID0gbnVsbCwgLy8gUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAgICBib3R0b20gPSBudWxsIC8vIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICB9KSB7XG4gICAgcmlnaHQgPSBOdW1iZXIuaXNGaW5pdGUocmlnaHQpID8gcmlnaHQgOiBsZWZ0ICsgd2lkdGg7XG4gICAgYm90dG9tID0gTnVtYmVyLmlzRmluaXRlKGJvdHRvbSkgPyByaWdodCA6IHRvcCArIGhlaWdodDtcbiAgICBzdXBlcih7XG4gICAgICB2aWV3TWF0cml4OiBtYXQ0Lmxvb2tBdChbXSwgZXllLCBsb29rQXQsIHVwKSxcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IG1hdDQub3J0aG8oW10sIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi92aWV3cG9ydHMvb3J0aG9ncmFwaGljLXZpZXdwb3J0LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTs7QUE1QkE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 55 */
/* exports provided: default */
/*!***************************************************!*\
  !*** ./src/lib/viewports/perspective-viewport.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n\n\n\nvar DEGREES_TO_RADIANS = Math.PI / 180;\n\nvar PerspectiveViewport = (function (Viewport) {\n  function PerspectiveViewport(ref) {\n    var width = ref.width;\n    var height = ref.height;\n    var eye = ref.eye;\n    var lookAt = ref.lookAt; if ( lookAt === void 0 ) lookAt = [0, 0, 0];\n    var up = ref.up; if ( up === void 0 ) up = [0, 1, 0];\n    var fovy = ref.fovy; if ( fovy === void 0 ) fovy = 75;\n    var near = ref.near; if ( near === void 0 ) near = 1;\n    var far = ref.far; if ( far === void 0 ) far = 100;\n    var aspect = ref.aspect; if ( aspect === void 0 ) aspect = null;\n\n    var fovyRadians = fovy * DEGREES_TO_RADIANS;\n    aspect = Number.isFinite(aspect) ? aspect : width / height;\n    Viewport.call(this, {\n      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].lookAt([], eye, lookAt, up),\n      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].perspective([], fovyRadians, aspect, near, far),\n      width: width,\n      height: height\n    });\n  }\n\n  if ( Viewport ) PerspectiveViewport.__proto__ = Viewport;\n  PerspectiveViewport.prototype = Object.create( Viewport && Viewport.prototype );\n  PerspectiveViewport.prototype.constructor = PerspectiveViewport;\n\n  return PerspectiveViewport;\n}(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */]));\n\n/* unused harmony default export */ var _unused_webpack_default_export = PerspectiveViewport;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi92aWV3cG9ydHMvcGVyc3BlY3RpdmUtdmlld3BvcnQuanM/NGQ0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmlld3BvcnQgZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQgeyBtYXQ0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc3BlY3RpdmVWaWV3cG9ydCBleHRlbmRzIFZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIHZpZXdwb3J0IGFyZ3VtZW50c1xuICAgIHdpZHRoLCAvLyBXaWR0aCBvZiB2aWV3cG9ydFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHZpZXdwb3J0XG4gICAgLy8gdmlldyBtYXRyaXggYXJndW1lbnRzXG4gICAgZXllLCAvLyBEZWZpbmVzIGV5ZSBwb3NpdGlvblxuICAgIGxvb2tBdCA9IFswLCAwLCAwXSwgLy8gV2hpY2ggcG9pbnQgaXMgY2FtZXJhIGxvb2tpbmcgYXQsIGRlZmF1bHQgb3JpZ2luXG4gICAgdXAgPSBbMCwgMSwgMF0sIC8vIERlZmluZXMgdXAgZGlyZWN0aW9uLCBkZWZhdWx0IHBvc2l0aXZlIHkgYXhpc1xuICAgIC8vIHByb2plY3Rpb24gbWF0cml4IGFyZ3VtZW50c1xuICAgIGZvdnkgPSA3NSwgLy8gRmllbGQgb2YgdmlldyBjb3ZlcmVkIGJ5IGNhbWVyYVxuICAgIG5lYXIgPSAxLCAvLyBEaXN0YW5jZSBvZiBuZWFyIGNsaXBwaW5nIHBsYW5lXG4gICAgZmFyID0gMTAwLCAvLyBEaXN0YW5jZSBvZiBmYXIgY2xpcHBpbmcgcGxhbmVcbiAgICAvLyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWRcbiAgICBhc3BlY3QgPSBudWxsIC8vIEFzcGVjdCByYXRpbyAoc2V0IHRvIHZpZXdwb3J0IHdpZGh0L2hlaWdodClcbiAgfSkge1xuICAgIGNvbnN0IGZvdnlSYWRpYW5zID0gZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICBhc3BlY3QgPSBOdW1iZXIuaXNGaW5pdGUoYXNwZWN0KSA/IGFzcGVjdCA6IHdpZHRoIC8gaGVpZ2h0O1xuICAgIHN1cGVyKHtcbiAgICAgIHZpZXdNYXRyaXg6IG1hdDQubG9va0F0KFtdLCBleWUsIGxvb2tBdCwgdXApLFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogbWF0NC5wZXJzcGVjdGl2ZShbXSwgZm92eVJhZGlhbnMsIGFzcGVjdCwgbmVhciwgZmFyKSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYi92aWV3cG9ydHMvcGVyc3BlY3RpdmUtdmlld3BvcnQuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTs7QUF6QkE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 56 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/lib/viewports/web-mercator-viewport.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\n// View and Projection Matrix calculations for mapbox-js style\n// map view properties\n\n\n\n// CONSTANTS\nvar PI = Math.PI;\nvar PI_4 = PI / 4;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nvar TILE_SIZE = 512;\nvar WORLD_SCALE = TILE_SIZE / (2 * PI);\n\nvar DEFAULT_MAP_STATE = {\n  latitude: 37,\n  longitude: -122,\n  zoom: 11,\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\n\nvar WebMercatorViewport = (function (Viewport) {\n  function WebMercatorViewport(ref) {\n    if ( ref === void 0 ) ref = {};\n    var width = ref.width;\n    var height = ref.height;\n    var latitude = ref.latitude;\n    var longitude = ref.longitude;\n    var zoom = ref.zoom;\n    var pitch = ref.pitch;\n    var bearing = ref.bearing;\n    var altitude = ref.altitude;\n    var mercatorEnabled = ref.mercatorEnabled;\n\n    // Viewport - support undefined arguments\n    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;\n    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;\n    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;\n    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;\n    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;\n    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;\n    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;\n    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    var scale = Math.pow(2, zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });\n\n    var projectionMatrix = makeProjectionMatrixFromMercatorParams({\n      width: width,\n      height: height,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude\n    });\n\n    var ref$1 = makeViewMatrixFromMercatorParams({\n      width: width,\n      height: height,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude,\n      distanceScales: distanceScales\n    });\n    var viewMatrix = ref$1.viewMatrix;\n    var viewMatrixUncentered = ref$1.viewMatrixUncentered;\n    var viewCenter = ref$1.viewCenter;\n\n    Viewport.call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix });\n\n    // Add additional matrices\n    this.viewMatrixUncentered = viewMatrixUncentered;\n    this.viewCenter = viewCenter;\n\n    // Save parameters\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n\n    this.scale = scale;\n\n    this._distanceScales = distanceScales;\n\n    this.getDistanceScales = this.getDistanceScales.bind(this);\n    this.metersToLngLatDelta = this.metersToLngLatDelta.bind(this);\n    this.lngLatDeltaToMeters = this.lngLatDeltaToMeters.bind(this);\n    this.addMetersToLngLat = this.addMetersToLngLat.bind(this);\n  }\n\n  if ( Viewport ) WebMercatorViewport.__proto__ = Viewport;\n  WebMercatorViewport.prototype = Object.create( Viewport && Viewport.prototype );\n  WebMercatorViewport.prototype.constructor = WebMercatorViewport;\n  /* eslint-enable complexity, max-statements */\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  WebMercatorViewport.prototype._projectFlat = function _projectFlat (lngLat, scale) {\n    if ( scale === void 0 ) scale = this.scale;\n\n    return projectFlat(lngLat, scale);\n  };\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  WebMercatorViewport.prototype._unprojectFlat = function _unprojectFlat (xy, scale) {\n    if ( scale === void 0 ) scale = this.scale;\n\n    return unprojectFlat(xy, scale);\n  };\n\n  WebMercatorViewport.prototype.getDistanceScales = function getDistanceScales () {\n    return this._distanceScales;\n  };\n\n  /**\n   * Converts a meter offset to a lnglat offset\n   *\n   * Note: Uses simple linear approximation around the viewport center\n   * Error increases with size of offset (roughly 1% per 100km)\n   *\n   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n   * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas\n   */\n  WebMercatorViewport.prototype.metersToLngLatDelta = function metersToLngLatDelta (xyz) {\n    var x = xyz[0];\n    var y = xyz[1];\n    var z = xyz[2]; if ( z === void 0 ) z = 0;\n    var ref = this._distanceScales;\n    var pixelsPerMeter = ref.pixelsPerMeter;\n    var degreesPerPixel = ref.degreesPerPixel;\n    var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];\n    var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];\n    return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];\n  };\n\n  /**\n   * Converts a lnglat offset to a meter offset\n   *\n   * Note: Uses simple linear approximation around the viewport center\n   * Error increases with size of offset (roughly 1% per 100km)\n   *\n   * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas\n   * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas\n   */\n  WebMercatorViewport.prototype.lngLatDeltaToMeters = function lngLatDeltaToMeters (deltaLngLatZ) {\n    var deltaLng = deltaLngLatZ[0];\n    var deltaLat = deltaLngLatZ[1];\n    var deltaZ = deltaLngLatZ[2]; if ( deltaZ === void 0 ) deltaZ = 0;\n    var ref = this._distanceScales;\n    var pixelsPerDegree = ref.pixelsPerDegree;\n    var metersPerPixel = ref.metersPerPixel;\n    var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];\n    var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];\n    return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];\n  };\n\n  /**\n   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array\n   *\n   * Note: Uses simple linear approximation around the viewport center\n   * Error increases with size of offset (roughly 1% per 100km)\n   *\n   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate\n   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas\n   */\n  WebMercatorViewport.prototype.addMetersToLngLat = function addMetersToLngLat (lngLatZ, xyz) {\n    var lng = lngLatZ[0];\n    var lat = lngLatZ[1];\n    var Z = lngLatZ[2]; if ( Z === void 0 ) Z = 0;\n    var ref = this.metersToLngLatDelta(xyz);\n    var deltaLng = ref[0];\n    var deltaLat = ref[1];\n    var deltaZ = ref[2]; if ( deltaZ === void 0 ) deltaZ = 0;\n    return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];\n  };\n\n  // INTERNAL METHODS\n\n  WebMercatorViewport.prototype._getParams = function _getParams () {\n    return this._distanceScales;\n  };\n\n  return WebMercatorViewport;\n}(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */]));\n\n/* harmony default export */ exports[\"a\"] = WebMercatorViewport;\n\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param {Array} lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\nfunction projectFlat(ref, scale) {\n  var lng = ref[0];\n  var lat = ref[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = lng * DEGREES_TO_RADIANS;\n  var phi2 = lat * DEGREES_TO_RADIANS;\n  var x = scale * (lambda2 + PI);\n  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));\n  return [x, y];\n}\n\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param {object|Vector} xy - object with {x,y} members\n *  representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\nfunction unprojectFlat(ref, scale) {\n  var x = ref[0];\n  var y = ref[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = x / scale - PI;\n  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nfunction calculateDistanceScales(ref) {\n  var latitude = ref.latitude;\n  var longitude = ref.longitude;\n  var scale = ref.scale;\n\n  // Approximately 111km per degree at equator\n  var METERS_PER_DEGREE = 111000;\n\n  var latCosine = Math.cos(latitude * Math.PI / 180);\n\n  var metersPerDegree = METERS_PER_DEGREE * latCosine;\n\n  // Calculate number of pixels occupied by one degree longitude\n  // around current lat/lon\n  var pixelsPerDegreeX = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec2\"].distance(projectFlat([longitude + 0.5, latitude]), projectFlat([longitude - 0.5, latitude]));\n  // Calculate number of pixels occupied by one degree latitude\n  // around current lat/lon\n  var pixelsPerDegreeY = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec2\"].distance(projectFlat([longitude, latitude + 0.5]), projectFlat([longitude, latitude - 0.5]));\n\n  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;\n  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;\n  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;\n  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];\n\n  var worldSize = TILE_SIZE * scale;\n  var altPixelsPerMeter = worldSize / (4e7 * latCosine);\n  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];\n  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];\n\n  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];\n  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return {\n    pixelsPerMeter: pixelsPerMeter,\n    metersPerPixel: metersPerPixel,\n    pixelsPerDegree: pixelsPerDegree,\n    degreesPerPixel: degreesPerPixel\n  };\n}\n\n// ATTRIBUTION:\n// view and projection matrix creation is intentionally kept compatible with\n// mapbox-gl's implementation to ensure that seamless interoperation\n// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\nfunction makeProjectionMatrixFromMercatorParams(ref) {\n  var width = ref.width;\n  var height = ref.height;\n  var pitch = ref.pitch;\n  var altitude = ref.altitude;\n\n  var pitchRadians = pitch * DEGREES_TO_RADIANS;\n\n  // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE\n  // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n  var halfFov = Math.atan(0.5 / altitude);\n  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);\n\n  // Calculate z value of the farthest fragment that should be rendered.\n  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n\n  var projectionMatrix = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].perspective(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"b\" /* createMat4 */])(), 2 * Math.atan(height / 2 / altitude), // fov in radians\n  width / height, // aspect ratio\n  0.1, // near plane\n  farZ * 10.0 // far plane\n  );\n\n  return projectionMatrix;\n}\n\nfunction makeViewMatrixFromMercatorParams(ref) {\n  var width = ref.width;\n  var height = ref.height;\n  var longitude = ref.longitude;\n  var latitude = ref.latitude;\n  var zoom = ref.zoom;\n  var pitch = ref.pitch;\n  var bearing = ref.bearing;\n  var altitude = ref.altitude;\n\n  // Center x, y\n  var scale = Math.pow(2, zoom);\n  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n  var vm = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"b\" /* createMat4 */])();\n\n  // Move camera to altitude\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].translate(vm, vm, [0, 0, -altitude]);\n\n  // After the rotateX, z values are in pixel units. Convert them to\n  // altitude units. 1 altitude unit = the screen height.\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].scale(vm, vm, [1, -1, 1 / height]);\n\n  // Rotate by bearing, and then by pitch (which tilts the view)\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);\n\n  var ref$1 = projectFlat([longitude, latitude], scale);\n  var centerX = ref$1[0];\n  var centerY = ref$1[1];\n\n  var center = [-centerX, -centerY, 0, 1];\n  var viewCenter = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec4\"].transformMat4([], center, vm);\n\n  var vmCentered = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].translate([], vm, [-centerX, -centerY, 0]);\n\n  return {\n    viewMatrix: vmCentered,\n    viewMatrixUncentered: vm,\n    viewCenter: viewCenter\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi92aWV3cG9ydHMvd2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzP2I5MjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggY2FsY3VsYXRpb25zIGZvciBtYXBib3gtanMgc3R5bGVcbi8vIG1hcCB2aWV3IHByb3BlcnRpZXNcbmltcG9ydCBWaWV3cG9ydCwgeyBjcmVhdGVNYXQ0IH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQgeyBtYXQ0LCB2ZWM0LCB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuLy8gQ09OU1RBTlRTXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBQSV80ID0gUEkgLyA0O1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG5jb25zdCBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmNvbnN0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gKDIgKiBQSSk7XG5cbmNvbnN0IERFRkFVTFRfTUFQX1NUQVRFID0ge1xuICBsYXRpdHVkZTogMzcsXG4gIGxvbmdpdHVkZTogLTEyMixcbiAgem9vbTogMTEsXG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJNZXJjYXRvclZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBDcmVhdGVzIHZpZXcvcHJvamVjdGlvbiBtYXRyaWNlcyBmcm9tIG1lcmNhdG9yIHBhcmFtc1xuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuICAgICogTm90ZXM6XG4gICAqICAtIE9ubHkgb25lIG9mIGNlbnRlciBvciBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIGJlIHNwZWNpZmllZFxuICAgKiAgLSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIHdoZW4gXCJtZXJjYXRvclwiIGlzIHRydWVcbiAgICogIC0gQWx0aXR1ZGUgaGFzIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IG1hdGNoZXMgYXNzdW1wdGlvbnMgaW4gbWFwYm94LWdsXG4gICAqICAtIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGZvcmNlZCB0byAxIGlmIHN1cHBsaWVkIGFzIDAsIHRvIGF2b2lkXG4gICAqICAgIGRpdmlzaW9uIGJ5IHplcm8uIFRoaXMgaXMgaW50ZW5kZWQgdG8gcmVkdWNlIHRoZSBidXJkZW4gb2YgYXBwcyB0b1xuICAgKiAgICB0byBjaGVjayB2YWx1ZXMgYmVmb3JlIGluc3RhbnRpYXRpbmcgYSBWaWV3cG9ydC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBtZXJjYXRvckVuYWJsZWRcbiAgfSA9IHt9KSB7XG4gICAgLy8gVmlld3BvcnQgLSBzdXBwb3J0IHVuZGVmaW5lZCBhcmd1bWVudHNcbiAgICB3aWR0aCA9IHdpZHRoICE9PSB1bmRlZmluZWQgPyB3aWR0aCA6IERFRkFVTFRfTUFQX1NUQVRFLndpZHRoO1xuICAgIGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogREVGQVVMVF9NQVBfU1RBVEUuaGVpZ2h0O1xuICAgIHpvb20gPSB6b29tICE9PSB1bmRlZmluZWQgPyB6b29tIDogREVGQVVMVF9NQVBfU1RBVEUuem9vbTtcbiAgICBsYXRpdHVkZSA9IGxhdGl0dWRlICE9PSB1bmRlZmluZWQgPyBsYXRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxhdGl0dWRlO1xuICAgIGxvbmdpdHVkZSA9IGxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkID8gbG9uZ2l0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubG9uZ2l0dWRlO1xuICAgIGJlYXJpbmcgPSBiZWFyaW5nICE9PSB1bmRlZmluZWQgPyBiZWFyaW5nIDogREVGQVVMVF9NQVBfU1RBVEUuYmVhcmluZztcbiAgICBwaXRjaCA9IHBpdGNoICE9PSB1bmRlZmluZWQgPyBwaXRjaCA6IERFRkFVTFRfTUFQX1NUQVRFLnBpdGNoO1xuICAgIGFsdGl0dWRlID0gYWx0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGFsdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUuYWx0aXR1ZGU7XG5cbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwIHRvIGZhY2lsaXRhdGUgaXNvbW9ycGhpYyByZW5kZXIgZXRjXG4gICAgd2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgICAvLyBBbHRpdHVkZSAtIHByZXZlbnQgZGl2aXNpb24gYnkgMFxuICAgIC8vIFRPRE8gLSBqdXN0IHRocm93IGFuIEVycm9yIGluc3RlYWQ/XG4gICAgYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG5cbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlcyA9IGNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGUgfSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB2aWV3TWF0cml4LCB2aWV3TWF0cml4VW5jZW50ZXJlZCwgdmlld0NlbnRlciB9ID0gbWFrZVZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIGRpc3RhbmNlU2NhbGVzXG4gICAgfSk7XG5cbiAgICBzdXBlcih7IHdpZHRoLCBoZWlnaHQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXggfSk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBtYXRyaWNlc1xuICAgIHRoaXMudmlld01hdHJpeFVuY2VudGVyZWQgPSB2aWV3TWF0cml4VW5jZW50ZXJlZDtcbiAgICB0aGlzLnZpZXdDZW50ZXIgPSB2aWV3Q2VudGVyO1xuXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgdGhpcy5fZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcztcblxuICAgIHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMgPSB0aGlzLmdldERpc3RhbmNlU2NhbGVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzID0gdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdCA9IHRoaXMuYWRkTWV0ZXJzVG9MbmdMYXQuYmluZCh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgX3Byb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICBfdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHVucHJvamVjdEZsYXQoeHksIHNjYWxlKTtcbiAgfVxuXG4gIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG1ldGVyIG9mZnNldCB0byBhIGxuZ2xhdCBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBtZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgY29uc3QgeyBwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsIH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YUxuZyA9IHggKiBwaXhlbHNQZXJNZXRlclswXSAqIGRlZ3JlZXNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YUxhdCA9IHkgKiBwaXhlbHNQZXJNZXRlclsxXSAqIGRlZ3JlZXNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFtkZWx0YUxuZywgZGVsdGFMYXRdIDogW2RlbHRhTG5nLCBkZWx0YUxhdCwgel07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBsbmdsYXQgb2Zmc2V0IHRvIGEgbWV0ZXIgb2Zmc2V0XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgZGVsdGFMbmdMYXRaIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKi9cbiAgbG5nTGF0RGVsdGFUb01ldGVycyhkZWx0YUxuZ0xhdFopIHtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IGRlbHRhTG5nTGF0WjtcbiAgICBjb25zdCB7IHBpeGVsc1BlckRlZ3JlZSwgbWV0ZXJzUGVyUGl4ZWwgfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhWCA9IGRlbHRhTG5nICogcGl4ZWxzUGVyRGVncmVlWzBdICogbWV0ZXJzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFZID0gZGVsdGFMYXQgKiBwaXhlbHNQZXJEZWdyZWVbMV0gKiBtZXRlcnNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4gZGVsdGFMbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFtkZWx0YVgsIGRlbHRhWV0gOiBbZGVsdGFYLCBkZWx0YVksIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbWV0ZXIgZGVsdGEgdG8gYSBiYXNlIGxuZ2xhdCBjb29yZGluYXRlLCByZXR1cm5pbmcgYSBuZXcgbG5nbGF0IGFycmF5XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgbG5nTGF0WiAtIGJhc2UgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKi9cbiAgYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gICAgY29uc3QgW2xuZywgbGF0LCBaID0gMF0gPSBsbmdMYXRaO1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eik7XG4gICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyID8gW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdF0gOiBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICBfZ2V0UGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAqIHBlcnNwZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAqL1xuZnVuY3Rpb24gcHJvamVjdEZsYXQoW2xuZywgbGF0XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCB4ID0gc2NhbGUgKiAobGFtYmRhMiArIFBJKTtcbiAgY29uc3QgeSA9IHNjYWxlICogKFBJIC0gTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZnVuY3Rpb24gdW5wcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgY29uc3QgbGFtYmRhMiA9IHggLyBzY2FsZSAtIFBJO1xuICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUEkgLSB5IC8gc2NhbGUpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gKiBkZWdyZWVzIGFuZCBwaXhlbHMuXG4gKiBJbiBtZXJjYXRvciBwcm9qZWN0aW9uIG1vZGUsIHRoZSBkaXN0YW5jZSBzY2FsZXMgdmFyeSBzaWduaWZpY2FudGx5XG4gKiB3aXRoIGxhdGl0dWRlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyh7IGxhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlIH0pIHtcbiAgLy8gQXBwcm94aW1hdGVseSAxMTFrbSBwZXIgZGVncmVlIGF0IGVxdWF0b3JcbiAgY29uc3QgTUVURVJTX1BFUl9ERUdSRUUgPSAxMTEwMDA7XG5cbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBNYXRoLlBJIC8gMTgwKTtcblxuICBjb25zdCBtZXRlcnNQZXJEZWdyZWUgPSBNRVRFUlNfUEVSX0RFR1JFRSAqIGxhdENvc2luZTtcblxuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyLmRpc3RhbmNlKHByb2plY3RGbGF0KFtsb25naXR1ZGUgKyAwLjUsIGxhdGl0dWRlXSksIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSkpO1xuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxhdGl0dWRlXG4gIC8vIGFyb3VuZCBjdXJyZW50IGxhdC9sb25cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWSA9IHZlYzIuZGlzdGFuY2UocHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgKyAwLjVdKSwgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgLSAwLjVdKSk7XG5cbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJYID0gcGl4ZWxzUGVyRGVncmVlWCAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJZID0gcGl4ZWxzUGVyRGVncmVlWSAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJaID0gKHBpeGVsc1Blck1ldGVyWCArIHBpeGVsc1Blck1ldGVyWSkgLyAyO1xuICAvLyBjb25zdCBwaXhlbHNQZXJNZXRlciA9IFtwaXhlbHNQZXJNZXRlclgsIHBpeGVsc1Blck1ldGVyWSwgcGl4ZWxzUGVyTWV0ZXJaXTtcblxuICBjb25zdCB3b3JsZFNpemUgPSBUSUxFX1NJWkUgKiBzY2FsZTtcbiAgY29uc3QgYWx0UGl4ZWxzUGVyTWV0ZXIgPSB3b3JsZFNpemUgLyAoNGU3ICogbGF0Q29zaW5lKTtcbiAgY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlcl07XG4gIGNvbnN0IG1ldGVyc1BlclBpeGVsID0gWzEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gcGl4ZWxzUGVyTWV0ZXJaXTtcblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWUgPSBbcGl4ZWxzUGVyRGVncmVlWCwgcGl4ZWxzUGVyRGVncmVlWSwgcGl4ZWxzUGVyTWV0ZXJaXTtcbiAgY29uc3QgZGVncmVlc1BlclBpeGVsID0gWzEgLyBwaXhlbHNQZXJEZWdyZWVYLCAxIC8gcGl4ZWxzUGVyRGVncmVlWSwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBjb252ZXJ0aW5nIG1ldGVycyB0byBsYXRsbmcgZGVsdGFzIGFuZCBzY2FsaW5nIG9mZnNldHNcbiAgcmV0dXJuIHtcbiAgICBwaXhlbHNQZXJNZXRlcixcbiAgICBtZXRlcnNQZXJQaXhlbCxcbiAgICBwaXhlbHNQZXJEZWdyZWUsXG4gICAgZGVncmVlc1BlclBpeGVsXG4gIH07XG59XG5cbi8vIEFUVFJJQlVUSU9OOlxuLy8gdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaXggY3JlYXRpb24gaXMgaW50ZW50aW9uYWxseSBrZXB0IGNvbXBhdGlibGUgd2l0aFxuLy8gbWFwYm94LWdsJ3MgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIHRoYXQgc2VhbWxlc3MgaW50ZXJvcGVyYXRpb25cbi8vIHdpdGggbWFwYm94IGFuZCByZWFjdC1tYXAtZ2wuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanNcbmZ1bmN0aW9uIG1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGFsdGl0dWRlXG59KSB7XG4gIGNvbnN0IHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuXG4gIC8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSBTUEFDRSBUTyBDTElQU1BBQ0VcbiAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wXG4gIC8vIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgY29uc3QgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPSBNYXRoLnNpbihoYWxmRm92KSAqIGFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMgLSBoYWxmRm92KTtcblxuICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gIGNvbnN0IGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoY3JlYXRlTWF0NCgpLCAyICogTWF0aC5hdGFuKGhlaWdodCAvIDIgLyBhbHRpdHVkZSksIC8vIGZvdiBpbiByYWRpYW5zXG4gIHdpZHRoIC8gaGVpZ2h0LCAvLyBhc3BlY3QgcmF0aW9cbiAgMC4xLCAvLyBuZWFyIHBsYW5lXG4gIGZhclogKiAxMC4wIC8vIGZhciBwbGFuZVxuICApO1xuXG4gIHJldHVybiBwcm9qZWN0aW9uTWF0cml4O1xufVxuXG5mdW5jdGlvbiBtYWtlVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIHpvb20sXG4gIHBpdGNoLFxuICBiZWFyaW5nLFxuICBhbHRpdHVkZVxufSkge1xuICAvLyBDZW50ZXIgeCwgeVxuICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAvLyBWSUVXIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBWSVJUVUFMIFBJWEVMUyBUTyBDQU1FUkEgU1BBQ0VcbiAgLy8gTm90ZTogQXMgdXN1YWwsIG1hdHJpeCBvcGVyYXRpb24gb3JkZXJzIHNob3VsZCBiZSByZWFkIGluIHJldmVyc2VcbiAgLy8gc2luY2UgdmVjdG9ycyB3aWxsIGJlIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uXG4gIGNvbnN0IHZtID0gY3JlYXRlTWF0NCgpO1xuXG4gIC8vIE1vdmUgY2FtZXJhIHRvIGFsdGl0dWRlXG4gIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC1hbHRpdHVkZV0pO1xuXG4gIC8vIEFmdGVyIHRoZSByb3RhdGVYLCB6IHZhbHVlcyBhcmUgaW4gcGl4ZWwgdW5pdHMuIENvbnZlcnQgdGhlbSB0b1xuICAvLyBhbHRpdHVkZSB1bml0cy4gMSBhbHRpdHVkZSB1bml0ID0gdGhlIHNjcmVlbiBoZWlnaHQuXG4gIG1hdDQuc2NhbGUodm0sIHZtLCBbMSwgLTEsIDEgLyBoZWlnaHRdKTtcblxuICAvLyBSb3RhdGUgYnkgYmVhcmluZywgYW5kIHRoZW4gYnkgcGl0Y2ggKHdoaWNoIHRpbHRzIHRoZSB2aWV3KVxuICBtYXQ0LnJvdGF0ZVgodm0sIHZtLCBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIG1hdDQucm90YXRlWih2bSwgdm0sIC1iZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICBjb25zdCBbY2VudGVyWCwgY2VudGVyWV0gPSBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcblxuICBjb25zdCBjZW50ZXIgPSBbLWNlbnRlclgsIC1jZW50ZXJZLCAwLCAxXTtcbiAgY29uc3Qgdmlld0NlbnRlciA9IHZlYzQudHJhbnNmb3JtTWF0NChbXSwgY2VudGVyLCB2bSk7XG5cbiAgY29uc3Qgdm1DZW50ZXJlZCA9IG1hdDQudHJhbnNsYXRlKFtdLCB2bSwgWy1jZW50ZXJYLCAtY2VudGVyWSwgMF0pO1xuXG4gIHJldHVybiB7XG4gICAgdmlld01hdHJpeDogdm1DZW50ZXJlZCxcbiAgICB2aWV3TWF0cml4VW5jZW50ZXJlZDogdm0sXG4gICAgdmlld0NlbnRlclxuICB9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUE0Q0E7QUFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQURBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBck1BO0FBQ0E7QUFvTUE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 57 */
/* exports provided: default */
/* exports used: default */
/*!*************************************!*\
  !*** ./src/react/webgl-renderer.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__autobind__ = __webpack_require__(/*! ./autobind */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\n\n/* global requestAnimationFrame, cancelAnimationFrame */\n\nvar DEFAULT_PIXEL_RATIO = typeof window !== 'undefined' && window.devicePixelRatio || 1;\n\nvar propTypes = {\n  id: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].string.isRequired,\n\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  style: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n\n  pixelRatio: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number,\n  viewport: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object.isRequired,\n  events: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  gl: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  glOptions: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  debug: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].bool,\n\n  onInitializationFailed: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onRendererInitialized: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func.isRequired,\n  onRenderFrame: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseMove: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nvar defaultProps = {\n  style: {},\n  gl: null,\n  glOptions: { preserveDrawingBuffer: true },\n  debug: false,\n  pixelRatio: DEFAULT_PIXEL_RATIO,\n\n  onInitializationFailed: function (error) {\n    throw error;\n  },\n  onRendererInitialized: function () {},\n  onRenderFrame: function () {}\n};\n\nvar WebGLRenderer = (function (superclass) {\n  function WebGLRenderer(props) {\n    superclass.call(this, props);\n    this.state = {};\n    this._animationFrame = null;\n    this.gl = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__autobind__[\"a\" /* default */])(this);\n  }\n\n  if ( superclass ) WebGLRenderer.__proto__ = superclass;\n  WebGLRenderer.prototype = Object.create( superclass && superclass.prototype );\n  WebGLRenderer.prototype.constructor = WebGLRenderer;\n\n  WebGLRenderer.prototype.componentDidMount = function componentDidMount () {\n    var canvas = this.refs.overlay;\n    this._initWebGL(canvas);\n    this._animationLoop();\n  };\n\n  WebGLRenderer.prototype.componentWillUnmount = function componentWillUnmount () {\n    this._cancelAnimationLoop();\n  };\n\n  /**\n   * Initialize LumaGL library and through it WebGL\n   * @param {string} canvas\n   */\n  WebGLRenderer.prototype._initWebGL = function _initWebGL (canvas) {\n    var ref = this.props;\n    var debug = ref.debug;\n    var glOptions = ref.glOptions;\n\n    // Create context if not supplied\n    var gl = this.props.gl;\n    if (!gl) {\n      try {\n        gl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"createGLContext\"])(Object.assign({ canvas: canvas, debug: debug }, glOptions));\n      } catch (error) {\n        this.props.onInitializationFailed(error);\n        return;\n      }\n    }\n\n    this.gl = gl;\n\n    // Call callback last, in case it throws\n    this.props.onRendererInitialized({ canvas: canvas, gl: gl });\n  };\n\n  /**\n   * Main WebGL animation loop\n   */\n  WebGLRenderer.prototype._animationLoop = function _animationLoop () {\n    this._renderFrame();\n    // Keep registering ourselves for the next animation frame\n    if (typeof window !== 'undefined') {\n      this._animationFrame = requestAnimationFrame(this._animationLoop);\n    }\n  };\n\n  WebGLRenderer.prototype._cancelAnimationLoop = function _cancelAnimationLoop () {\n    if (this._animationFrame) {\n      cancelAnimationFrame(this._animationFrame);\n    }\n  };\n\n  // Updates WebGL viewport to latest props\n  // for clean logging, only calls gl.viewport if props have changed\n  WebGLRenderer.prototype._updateGLViewport = function _updateGLViewport () {\n    var ref = this.props;\n    var ref_viewport = ref.viewport;\n    var x = ref_viewport.x;\n    var y = ref_viewport.y;\n    var w = ref_viewport.width;\n    var h = ref_viewport.height;\n    var ref$1 = this.props;\n    var dpr = ref$1.pixelRatio;\n    var ref$2 = this;\n    var gl = ref$2.gl;\n\n    x = x * dpr;\n    y = y * dpr;\n    w = w * dpr;\n    h = h * dpr;\n\n    if (x !== this.x || y !== this.y || w !== this.w || h !== this.h) {\n      gl.viewport(x, y, w, h);\n      this.x = x;\n      this.y = y;\n      this.w = w;\n      this.h = h;\n    }\n  };\n\n  WebGLRenderer.prototype._renderFrame = function _renderFrame () {\n    var ref = this.props;\n    var ref_viewport = ref.viewport;\n    var width = ref_viewport.width;\n    var height = ref_viewport.height;\n    var ref$1 = this;\n    var gl = ref$1.gl;\n\n    // Check for reasons not to draw\n    if (!gl || !(width > 0) || !(height > 0)) {\n      return;\n    }\n\n    this._updateGLViewport();\n\n    // Call render callback\n    this.props.onRenderFrame({ gl: gl });\n  };\n\n  WebGLRenderer.prototype.render = function render () {\n    var ref = this.props;\n    var id = ref.id;\n    var width = ref.width;\n    var height = ref.height;\n    var pixelRatio = ref.pixelRatio;\n    var style = ref.style;\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"])('canvas', {\n      ref: 'overlay',\n      key: 'overlay',\n      id: id,\n      width: width * pixelRatio,\n      height: height * pixelRatio,\n      style: Object.assign({}, style, { width: width, height: height })\n    });\n  };\n\n  return WebGLRenderer;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));\n\n/* harmony default export */ exports[\"a\"] = WebGLRenderer;\n\nWebGLRenderer.propTypes = propTypes;\nWebGLRenderer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3JlYWN0L3dlYmdsLXJlbmRlcmVyLmpzPzFlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcywgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuL2F1dG9iaW5kJztcbmltcG9ydCB7IGNyZWF0ZUdMQ29udGV4dCB9IGZyb20gJ2x1bWEuZ2wnO1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUgKi9cblxuY29uc3QgREVGQVVMVF9QSVhFTF9SQVRJTyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgcGl4ZWxSYXRpbzogUHJvcFR5cGVzLm51bWJlcixcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICBnbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgZ2xPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgb25Jbml0aWFsaXphdGlvbkZhaWxlZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uUmVuZGVyZXJJbml0aWFsaXplZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25SZW5kZXJGcmFtZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc3R5bGU6IHt9LFxuICBnbDogbnVsbCxcbiAgZ2xPcHRpb25zOiB7IHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSB9LFxuICBkZWJ1ZzogZmFsc2UsXG4gIHBpeGVsUmF0aW86IERFRkFVTFRfUElYRUxfUkFUSU8sXG5cbiAgb25Jbml0aWFsaXphdGlvbkZhaWxlZDogZXJyb3IgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9LFxuICBvblJlbmRlcmVySW5pdGlhbGl6ZWQ6ICgpID0+IHt9LFxuICBvblJlbmRlckZyYW1lOiAoKSA9PiB7fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFNtYWxsIHJlYWN0IGNvbXBvbmVudCB0aGF0IHVzZXMgTHVtYS5HTCB0byBpbml0aWFsaXplIGEgV2ViR0wgY29udGV4dC5cbiAgICpcbiAgICogUmV0dXJucyBhIGNhbnZhcywgY3JlYXRlcyBhIGJhc2ljIFdlYkdMIGNvbnRleHRcbiAgICogc2V0cyB1cCBhIHJlbmRlcmxvb3AsIGFuZCByZWdpc3RlcnMgc29tZSBiYXNpYyBldmVudCBoYW5kbGVyc1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gc2VlIHByb3BUeXBlcyBkb2N1bWVudGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5fYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZWZzLm92ZXJsYXk7XG4gICAgdGhpcy5faW5pdFdlYkdMKGNhbnZhcyk7XG4gICAgdGhpcy5fYW5pbWF0aW9uTG9vcCgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uTG9vcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgTHVtYUdMIGxpYnJhcnkgYW5kIHRocm91Z2ggaXQgV2ViR0xcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbnZhc1xuICAgKi9cbiAgX2luaXRXZWJHTChjYW52YXMpIHtcbiAgICBjb25zdCB7IGRlYnVnLCBnbE9wdGlvbnMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBDcmVhdGUgY29udGV4dCBpZiBub3Qgc3VwcGxpZWRcbiAgICBsZXQgZ2wgPSB0aGlzLnByb3BzLmdsO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdsID0gY3JlYXRlR0xDb250ZXh0KE9iamVjdC5hc3NpZ24oeyBjYW52YXMsIGRlYnVnIH0sIGdsT3B0aW9ucykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkluaXRpYWxpemF0aW9uRmFpbGVkKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vIENhbGwgY2FsbGJhY2sgbGFzdCwgaW4gY2FzZSBpdCB0aHJvd3NcbiAgICB0aGlzLnByb3BzLm9uUmVuZGVyZXJJbml0aWFsaXplZCh7IGNhbnZhcywgZ2wgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBXZWJHTCBhbmltYXRpb24gbG9vcFxuICAgKi9cbiAgX2FuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5fcmVuZGVyRnJhbWUoKTtcbiAgICAvLyBLZWVwIHJlZ2lzdGVyaW5nIG91cnNlbHZlcyBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25Mb29wKTtcbiAgICB9XG4gIH1cblxuICBfY2FuY2VsQW5pbWF0aW9uTG9vcCgpIHtcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGVzIFdlYkdMIHZpZXdwb3J0IHRvIGxhdGVzdCBwcm9wc1xuICAvLyBmb3IgY2xlYW4gbG9nZ2luZywgb25seSBjYWxscyBnbC52aWV3cG9ydCBpZiBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgX3VwZGF0ZUdMVmlld3BvcnQoKSB7XG4gICAgbGV0IHsgdmlld3BvcnQ6IHsgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCB9IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcGl4ZWxSYXRpbzogZHByIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG5cbiAgICB4ID0geCAqIGRwcjtcbiAgICB5ID0geSAqIGRwcjtcbiAgICB3ID0gdyAqIGRwcjtcbiAgICBoID0gaCAqIGRwcjtcblxuICAgIGlmICh4ICE9PSB0aGlzLnggfHwgeSAhPT0gdGhpcy55IHx8IHcgIT09IHRoaXMudyB8fCBoICE9PSB0aGlzLmgpIHtcbiAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHcsIGgpO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLncgPSB3O1xuICAgICAgdGhpcy5oID0gaDtcbiAgICB9XG4gIH1cblxuICBfcmVuZGVyRnJhbWUoKSB7XG4gICAgY29uc3QgeyB2aWV3cG9ydDogeyB3aWR0aCwgaGVpZ2h0IH0gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcblxuICAgIC8vIENoZWNrIGZvciByZWFzb25zIG5vdCB0byBkcmF3XG4gICAgaWYgKCFnbCB8fCAhKHdpZHRoID4gMCkgfHwgIShoZWlnaHQgPiAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUdMVmlld3BvcnQoKTtcblxuICAgIC8vIENhbGwgcmVuZGVyIGNhbGxiYWNrXG4gICAgdGhpcy5wcm9wcy5vblJlbmRlckZyYW1lKHsgZ2wgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpZCwgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbywgc3R5bGUgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHJlZjogJ292ZXJsYXknLFxuICAgICAga2V5OiAnb3ZlcmxheScsXG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiB3aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICBoZWlnaHQ6IGhlaWdodCAqIHBpeGVsUmF0aW8sXG4gICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgd2lkdGgsIGhlaWdodCB9KVxuICAgIH0pO1xuICB9XG59XG5cbldlYkdMUmVuZGVyZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuV2ViR0xSZW5kZXJlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9yZWFjdC93ZWJnbC1yZW5kZXJlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFySEE7QUFDQTtBQW9IQTtBQUNBO0FBQ0E7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 58 */
/* exports provided: checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/* exports used: checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/*!**********************************************!*\
  !*** ./src/shader-utils/assemble-shaders.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(/*! ./shader-chunks */ 59);\n/* harmony export (immutable) */ exports[\"a\"] = checkRendererVendor;\n/* harmony export (immutable) */ exports[\"b\"] = getPlatformShaderDefines;\n/* harmony export (immutable) */ exports[\"c\"] = assembleShaders;\n\n\n// Load shader chunks\n// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';\n\n\nfunction checkRendererVendor(debugInfo, gpuVendor) {\n  var vendor = debugInfo.vendor;\n  var renderer = debugInfo.renderer;\n  var result;\n  switch (gpuVendor) {\n    case 'nvidia':\n      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);\n      break;\n    case 'intel':\n      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);\n      break;\n    case 'amd':\n      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);\n      break;\n    default:\n      result = false;\n  }\n  return result;\n}\n\nfunction getPlatformShaderDefines(gl) {\n  /* eslint-disable */\n  var platformDefines = '';\n  var debugInfo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glGetDebugInfo\"])(gl);\n\n  if (checkRendererVendor(debugInfo, 'nvidia')) {\n    platformDefines += \"#define NVIDIA_GPU\\n#define NVIDIA_FP64_WORKAROUND 1\\n#define NVIDIA_EQUATION_WORKAROUND 1\\n\";\n  } else if (checkRendererVendor(debugInfo, 'intel')) {\n    platformDefines += \"#define INTEL_GPU\\n#define INTEL_FP64_WORKAROUND 1\\n#define NVIDIA_EQUATION_WORKAROUND 1\\n #define INTEL_TAN_WORKAROUND 1\\n\";\n  } else if (checkRendererVendor(debugInfo, 'amd')) {\n    platformDefines += \"#define AMD_GPU\\n\";\n  } else {\n    platformDefines += \"#define DEFAULT_GPU\\n\";\n  }\n\n  return platformDefines;\n}\n\nfunction assembleShader(gl, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  var vs = opts.vs;\n  var project = opts.project; if ( project === void 0 ) project = true;\n  var project64 = opts.project64; if ( project64 === void 0 ) project64 = false;\n  var fp64 = opts.fp64; if ( fp64 === void 0 ) fp64 = false;\n  if (project64 === true) {\n    fp64 = true;\n  }\n  var source = (getPlatformShaderDefines(gl)) + \"\\n\";\n  opts = Object.assign({}, opts, { project: project, project64: project64, fp64: fp64 });\n  for (var i = 0, list = Object.keys(__WEBPACK_IMPORTED_MODULE_1__shader_chunks__); i < list.length; i += 1) {\n    var chunkName = list[i];\n\n    if (opts[chunkName]) {\n      source += (__WEBPACK_IMPORTED_MODULE_1__shader_chunks__[chunkName].source) + \"\\n\";\n    }\n  }\n  source += vs;\n  return source;\n}\n\nfunction assembleShaders(gl, opts) {\n  return {\n    gl: gl,\n    vs: assembleShader(gl, opts),\n    fs: opts.fs\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NoYWRlci11dGlscy9hc3NlbWJsZS1zaGFkZXJzLmpzP2VmYWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2xHZXREZWJ1Z0luZm8gfSBmcm9tICdsdW1hLmdsJztcblxuLy8gTG9hZCBzaGFkZXIgY2h1bmtzXG4vLyBpbXBvcnQgU0hBREVSX0NIVU5LUyBmcm9tICcuLi8uLi9kaXN0L3NoYWRlcmxpYi9zaGFkZXItY2h1bmtzJztcbmltcG9ydCAqIGFzIFNIQURFUl9DSFVOS1MgZnJvbSAnLi9zaGFkZXItY2h1bmtzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCBncHVWZW5kb3IpIHtcbiAgY29uc3QgeyB2ZW5kb3IsIHJlbmRlcmVyIH0gPSBkZWJ1Z0luZm87XG4gIGxldCByZXN1bHQ7XG4gIHN3aXRjaCAoZ3B1VmVuZG9yKSB7XG4gICAgY2FzZSAnbnZpZGlhJzpcbiAgICAgIHJlc3VsdCA9IHZlbmRvci5tYXRjaCgvTlZJRElBL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9OVklESUEvaSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnRlbCc6XG4gICAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL0lOVEVML2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9JTlRFTC9pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FtZCc6XG4gICAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL0FNRC9pKSB8fCByZW5kZXJlci5tYXRjaCgvQU1EL2kpIHx8IHZlbmRvci5tYXRjaCgvQVRJL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BVEkvaSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICBsZXQgcGxhdGZvcm1EZWZpbmVzID0gJyc7XG4gIGNvbnN0IGRlYnVnSW5mbyA9IGdsR2V0RGVidWdJbmZvKGdsKTtcblxuICBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdudmlkaWEnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgTlZJRElBX0dQVVxuI2RlZmluZSBOVklESUFfRlA2NF9XT1JLQVJPVU5EIDFcbiNkZWZpbmUgTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQgMVxuYDtcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2ludGVsJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIElOVEVMX0dQVVxuI2RlZmluZSBJTlRFTF9GUDY0X1dPUktBUk9VTkQgMVxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXFxuIFxcXG4jZGVmaW5lIElOVEVMX1RBTl9XT1JLQVJPVU5EIDFcbmA7XG4gIH0gZWxzZSBpZiAoY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sICdhbWQnKSkge1xuICAgIHBsYXRmb3JtRGVmaW5lcyArPSBgXFxcbiNkZWZpbmUgQU1EX0dQVVxuYDtcbiAgfSBlbHNlIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gYFxcXG4jZGVmaW5lIERFRkFVTFRfR1BVXG5gO1xuICB9XG5cbiAgcmV0dXJuIHBsYXRmb3JtRGVmaW5lcztcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHZzLCBwcm9qZWN0ID0gdHJ1ZSwgcHJvamVjdDY0ID0gZmFsc2UgfSA9IG9wdHM7XG4gIGxldCB7IGZwNjQgPSBmYWxzZSB9ID0gb3B0cztcbiAgaWYgKHByb2plY3Q2NCA9PT0gdHJ1ZSkge1xuICAgIGZwNjQgPSB0cnVlO1xuICB9XG4gIGxldCBzb3VyY2UgPSBgJHsgZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzKGdsKSB9XFxuYDtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHsgcHJvamVjdCwgcHJvamVjdDY0LCBmcDY0IH0pO1xuICBmb3IgKGNvbnN0IGNodW5rTmFtZSBvZiBPYmplY3Qua2V5cyhTSEFERVJfQ0hVTktTKSkge1xuICAgIGlmIChvcHRzW2NodW5rTmFtZV0pIHtcbiAgICAgIHNvdXJjZSArPSBgJHsgU0hBREVSX0NIVU5LU1tjaHVua05hbWVdLnNvdXJjZSB9XFxuYDtcbiAgICB9XG4gIH1cbiAgc291cmNlICs9IHZzO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXJzKGdsLCBvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgZ2wsXG4gICAgdnM6IGFzc2VtYmxlU2hhZGVyKGdsLCBvcHRzKSxcbiAgICBmczogb3B0cy5mc1xuICB9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc2hhZGVyLXV0aWxzL2Fzc2VtYmxlLXNoYWRlcnMuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 59 */
/* exports provided: fp64, project, project64 */
/* all exports used */
/*!*******************************************!*\
  !*** ./src/shader-utils/shader-chunks.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__ = __webpack_require__(/*! ../shaderlib/fp64 */ 60);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"fp64\", function() { return __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__ = __webpack_require__(/*! ../shaderlib/project */ 61);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"project\", function() { return __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__ = __webpack_require__(/*! ../shaderlib/project64 */ 62);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"project64\", function() { return __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__[\"a\"]; });\n// Load shader chunks\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NoYWRlci11dGlscy9zaGFkZXItY2h1bmtzLmpzPzNmZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTG9hZCBzaGFkZXIgY2h1bmtzXG5leHBvcnQgKiBmcm9tICcuLi9zaGFkZXJsaWIvZnA2NCc7XG5leHBvcnQgKiBmcm9tICcuLi9zaGFkZXJsaWIvcHJvamVjdCc7XG5leHBvcnQgKiBmcm9tICcuLi9zaGFkZXJsaWIvcHJvamVjdDY0JztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NoYWRlci11dGlscy9zaGFkZXItY2h1bmtzLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 60 */
/* exports provided: fp64 */
/* exports used: fp64 */
/*!*************************************!*\
  !*** ./src/shaderlib/fp64/index.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(exports, \"a\", function() { return fp64; });\n\n\nvar fp64 = {\n  interface: 'fp64',\n  source: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\nuniform float ONE;\\n\\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\\n\\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\\n\\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\\n\\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\\n\\nfloat nint(float d) {\\n    if (d == floor(d)) return d;\\n    return floor(d + 0.5);\\n}\\n\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\nvec2 split(float a) {\\n  const float SPLIT = 4097.0;\\n  float t = a * SPLIT;\\n  float a_hi = t * ONE - (t - a);\\n  float a_lo = a * ONE - a_hi;\\n  return vec2(a_hi, a_lo);\\n}\\n#else\\nvec2 split(float a) {\\n  const float SPLIT = 4097.0;\\n  float t = a * SPLIT;\\n  float a_hi = t - (t - a);\\n  float a_lo = a - a_hi;\\n  return vec2(a_hi, a_lo);\\n}\\n#endif\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\nvec2 quickTwoSum(float a, float b) {\\n  float sum = (a + b) * ONE;\\n  float err = b - (sum - a) * ONE;\\n  return vec2(sum, err);\\n}\\n#else\\nvec2 quickTwoSum(float a, float b) {\\n  float sum = a + b;\\n  float err = b - (sum - a);\\n  return vec2(sum, err);\\n}\\n#endif\\n\\nvec2 nint_fp64(vec2 a) {\\n    float hi = nint(a.x);\\n    float lo;\\n    vec2 tmp;\\n    if (hi == a.x) {\\n        lo = nint(a.y);\\n        tmp = quickTwoSum(hi, lo);\\n    } else {\\n        lo = 0.0;\\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\\n            hi -= 1.0;\\n        }\\n        tmp = vec2(hi, lo);\\n    }\\n    return tmp;\\n}\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\nvec2 twoSum(float a, float b) {\\n  float s = (a + b) * ONE;\\n  float v = (s - a);\\n  float err = (a - (s - v) * ONE) * ONE + (b - v);\\n  return vec2(s, err);\\n}\\n#else\\nvec2 twoSum(float a, float b) {\\n  float s = a + b;\\n  float v = s - a;\\n  float err = (a - (s - v)) + (b - v);\\n  return vec2(s, err);\\n}\\n#endif\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\nvec2 twoSub(float a, float b) {\\n  float s = (a - b) * ONE;\\n  float v = (s - a);\\n  float err = (a - (s - v) * ONE) * ONE - (b + v);\\n  return vec2(s, err);\\n}\\n#else\\nvec2 twoSub(float a, float b) {\\n  float s = a - b;\\n  float v = s - a;\\n  float err = (a - (s - v)) - (b + v);\\n  return vec2(s, err);\\n}\\n#endif\\n\\nvec2 twoProd(float a, float b) {\\n  float prod = a * b;\\n  vec2 a_fp64 = split(a);\\n  vec2 b_fp64 = split(b);\\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\\n  return vec2(prod, err);\\n}\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\nvec2 twoSqr(float a) {\\n  float prod = a * a;\\n  vec2 a_fp64 = split(a);\\n\\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x * a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\\n  return vec2(prod, err);\\n}\\n#else\\nvec2 twoSqr(float a) {\\n  float prod = a * a;\\n  vec2 a_fp64 = split(a);\\n\\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\\n  return vec2(prod, err);\\n}\\n#endif\\n\\nvec2 sum_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSum(a.x, b.x);\\n  t = twoSum(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 sub_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSub(a.x, b.x);\\n  t = twoSub(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 mul_fp64(vec2 a, vec2 b) {\\n  vec2 prod = twoProd(a.x, b.x);\\n  // y component is for the error\\n  prod.y += a.x * b.y;\\n  prod.y += a.y * b.x;\\n  prod = quickTwoSum(prod.x, prod.y);\\n  return prod;\\n}\\n\\nvec2 div_fp64(vec2 a, vec2 b) {\\n  float xn = 1.0 / b.x;\\n  vec2 yn = a * xn;\\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\\n  vec2 prod = twoProd(xn, diff);\\n  return sum_fp64(yn, prod);\\n}\\n\\nvec2 sqrt_fp64(vec2 a) {\\n\\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\\n\\n  float x = 1.0 / sqrt(a.x);\\n  float yn = a.x * x;\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\n  vec2 yn_sqr = twoSqr(yn) * ONE;\\n#else\\n  vec2 yn_sqr = twoSqr(yn);\\n#endif\\n  float diff = sub_fp64(a, yn_sqr).x;\\n  vec2 prod = twoProd(x * 0.5, diff);\\n  return sum_fp64(vec2(yn, 0.0), prod);\\n}\\n\\nvec2 exp_fp64(vec2 a) {\\n  const float k = 512.0;\\n  const float inv_k = 1.0 / k;\\n\\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\\n\\n  // Range reduction using assume a = kr + m * log(2), k and m being integers.\\n  // Set k = 9 (we can choose other k to trade accuracy with performance.\\n  // we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k\\n\\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\\n  vec2 s, t, p;\\n\\n  p = mul_fp64(r, r);\\n  s = sum_fp64(r, p * 0.5);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\\n\\n  s = sum_fp64(s, t);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\\n\\n  s = sum_fp64(s, t);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\\n\\n  s = sum_fp64(s, t);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\\n\\n  s = sum_fp64(s, t);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\\n\\n  s = sum_fp64(s, t);\\n\\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\\n\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n\\n  // We can add more iterations here and increase k.\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\n  s = sum_fp64(s, vec2(1.0, 0.0) * ONE);\\n#else\\n  s = sum_fp64(s, vec2(1.0, 0.0));\\n#endif\\n\\n  return s * pow(2.0, m);\\n//   return r;\\n}\\n\\nvec2 log_fp64(vec2 a)\\n{\\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\\n  vec2 x = vec2(log(a.x), 0.0);\\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), vec2(1.0, 0.0));\\n  return x;\\n}\\n\\nvec2 sin_taylor_fp64(vec2 a) {\\n  vec2 r, s, t, x;\\n\\n  if (a.x == 0.0 && a.y == 0.0) {\\n    return vec2(0.0, 0.0);\\n  }\\n\\n  x = -mul_fp64(a, a);\\n  s = a;\\n  r = a;\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\\n  s = sum_fp64(s, t);\\n\\n  return s;\\n}\\n\\nvec2 cos_taylor_fp64(vec2 a) {\\n  vec2 r, s, t, x;\\n\\n  if (a.x == 0.0 && a.y == 0.0) {\\n    return vec2(1.0, 0.0);\\n  }\\n\\n  x = -mul_fp64(a, a);\\n  r = x;\\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\\n  s = sum_fp64(s, t);\\n\\n  return s;\\n}\\n\\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\\n  if (a.x == 0.0 && a.y == 0.0) {\\n    sin_t = vec2(0.0, 0.0);\\n    cos_t = vec2(1.0, 0.0);\\n  }\\n\\n  sin_t = sin_taylor_fp64(a);\\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\\n}\\n\\nvec2 sin_fp64(vec2 a) {\\n    if (a.x == 0.0 && a.y == 0.0) {\\n        return vec2(0.0, 0.0);\\n    }\\n\\n    // 2pi range reduction\\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\\n\\n    vec2 t;\\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    }\\n\\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\\n\\n    q = floor(t.x / PI_16_FP64.x + 0.5);\\n    int k = int(q);\\n\\n    if (k == 0) {\\n        if (j == 0) {\\n            return sin_taylor_fp64(t);\\n        } else if (j == 1) {\\n            return cos_taylor_fp64(t);\\n        } else if (j == -1) {\\n            return -cos_taylor_fp64(t);\\n        } else {\\n            return -sin_taylor_fp64(t);\\n        }\\n    }\\n\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    } else if (k == 3) {\\n        t = sub_fp64(t, PI_16_3_FP64);\\n    } else if (k == -3) {\\n        t = sum_fp64(t, PI_16_3_FP64);\\n    } else {\\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\\n    }\\n\\n    vec2 u = vec2(0.0, 0.0);\\n    vec2 v = vec2(0.0, 0.0);\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n    if (abs(float(abs_k) - 1.0) < 0.5) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#else\\n    if (abs_k == 1) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs_k == 2) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs_k == 3) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs_k == 4) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#endif\\n\\n    vec2 sin_t, cos_t;\\n    sincos_taylor_fp64(t, sin_t, cos_t);\\n\\n    vec2 result = vec2(0.0, 0.0);\\n    if (j == 0) {\\n        if (k > 0) {\\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        }\\n    } else if (j == 1) {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        } else {\\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    } else if (j == -1) {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\\n        } else {\\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\\n        }\\n    } else {\\n        if (k > 0) {\\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nvec2 cos_fp64(vec2 a) {\\n    if (a.x == 0.0 && a.y == 0.0) {\\n        return vec2(1.0, 0.0);\\n    }\\n\\n    // 2pi range reduction\\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\\n\\n    vec2 t;\\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    }\\n\\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\\n\\n    q = floor(t.x / PI_16_FP64.x + 0.5);\\n    int k = int(q);\\n\\n    if (k == 0) {\\n        if (j == 0) {\\n            return cos_taylor_fp64(t);\\n        } else if (j == 1) {\\n            return -sin_taylor_fp64(t);\\n        } else if (j == -1) {\\n            return sin_taylor_fp64(t);\\n        } else {\\n            return -cos_taylor_fp64(t);\\n        }\\n    }\\n\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    } else if (k == 3) {\\n        t = sub_fp64(t, PI_16_3_FP64);\\n    } else if (k == -3) {\\n        t = sum_fp64(t, PI_16_3_FP64);\\n    } else {\\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\\n    }\\n\\n    vec2 u = vec2(0.0, 0.0);\\n    vec2 v = vec2(0.0, 0.0);\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n    if (abs(float(abs_k) - 1.0) < 0.5) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#else\\n    if (abs_k == 1) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs_k == 2) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs_k == 3) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs_k == 4) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#endif\\n\\n    vec2 sin_t, cos_t;\\n    sincos_taylor_fp64(t, sin_t, cos_t);\\n\\n    vec2 result = vec2(0.0, 0.0);\\n    if (j == 0) {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        } else {\\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    } else if (j == 1) {\\n        if (k > 0) {\\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\\n        }\\n    } else if (j == -1) {\\n        if (k > 0) {\\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        }\\n    } else {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\\n        } else {\\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nvec2 tan_fp64(vec2 a) {\\n    vec2 sin_a;\\n    vec2 cos_a;\\n\\n    if (a.x == 0.0 && a.y == 0.0) {\\n        return vec2(0.0, 0.0);\\n    }\\n\\n    // 2pi range reduction\\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\\n\\n    vec2 t;\\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\\n    int j = int(q);\\n\\n\\n    if (j < -2 || j > 2) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    }\\n\\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\\n\\n    q = floor(t.x / PI_16_FP64.x + 0.5);\\n    int k = int(q);\\n    int abs_k = int(abs(float(k)));\\n\\n    // We just can\\'t get PI/16 * 3.0 very accurately.\\n    // so let\\'s just store it\\n    if (abs_k > 4) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    } else if (k == 3) {\\n        t = sub_fp64(t, PI_16_3_FP64);\\n    } else if (k == -3) {\\n        t = sum_fp64(t, PI_16_3_FP64);\\n    } else {\\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\\n    }\\n\\n\\n    vec2 u = vec2(0.0, 0.0);\\n    vec2 v = vec2(0.0, 0.0);\\n\\n    vec2 sin_t, cos_t;\\n    vec2 s, c;\\n    sincos_taylor_fp64(t, sin_t, cos_t);\\n\\n    if (k == 0) {\\n        s = sin_t;\\n        c = cos_t;\\n    } else {\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n        if (abs(float(abs_k) - 1.0) < 0.5) {\\n            u = COS_TABLE_0_FP64;\\n            v = SIN_TABLE_0_FP64;\\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n            u = COS_TABLE_1_FP64;\\n            v = SIN_TABLE_1_FP64;\\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n            u = COS_TABLE_2_FP64;\\n            v = SIN_TABLE_2_FP64;\\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n            u = COS_TABLE_3_FP64;\\n            v = SIN_TABLE_3_FP64;\\n        }\\n#else\\n        if (abs_k == 1) {\\n            u = COS_TABLE_0_FP64;\\n            v = SIN_TABLE_0_FP64;\\n        } else if (abs_k == 2) {\\n            u = COS_TABLE_1_FP64;\\n            v = SIN_TABLE_1_FP64;\\n        } else if (abs_k == 3) {\\n            u = COS_TABLE_2_FP64;\\n            v = SIN_TABLE_2_FP64;\\n        } else if (abs_k == 4) {\\n            u = COS_TABLE_3_FP64;\\n            v = SIN_TABLE_3_FP64;\\n        }\\n#endif\\n        if (k > 0) {\\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        } else {\\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    }\\n\\n    if (j == 0) {\\n        sin_a = s;\\n        cos_a = c;\\n    } else if (j == 1) {\\n        sin_a = c;\\n        cos_a = -s;\\n    } else if (j == -1) {\\n        sin_a = -c;\\n        cos_a = s;\\n    } else {\\n        sin_a = -s;\\n        cos_a = -c;\\n    }\\n    return div_fp64(sin_a, cos_a);\\n}\\n\\nvec2 radians_fp64(vec2 degree) {\\n  return div_fp64(mul_fp64(degree, PI_FP64), vec2(180.0, 0.0));\\n}\\n\\n// Vector functions\\n// vec2 functions\\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\\n    out_val[0] = sum_fp64(a[0], b[0]);\\n    out_val[1] = sum_fp64(a[1], b[1]);\\n}\\n\\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\\n    out_val[0] = sub_fp64(a[0], b[0]);\\n    out_val[1] = sub_fp64(a[1], b[1]);\\n}\\n\\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\\n  vec2 range[2];\\n  vec2_sub_fp64(y, x, range);\\n  vec2 portion[2];\\n  portion[0] = range[0] * a;\\n  portion[1] = range[1] * a;\\n  vec2_sum_fp64(x, portion, out_val);\\n}\\n\\nvec2 vec2_length_fp64(vec2 x[2]) {\\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\\n}\\n\\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\\n  vec2 diff[2];\\n  vec2_sub_fp64(x, y, diff);\\n  return vec2_length_fp64(diff);\\n}\\n\\n// vec3 functions\\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\\n  for (int i = 0; i < 3; i++) {\\n    out_val[i] = sum_fp64(a[i], b[i]);\\n  }\\n}\\n\\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\\n  for (int i = 0; i < 3; i++) {\\n    out_val[i] = sum_fp64(a[i], b[i]);\\n  }\\n}\\n\\nvec2 vec3_length_fp64(vec2 x[3]) {\\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])), mul_fp64(x[2], x[2])));\\n}\\n\\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\\n  vec2 diff[3];\\n  vec3_sub_fp64(x, y, diff);\\n  return vec3_length_fp64(diff);\\n}\\n\\n// vec4 functions\\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\\n  out_val[0].x = a[0];\\n  out_val[0].y = 0.0;\\n\\n  out_val[1].x = a[1];\\n  out_val[1].y = 0.0;\\n\\n  out_val[2].x = a[2];\\n  out_val[2].y = 0.0;\\n\\n  out_val[3].x = a[3];\\n  out_val[3].y = 0.0;\\n}\\n\\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\\n  out_val[0] = mul_fp64(a[0], b);\\n  out_val[1] = mul_fp64(a[1], b);\\n  out_val[2] = mul_fp64(a[2], b);\\n  out_val[3] = mul_fp64(a[3], b);\\n}\\n\\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\\n  for (int i = 0; i < 4; i++) {\\n    out_val[i] = sum_fp64(a[i], b[i]);\\n  }\\n}\\n\\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\\n  vec2 v[4];\\n\\n  v[0] = mul_fp64(a[0], b[0]);\\n  v[1] = mul_fp64(a[1], b[1]);\\n  v[2] = mul_fp64(a[2], b[2]);\\n  v[3] = mul_fp64(a[3], b[3]);\\n\\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\\n}\\n\\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\\n  vec2 tmp[4];\\n\\n  for (int i = 0; i < 4; i++)\\n  {\\n    for (int j = 0; j < 4; j++)\\n    {\\n      tmp[j] = b[j + i * 4];\\n    }\\n    vec4_dot_fp64(a, tmp, out_val[i]);\\n  }\\n}\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NoYWRlcmxpYi9mcDY0L2luZGV4LmpzP2YzYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmV4cG9ydCBjb25zdCBmcDY0ID0ge1xuICBpbnRlcmZhY2U6ICdmcDY0JyxcbiAgc291cmNlOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG51bmlmb3JtIGZsb2F0IE9ORTtcXG5cXG5jb25zdCB2ZWMyIEVfRlA2NCA9IHZlYzIoMi43MTgyODE3NDU5MTA2NDQ1ZSswMCwgOC4yNTQ4NDAzNjY4MTcwMDdlLTA4KTtcXG5jb25zdCB2ZWMyIExPRzJfRlA2NCA9IHZlYzIoMC42OTMxNDcxODI0NjQ1OTk2ZSswMCwgLTEuOTA0NjU0MjEyMTI1OTMzNmUtMDkpO1xcbmNvbnN0IHZlYzIgUElfRlA2NCA9IHZlYzIoMy4xNDE1OTI3NDEwMTI1NzMyLCAtOC43NDIyNzgwMTI2MTg5NTRlLTgpO1xcbmNvbnN0IHZlYzIgVFdPX1BJX0ZQNjQgPSB2ZWMyKDYuMjgzMTg1NDgyMDI1MTQ2NSwgLTEuNzQ4NDU1NjAyNTIzNzkwN2UtNyk7XFxuY29uc3QgdmVjMiBQSV8yX0ZQNjQgPSB2ZWMyKDEuNTcwNzk2MzcwNTA2Mjg2NiwgLTQuMzcxMTM5MDA2MzA5NDc3ZS04KTtcXG5jb25zdCB2ZWMyIFBJXzRfRlA2NCA9IHZlYzIoMC43ODUzOTgxODUyNTMxNDMzLCAtMi4xODU1Njk1MDMxNTQ3Mzg0ZS04KTtcXG5jb25zdCB2ZWMyIFBJXzE2X0ZQNjQgPSB2ZWMyKDAuMTk2MzQ5NTQ2MzEzMjg1ODMsIC01LjQ2MzkyMzc1Nzg4Njg0NmUtOSk7XFxuY29uc3QgdmVjMiBQSV8xNl8yX0ZQNjQgPSB2ZWMyKDAuMzkyNjk5MDkyNjI2NTcxNjYsIC0xLjA5Mjc4NDc1MTU3NzM2OTJlLTgpO1xcbmNvbnN0IHZlYzIgUElfMTZfM19GUDY0ID0gdmVjMigwLjU4OTA0ODYyNDAzODY5NjMsIC0xLjQ5MDYxMDA3OTgxMjg4MThlLTkpO1xcblxcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzBfRlA2NCA9IHZlYzIoMC4xOTUwOTAzMjM2ODY1OTk3MywgLTEuNjcwNDcxNDgzMzYxNTI0MmUtOSk7XFxuY29uc3QgdmVjMiBTSU5fVEFCTEVfMV9GUDY0ID0gdmVjMigwLjM4MjY4MzQyNjE0MTczODksIDYuMjIzMzUwODkwMTc3NjdlLTkpO1xcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzJfRlA2NCA9IHZlYzIoMC41NTU1NzAyNDQ3ODkxMjM1LCAtMS4xNzY5NTIxMzU3NTA3NTI5ZS04KTtcXG5jb25zdCB2ZWMyIFNJTl9UQUJMRV8zX0ZQNjQgPSB2ZWMyKDAuNzA3MTA2NzY5MDg0OTMwNCwgMS4yMTAxNjE3MDQxNzkzMTMzZS04KTtcXG5cXG5jb25zdCB2ZWMyIENPU19UQUJMRV8wX0ZQNjQgPSB2ZWMyKDAuOTgwNzg1MjUwNjYzNzU3MywgMi45NzM5NDczMTA2MzYwNDkyZS04KTtcXG5jb25zdCB2ZWMyIENPU19UQUJMRV8xX0ZQNjQgPSB2ZWMyKDAuOTIzODc5NTA0MjAzNzk2NCwgMi44MzA3NDkwMzUxNzY0Mzg2ZS04KTtcXG5jb25zdCB2ZWMyIENPU19UQUJMRV8yX0ZQNjQgPSB2ZWMyKDAuODMxNDY5NTk1NDMyMjgxNSwgMS42ODcwMjYzNzQxNTMwNzc4ZS04KTtcXG5jb25zdCB2ZWMyIENPU19UQUJMRV8zX0ZQNjQgPSB2ZWMyKDAuNzA3MTA2NzY5MDg0OTMwNCwgMS4yMTAxNjE3MTUyODE1NDM2ZS04KTtcXG5cXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCA9IHZlYzIoMS42NjY2NjY3MTYzMzcyMDRlLTAxLCAtNC45NjcwNTM4NzkzMTIyODllLTA5KTsgLy8gMS8zIVxcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0ID0gdmVjMig0LjE2NjY2Njc5MDg0MzAxZS0wMiwgLTEuMjQxNzYzNDY5ODI4MDcyMmUtMDkpOyAvLyAxLzQhXFxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF81X0ZQNjQgPSB2ZWMyKDguMzMzMzMzNzY3OTUwNTM1ZS0wMywgLTQuMzQ2MTcyMDMzMzc1OTVlLTEwKTsgLy8gMS81IVxcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNl9GUDY0ID0gdmVjMigxLjM4ODg4ODkyMjUxOTk4MTllLTAzLCAtMy4zNjMxMDk0NDM3MTAzMjE1ZS0xMSk7IC8vIDEvNiFcXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzdfRlA2NCA9IHZlYzIoMS45ODQxMjcwMTEzODI5NTIzZS0wNCwgIC0yLjcyNTU5Njg3NDkzMzQ1NmUtMTIpOyAvLyAxLzchXFxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF84X0ZQNjQgPSB2ZWMyKDIuNDgwMTU4NzY0MjI4NjkwNGUtMDUsIC0zLjQwNjk5NjAyNTkwNDE4NGUtMTMpOyAvLyAxLzghXFxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQgPSB2ZWMyKDIuNzU1NzMxODg0NDYyODc1MzNlLTA2LCAzLjc5MzU3MTM5MzcwMzgxODZlLTE0KTsgLy8gMS85IVxcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfMTBfRlA2NCA9IHZlYzIoMi43NTU3MzE5OTgxNDk3MTNlLTA3LCAtNy41NzUxMTIzNjc4Njk4NzNlLTE1KTsgLy8gMS8xMCFcXG5cXG5mbG9hdCBuaW50KGZsb2F0IGQpIHtcXG4gICAgaWYgKGQgPT0gZmxvb3IoZCkpIHJldHVybiBkO1xcbiAgICByZXR1cm4gZmxvb3IoZCArIDAuNSk7XFxufVxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxcbnZlYzIgc3BsaXQoZmxvYXQgYSkge1xcbiAgY29uc3QgZmxvYXQgU1BMSVQgPSA0MDk3LjA7XFxuICBmbG9hdCB0ID0gYSAqIFNQTElUO1xcbiAgZmxvYXQgYV9oaSA9IHQgKiBPTkUgLSAodCAtIGEpO1xcbiAgZmxvYXQgYV9sbyA9IGEgKiBPTkUgLSBhX2hpO1xcbiAgcmV0dXJuIHZlYzIoYV9oaSwgYV9sbyk7XFxufVxcbiNlbHNlXFxudmVjMiBzcGxpdChmbG9hdCBhKSB7XFxuICBjb25zdCBmbG9hdCBTUExJVCA9IDQwOTcuMDtcXG4gIGZsb2F0IHQgPSBhICogU1BMSVQ7XFxuICBmbG9hdCBhX2hpID0gdCAtICh0IC0gYSk7XFxuICBmbG9hdCBhX2xvID0gYSAtIGFfaGk7XFxuICByZXR1cm4gdmVjMihhX2hpLCBhX2xvKTtcXG59XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcXG52ZWMyIHF1aWNrVHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gIGZsb2F0IHN1bSA9IChhICsgYikgKiBPTkU7XFxuICBmbG9hdCBlcnIgPSBiIC0gKHN1bSAtIGEpICogT05FO1xcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xcbn1cXG4jZWxzZVxcbnZlYzIgcXVpY2tUd29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgZmxvYXQgc3VtID0gYSArIGI7XFxuICBmbG9hdCBlcnIgPSBiIC0gKHN1bSAtIGEpO1xcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xcbn1cXG4jZW5kaWZcXG5cXG52ZWMyIG5pbnRfZnA2NCh2ZWMyIGEpIHtcXG4gICAgZmxvYXQgaGkgPSBuaW50KGEueCk7XFxuICAgIGZsb2F0IGxvO1xcbiAgICB2ZWMyIHRtcDtcXG4gICAgaWYgKGhpID09IGEueCkge1xcbiAgICAgICAgbG8gPSBuaW50KGEueSk7XFxuICAgICAgICB0bXAgPSBxdWlja1R3b1N1bShoaSwgbG8pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbG8gPSAwLjA7XFxuICAgICAgICBpZiAoYWJzKGhpIC0gYS54KSA9PSAwLjUgJiYgYS55IDwgMC4wKSB7XFxuICAgICAgICAgICAgaGkgLT0gMS4wO1xcbiAgICAgICAgfVxcbiAgICAgICAgdG1wID0gdmVjMihoaSwgbG8pO1xcbiAgICB9XFxuICAgIHJldHVybiB0bXA7XFxufVxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxudmVjMiB0d29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgZmxvYXQgcyA9IChhICsgYikgKiBPTkU7XFxuICBmbG9hdCB2ID0gKHMgLSBhKTtcXG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSAqIE9ORSkgKiBPTkUgKyAoYiAtIHYpO1xcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcXG59XFxuI2Vsc2VcXG52ZWMyIHR3b1N1bShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICBmbG9hdCBzID0gYSArIGI7XFxuICBmbG9hdCB2ID0gcyAtIGE7XFxuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikpICsgKGIgLSB2KTtcXG4gIHJldHVybiB2ZWMyKHMsIGVycik7XFxufVxcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxudmVjMiB0d29TdWIoZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgZmxvYXQgcyA9IChhIC0gYikgKiBPTkU7XFxuICBmbG9hdCB2ID0gKHMgLSBhKTtcXG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSAqIE9ORSkgKiBPTkUgLSAoYiArIHYpO1xcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcXG59XFxuI2Vsc2VcXG52ZWMyIHR3b1N1YihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICBmbG9hdCBzID0gYSAtIGI7XFxuICBmbG9hdCB2ID0gcyAtIGE7XFxuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikpIC0gKGIgKyB2KTtcXG4gIHJldHVybiB2ZWMyKHMsIGVycik7XFxufVxcbiNlbmRpZlxcblxcbnZlYzIgdHdvUHJvZChmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICBmbG9hdCBwcm9kID0gYSAqIGI7XFxuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xcbiAgdmVjMiBiX2ZwNjQgPSBzcGxpdChiKTtcXG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBiX2ZwNjQueCAtIHByb2QpICsgYV9mcDY0LnggKiBiX2ZwNjQueSArXFxuICAgIGFfZnA2NC55ICogYl9mcDY0LngpICsgYV9mcDY0LnkgKiBiX2ZwNjQueTtcXG4gIHJldHVybiB2ZWMyKHByb2QsIGVycik7XFxufVxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxudmVjMiB0d29TcXIoZmxvYXQgYSkge1xcbiAgZmxvYXQgcHJvZCA9IGEgKiBhO1xcbiAgdmVjMiBhX2ZwNjQgPSBzcGxpdChhKTtcXG5cXG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBhX2ZwNjQueCAtIHByb2QpICogT05FICsgMi4wICogYV9mcDY0LnggKiBhX2ZwNjQueSAqIE9ORSAqIE9ORSkgKyBhX2ZwNjQueSAqIGFfZnA2NC55ICogT05FICogT05FICogT05FO1xcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcXG59XFxuI2Vsc2VcXG52ZWMyIHR3b1NxcihmbG9hdCBhKSB7XFxuICBmbG9hdCBwcm9kID0gYSAqIGE7XFxuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xcblxcbiAgZmxvYXQgZXJyID0gKChhX2ZwNjQueCAqIGFfZnA2NC54IC0gcHJvZCkgKyAyLjAgKiBhX2ZwNjQueCAqIGFfZnA2NC55KSArIGFfZnA2NC55ICogYV9mcDY0Lnk7XFxuICByZXR1cm4gdmVjMihwcm9kLCBlcnIpO1xcbn1cXG4jZW5kaWZcXG5cXG52ZWMyIHN1bV9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICB2ZWMyIHMsIHQ7XFxuICBzID0gdHdvU3VtKGEueCwgYi54KTtcXG4gIHQgPSB0d29TdW0oYS55LCBiLnkpO1xcbiAgcy55ICs9IHQueDtcXG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XFxuICBzLnkgKz0gdC55O1xcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcXG4gIHJldHVybiBzO1xcbn1cXG5cXG52ZWMyIHN1Yl9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICB2ZWMyIHMsIHQ7XFxuICBzID0gdHdvU3ViKGEueCwgYi54KTtcXG4gIHQgPSB0d29TdWIoYS55LCBiLnkpO1xcbiAgcy55ICs9IHQueDtcXG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XFxuICBzLnkgKz0gdC55O1xcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcXG4gIHJldHVybiBzO1xcbn1cXG5cXG52ZWMyIG11bF9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICB2ZWMyIHByb2QgPSB0d29Qcm9kKGEueCwgYi54KTtcXG4gIC8vIHkgY29tcG9uZW50IGlzIGZvciB0aGUgZXJyb3JcXG4gIHByb2QueSArPSBhLnggKiBiLnk7XFxuICBwcm9kLnkgKz0gYS55ICogYi54O1xcbiAgcHJvZCA9IHF1aWNrVHdvU3VtKHByb2QueCwgcHJvZC55KTtcXG4gIHJldHVybiBwcm9kO1xcbn1cXG5cXG52ZWMyIGRpdl9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICBmbG9hdCB4biA9IDEuMCAvIGIueDtcXG4gIHZlYzIgeW4gPSBhICogeG47XFxuICBmbG9hdCBkaWZmID0gKHN1Yl9mcDY0KGEsIG11bF9mcDY0KGIsIHluKSkpLng7XFxuICB2ZWMyIHByb2QgPSB0d29Qcm9kKHhuLCBkaWZmKTtcXG4gIHJldHVybiBzdW1fZnA2NCh5biwgcHJvZCk7XFxufVxcblxcbnZlYzIgc3FydF9mcDY0KHZlYzIgYSkge1xcblxcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xcbiAgaWYgKGEueCA8IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcblxcbiAgZmxvYXQgeCA9IDEuMCAvIHNxcnQoYS54KTtcXG4gIGZsb2F0IHluID0gYS54ICogeDtcXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcXG4gIHZlYzIgeW5fc3FyID0gdHdvU3FyKHluKSAqIE9ORTtcXG4jZWxzZVxcbiAgdmVjMiB5bl9zcXIgPSB0d29TcXIoeW4pO1xcbiNlbmRpZlxcbiAgZmxvYXQgZGlmZiA9IHN1Yl9mcDY0KGEsIHluX3NxcikueDtcXG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoeCAqIDAuNSwgZGlmZik7XFxuICByZXR1cm4gc3VtX2ZwNjQodmVjMih5biwgMC4wKSwgcHJvZCk7XFxufVxcblxcbnZlYzIgZXhwX2ZwNjQodmVjMiBhKSB7XFxuICBjb25zdCBmbG9hdCBrID0gNTEyLjA7XFxuICBjb25zdCBmbG9hdCBpbnZfayA9IDEuMCAvIGs7XFxuXFxuICBpZiAoYS54IDw9IC04OC4wKSByZXR1cm4gdmVjMigwLjAsIDAuMCk7XFxuICBpZiAoYS54ID49IDg4LjApIHJldHVybiB2ZWMyKDEuMCAvIDAuMCwgMS4wIC8gMC4wKTtcXG4gIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHJldHVybiB2ZWMyKDEuMCwgMC4wKTtcXG4gIGlmIChhLnggPT0gMS4wICYmIGEueSA9PSAwLjApIHJldHVybiBFX0ZQNjQ7XFxuXFxuICAvLyBSYW5nZSByZWR1Y3Rpb24gdXNpbmcgYXNzdW1lIGEgPSBrciArIG0gKiBsb2coMiksIGsgYW5kIG0gYmVpbmcgaW50ZWdlcnMuXFxuICAvLyBTZXQgayA9IDkgKHdlIGNhbiBjaG9vc2Ugb3RoZXIgayB0byB0cmFkZSBhY2N1cmFjeSB3aXRoIHBlcmZvcm1hbmNlLlxcbiAgLy8gd2Ugb25seSBuZWVkIHRvIGNhbGN1bGF0ZSBleHAocikgYW5kIHVzaW5nIGV4cChhKSA9IDJebSAqIGV4cChyKV5rXFxuXFxuICBmbG9hdCBtID0gZmxvb3IoYS54IC8gTE9HMl9GUDY0LnggKyAwLjUpO1xcbiAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoTE9HMl9GUDY0LCB2ZWMyKG0sIDAuMCkpKSAqIGludl9rO1xcbiAgdmVjMiBzLCB0LCBwO1xcblxcbiAgcCA9IG11bF9mcDY0KHIsIHIpO1xcbiAgcyA9IHN1bV9mcDY0KHIsIHAgKiAwLjUpO1xcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCk7XFxuXFxuICBzID0gc3VtX2ZwNjQocywgdCk7XFxuICBwID0gbXVsX2ZwNjQocCwgcik7XFxuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0KTtcXG5cXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcXG4gIHAgPSBtdWxfZnA2NChwLCByKTtcXG4gIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF81X0ZQNjQpO1xcblxcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzZfRlA2NCk7XFxuXFxuICBzID0gc3VtX2ZwNjQocywgdCk7XFxuICBwID0gbXVsX2ZwNjQocCwgcik7XFxuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0KTtcXG5cXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcXG5cXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHMgPSBleHAocikgLSAxOyBidXQgYWZ0ZXIgZm9sbG93aW5nIDQgcmVjdXJzaW9ucywgd2Ugd2lsbCBnZXQgZXhwKHIpIF4gNTEyIC0gMS5cXG5cXG4gIHMgPSBzdW1fZnA2NChzICogMi4wLCBtdWxfZnA2NChzLCBzKSk7XFxuICBzID0gc3VtX2ZwNjQocyAqIDIuMCwgbXVsX2ZwNjQocywgcykpO1xcbiAgcyA9IHN1bV9mcDY0KHMgKiAyLjAsIG11bF9mcDY0KHMsIHMpKTtcXG4gIHMgPSBzdW1fZnA2NChzICogMi4wLCBtdWxfZnA2NChzLCBzKSk7XFxuXFxuICAvLyBXZSBjYW4gYWRkIG1vcmUgaXRlcmF0aW9ucyBoZXJlIGFuZCBpbmNyZWFzZSBrLlxcbiAgcyA9IHN1bV9mcDY0KHMgKiAyLjAsIG11bF9mcDY0KHMsIHMpKTtcXG4gIHMgPSBzdW1fZnA2NChzICogMi4wLCBtdWxfZnA2NChzLCBzKSk7XFxuICBzID0gc3VtX2ZwNjQocyAqIDIuMCwgbXVsX2ZwNjQocywgcykpO1xcbiAgcyA9IHN1bV9mcDY0KHMgKiAyLjAsIG11bF9mcDY0KHMsIHMpKTtcXG4gIHMgPSBzdW1fZnA2NChzICogMi4wLCBtdWxfZnA2NChzLCBzKSk7XFxuXFxuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9GUDY0X1dPUktBUk9VTkQpXFxuICBzID0gc3VtX2ZwNjQocywgdmVjMigxLjAsIDAuMCkgKiBPTkUpO1xcbiNlbHNlXFxuICBzID0gc3VtX2ZwNjQocywgdmVjMigxLjAsIDAuMCkpO1xcbiNlbmRpZlxcblxcbiAgcmV0dXJuIHMgKiBwb3coMi4wLCBtKTtcXG4vLyAgIHJldHVybiByO1xcbn1cXG5cXG52ZWMyIGxvZ19mcDY0KHZlYzIgYSlcXG57XFxuICBpZiAoYS54ID09IDEuMCAmJiBhLnkgPT0gMC4wKSByZXR1cm4gdmVjMigwLjAsIDAuMCk7XFxuICBpZiAoYS54IDw9IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgdmVjMiB4ID0gdmVjMihsb2coYS54KSwgMC4wKTtcXG4gIHggPSBzdWJfZnA2NChzdW1fZnA2NCh4LCBtdWxfZnA2NChhLCBleHBfZnA2NCgteCkpKSwgdmVjMigxLjAsIDAuMCkpO1xcbiAgcmV0dXJuIHg7XFxufVxcblxcbnZlYzIgc2luX3RheWxvcl9mcDY0KHZlYzIgYSkge1xcbiAgdmVjMiByLCBzLCB0LCB4O1xcblxcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xcbiAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XFxuICB9XFxuXFxuICB4ID0gLW11bF9mcDY0KGEsIGEpO1xcbiAgcyA9IGE7XFxuICByID0gYTtcXG5cXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQpO1xcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgciA9IG11bF9mcDY0KHIsIHgpO1xcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XFxuICBzID0gc3VtX2ZwNjQocywgdCk7XFxuXFxuICByID0gbXVsX2ZwNjQociwgeCk7XFxuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfN19GUDY0KTtcXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcXG5cXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQpO1xcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgcmV0dXJuIHM7XFxufVxcblxcbnZlYzIgY29zX3RheWxvcl9mcDY0KHZlYzIgYSkge1xcbiAgdmVjMiByLCBzLCB0LCB4O1xcblxcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xcbiAgICByZXR1cm4gdmVjMigxLjAsIDAuMCk7XFxuICB9XFxuXFxuICB4ID0gLW11bF9mcDY0KGEsIGEpO1xcbiAgciA9IHg7XFxuICBzID0gc3VtX2ZwNjQodmVjMigxLjAsIDAuMCksIHIgKiAwLjUpO1xcblxcbiAgciA9IG11bF9mcDY0KHIsIHgpO1xcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzRfRlA2NCk7XFxuICBzID0gc3VtX2ZwNjQocywgdCk7XFxuXFxuICByID0gbXVsX2ZwNjQociwgeCk7XFxuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfNl9GUDY0KTtcXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcXG5cXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF84X0ZQNjQpO1xcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgciA9IG11bF9mcDY0KHIsIHgpO1xcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzEwX0ZQNjQpO1xcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgcmV0dXJuIHM7XFxufVxcblxcbnZvaWQgc2luY29zX3RheWxvcl9mcDY0KHZlYzIgYSwgb3V0IHZlYzIgc2luX3QsIG91dCB2ZWMyIGNvc190KSB7XFxuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XFxuICAgIHNpbl90ID0gdmVjMigwLjAsIDAuMCk7XFxuICAgIGNvc190ID0gdmVjMigxLjAsIDAuMCk7XFxuICB9XFxuXFxuICBzaW5fdCA9IHNpbl90YXlsb3JfZnA2NChhKTtcXG4gIGNvc190ID0gc3FydF9mcDY0KHN1Yl9mcDY0KHZlYzIoMS4wLCAwLjApLCBtdWxfZnA2NChzaW5fdCwgc2luX3QpKSk7XFxufVxcblxcbnZlYzIgc2luX2ZwNjQodmVjMiBhKSB7XFxuICAgIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcXG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcXG4gICAgfVxcblxcbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXFxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xcbiAgICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChUV09fUElfRlA2NCwgeikpO1xcblxcbiAgICB2ZWMyIHQ7XFxuICAgIGZsb2F0IHEgPSBmbG9vcihyLnggLyBQSV8yX0ZQNjQueCArIDAuNSk7XFxuICAgIGludCBqID0gaW50KHEpO1xcblxcbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XFxuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XFxuICAgIH1cXG5cXG4gICAgdCA9IHN1Yl9mcDY0KHIsIG11bF9mcDY0KFBJXzJfRlA2NCwgdmVjMihxLCAwLjApKSk7XFxuXFxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xcbiAgICBpbnQgayA9IGludChxKTtcXG5cXG4gICAgaWYgKGsgPT0gMCkge1xcbiAgICAgICAgaWYgKGogPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBzaW5fdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiBjb3NfdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcXG4gICAgICAgICAgICByZXR1cm4gLWNvc190YXlsb3JfZnA2NCh0KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIC1zaW5fdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xcblxcbiAgICBpZiAoYWJzX2sgPiA0KSB7XFxuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XFxuICAgIH0gZWxzZSBpZiAoayA9PSAzKSB7XFxuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgUElfMTZfM19GUDY0KTtcXG4gICAgfSBlbHNlIGlmIChrID09IC0zKSB7XFxuICAgICAgICB0ID0gc3VtX2ZwNjQodCwgUElfMTZfM19GUDY0KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHQgPSBzdWJfZnA2NCh0LCBtdWxfZnA2NChQSV8xNl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcXG4gICAgfVxcblxcbiAgICB2ZWMyIHUgPSB2ZWMyKDAuMCwgMC4wKTtcXG4gICAgdmVjMiB2ID0gdmVjMigwLjAsIDAuMCk7XFxuXFxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcXG4gICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xcbiAgICB9XFxuI2Vsc2VcXG4gICAgaWYgKGFic19rID09IDEpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMikge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSAzKSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDQpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XFxuICAgIH1cXG4jZW5kaWZcXG5cXG4gICAgdmVjMiBzaW5fdCwgY29zX3Q7XFxuICAgIHNpbmNvc190YXlsb3JfZnA2NCh0LCBzaW5fdCwgY29zX3QpO1xcblxcbiAgICB2ZWMyIHJlc3VsdCA9IHZlYzIoMC4wLCAwLjApO1xcbiAgICBpZiAoaiA9PSAwKSB7XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcXG4gICAgICAgIGlmIChrID4gMCkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcXG4gICAgICAgIGlmIChrID4gMCkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIHNpbl90KSwgbXVsX2ZwNjQodSwgY29zX3QpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHYsIHNpbl90KSwgbXVsX2ZwNjQodSwgY29zX3QpKTtcXG4gICAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChrID4gMCkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1Yl9mcDY0KG11bF9mcDY0KHYsIGNvc190KSwgbXVsX2ZwNjQodSwgc2luX3QpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG52ZWMyIGNvc19mcDY0KHZlYzIgYSkge1xcbiAgICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XFxuICAgICAgICByZXR1cm4gdmVjMigxLjAsIDAuMCk7XFxuICAgIH1cXG5cXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxcbiAgICB2ZWMyIHogPSBuaW50X2ZwNjQoZGl2X2ZwNjQoYSwgVFdPX1BJX0ZQNjQpKTtcXG4gICAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoVFdPX1BJX0ZQNjQsIHopKTtcXG5cXG4gICAgdmVjMiB0O1xcbiAgICBmbG9hdCBxID0gZmxvb3Ioci54IC8gUElfMl9GUDY0LnggKyAwLjUpO1xcbiAgICBpbnQgaiA9IGludChxKTtcXG5cXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgICB9XFxuXFxuICAgIHQgPSBzdWJfZnA2NChyLCBtdWxfZnA2NChQSV8yX0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xcblxcbiAgICBxID0gZmxvb3IodC54IC8gUElfMTZfRlA2NC54ICsgMC41KTtcXG4gICAgaW50IGsgPSBpbnQocSk7XFxuXFxuICAgIGlmIChrID09IDApIHtcXG4gICAgICAgIGlmIChqID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gY29zX3RheWxvcl9mcDY0KHQpO1xcbiAgICAgICAgfSBlbHNlIGlmIChqID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gLXNpbl90YXlsb3JfZnA2NCh0KTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xcbiAgICAgICAgICAgIHJldHVybiBzaW5fdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAtY29zX3RheWxvcl9mcDY0KHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcXG5cXG4gICAgaWYgKGFic19rID4gNCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgICB9IGVsc2UgaWYgKGsgPT0gMykge1xcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIFBJXzE2XzNfRlA2NCk7XFxuICAgIH0gZWxzZSBpZiAoayA9PSAtMykge1xcbiAgICAgICAgdCA9IHN1bV9mcDY0KHQsIFBJXzE2XzNfRlA2NCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XFxuICAgIH1cXG5cXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XFxuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxuICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcXG4gICAgfVxcbiNlbHNlXFxuICAgIGlmIChhYnNfayA9PSAxKSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xcbiAgICB9XFxuI2VuZGlmXFxuXFxuICAgIHZlYzIgc2luX3QsIGNvc190O1xcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcXG5cXG4gICAgdmVjMiByZXN1bHQgPSB2ZWMyKDAuMCwgMC4wKTtcXG4gICAgaWYgKGogPT0gMCkge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBjb3NfdCksIG11bF9mcDY0KHUsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBzaW5fdCksIG11bF9mcDY0KHUsIGNvc190KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudmVjMiB0YW5fZnA2NCh2ZWMyIGEpIHtcXG4gICAgdmVjMiBzaW5fYTtcXG4gICAgdmVjMiBjb3NfYTtcXG5cXG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xcbiAgICB9XFxuXFxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cXG4gICAgdmVjMiB6ID0gbmludF9mcDY0KGRpdl9mcDY0KGEsIFRXT19QSV9GUDY0KSk7XFxuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XFxuXFxuICAgIHZlYzIgdDtcXG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcXG4gICAgaW50IGogPSBpbnQocSk7XFxuXFxuXFxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcXG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcXG4gICAgfVxcblxcbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcXG5cXG4gICAgcSA9IGZsb29yKHQueCAvIFBJXzE2X0ZQNjQueCArIDAuNSk7XFxuICAgIGludCBrID0gaW50KHEpO1xcbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XFxuXFxuICAgIC8vIFdlIGp1c3QgY2FuXFwndCBnZXQgUEkvMTYgKiAzLjAgdmVyeSBhY2N1cmF0ZWx5LlxcbiAgICAvLyBzbyBsZXRcXCdzIGp1c3Qgc3RvcmUgaXRcXG4gICAgaWYgKGFic19rID4gNCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgICB9IGVsc2UgaWYgKGsgPT0gMykge1xcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIFBJXzE2XzNfRlA2NCk7XFxuICAgIH0gZWxzZSBpZiAoayA9PSAtMykge1xcbiAgICAgICAgdCA9IHN1bV9mcDY0KHQsIFBJXzE2XzNfRlA2NCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XFxuICAgIH1cXG5cXG5cXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XFxuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xcblxcbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcXG4gICAgdmVjMiBzLCBjO1xcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcXG5cXG4gICAgaWYgKGsgPT0gMCkge1xcbiAgICAgICAgcyA9IHNpbl90O1xcbiAgICAgICAgYyA9IGNvc190O1xcbiAgICB9IGVsc2Uge1xcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxuICAgICAgICBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDEuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzJfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDQuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgIH1cXG4jZWxzZVxcbiAgICAgICAgaWYgKGFic19rID09IDEpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMikge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xcbiAgICAgICAgfSBlbHNlIGlmIChhYnNfayA9PSAzKSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICB9IGVsc2UgaWYgKGFic19rID09IDQpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgIH1cXG4jZW5kaWZcXG4gICAgICAgIGlmIChrID4gMCkge1xcbiAgICAgICAgICAgIHMgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XFxuICAgICAgICAgICAgYyA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcyA9IHN1Yl9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcXG4gICAgICAgICAgICBjID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChqID09IDApIHtcXG4gICAgICAgIHNpbl9hID0gcztcXG4gICAgICAgIGNvc19hID0gYztcXG4gICAgfSBlbHNlIGlmIChqID09IDEpIHtcXG4gICAgICAgIHNpbl9hID0gYztcXG4gICAgICAgIGNvc19hID0gLXM7XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xcbiAgICAgICAgc2luX2EgPSAtYztcXG4gICAgICAgIGNvc19hID0gcztcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNpbl9hID0gLXM7XFxuICAgICAgICBjb3NfYSA9IC1jO1xcbiAgICB9XFxuICAgIHJldHVybiBkaXZfZnA2NChzaW5fYSwgY29zX2EpO1xcbn1cXG5cXG52ZWMyIHJhZGlhbnNfZnA2NCh2ZWMyIGRlZ3JlZSkge1xcbiAgcmV0dXJuIGRpdl9mcDY0KG11bF9mcDY0KGRlZ3JlZSwgUElfRlA2NCksIHZlYzIoMTgwLjAsIDAuMCkpO1xcbn1cXG5cXG4vLyBWZWN0b3IgZnVuY3Rpb25zXFxuLy8gdmVjMiBmdW5jdGlvbnNcXG52b2lkIHZlYzJfc3VtX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcXG4gICAgb3V0X3ZhbFswXSA9IHN1bV9mcDY0KGFbMF0sIGJbMF0pO1xcbiAgICBvdXRfdmFsWzFdID0gc3VtX2ZwNjQoYVsxXSwgYlsxXSk7XFxufVxcblxcbnZvaWQgdmVjMl9zdWJfZnA2NCh2ZWMyIGFbMl0sIHZlYzIgYlsyXSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xcbiAgICBvdXRfdmFsWzBdID0gc3ViX2ZwNjQoYVswXSwgYlswXSk7XFxuICAgIG91dF92YWxbMV0gPSBzdWJfZnA2NChhWzFdLCBiWzFdKTtcXG59XFxuXFxudm9pZCB2ZWMyX21peF9mcDY0KHZlYzIgeFsyXSwgdmVjMiB5WzJdLCBmbG9hdCBhLCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XFxuICB2ZWMyIHJhbmdlWzJdO1xcbiAgdmVjMl9zdWJfZnA2NCh5LCB4LCByYW5nZSk7XFxuICB2ZWMyIHBvcnRpb25bMl07XFxuICBwb3J0aW9uWzBdID0gcmFuZ2VbMF0gKiBhO1xcbiAgcG9ydGlvblsxXSA9IHJhbmdlWzFdICogYTtcXG4gIHZlYzJfc3VtX2ZwNjQoeCwgcG9ydGlvbiwgb3V0X3ZhbCk7XFxufVxcblxcbnZlYzIgdmVjMl9sZW5ndGhfZnA2NCh2ZWMyIHhbMl0pIHtcXG4gIHJldHVybiBzcXJ0X2ZwNjQoc3VtX2ZwNjQobXVsX2ZwNjQoeFswXSwgeFswXSksIG11bF9mcDY0KHhbMV0sIHhbMV0pKSk7XFxufVxcblxcbnZlYzIgdmVjMl9kaXN0YW5jZV9mcDY0KHZlYzIgeFsyXSwgdmVjMiB5WzJdKSB7XFxuICB2ZWMyIGRpZmZbMl07XFxuICB2ZWMyX3N1Yl9mcDY0KHgsIHksIGRpZmYpO1xcbiAgcmV0dXJuIHZlYzJfbGVuZ3RoX2ZwNjQoZGlmZik7XFxufVxcblxcbi8vIHZlYzMgZnVuY3Rpb25zXFxudm9pZCB2ZWMzX3N1Yl9mcDY0KHZlYzIgYVszXSwgdmVjMiBiWzNdLCBvdXQgdmVjMiBvdXRfdmFsWzNdKSB7XFxuICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKykge1xcbiAgICBvdXRfdmFsW2ldID0gc3VtX2ZwNjQoYVtpXSwgYltpXSk7XFxuICB9XFxufVxcblxcbnZvaWQgdmVjM19zdW1fZnA2NCh2ZWMyIGFbM10sIHZlYzIgYlszXSwgb3V0IHZlYzIgb3V0X3ZhbFszXSkge1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspIHtcXG4gICAgb3V0X3ZhbFtpXSA9IHN1bV9mcDY0KGFbaV0sIGJbaV0pO1xcbiAgfVxcbn1cXG5cXG52ZWMyIHZlYzNfbGVuZ3RoX2ZwNjQodmVjMiB4WzNdKSB7XFxuICByZXR1cm4gc3FydF9mcDY0KHN1bV9mcDY0KHN1bV9mcDY0KG11bF9mcDY0KHhbMF0sIHhbMF0pLCBtdWxfZnA2NCh4WzFdLCB4WzFdKSksIG11bF9mcDY0KHhbMl0sIHhbMl0pKSk7XFxufVxcblxcbnZlYzIgdmVjM19kaXN0YW5jZV9mcDY0KHZlYzIgeFszXSwgdmVjMiB5WzNdKSB7XFxuICB2ZWMyIGRpZmZbM107XFxuICB2ZWMzX3N1Yl9mcDY0KHgsIHksIGRpZmYpO1xcbiAgcmV0dXJuIHZlYzNfbGVuZ3RoX2ZwNjQoZGlmZik7XFxufVxcblxcbi8vIHZlYzQgZnVuY3Rpb25zXFxudm9pZCB2ZWM0X2ZwNjQodmVjNCBhLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XFxuICBvdXRfdmFsWzBdLnggPSBhWzBdO1xcbiAgb3V0X3ZhbFswXS55ID0gMC4wO1xcblxcbiAgb3V0X3ZhbFsxXS54ID0gYVsxXTtcXG4gIG91dF92YWxbMV0ueSA9IDAuMDtcXG5cXG4gIG91dF92YWxbMl0ueCA9IGFbMl07XFxuICBvdXRfdmFsWzJdLnkgPSAwLjA7XFxuXFxuICBvdXRfdmFsWzNdLnggPSBhWzNdO1xcbiAgb3V0X3ZhbFszXS55ID0gMC4wO1xcbn1cXG5cXG52b2lkIHZlYzRfc2NhbGFyX211bF9mcDY0KHZlYzIgYVs0XSwgdmVjMiBiLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XFxuICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoYVswXSwgYik7XFxuICBvdXRfdmFsWzFdID0gbXVsX2ZwNjQoYVsxXSwgYik7XFxuICBvdXRfdmFsWzJdID0gbXVsX2ZwNjQoYVsyXSwgYik7XFxuICBvdXRfdmFsWzNdID0gbXVsX2ZwNjQoYVszXSwgYik7XFxufVxcblxcbnZvaWQgdmVjNF9zdW1fZnA2NCh2ZWMyIGFbNF0sIHZlYzIgYls0XSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgb3V0X3ZhbFtpXSA9IHN1bV9mcDY0KGFbaV0sIGJbaV0pO1xcbiAgfVxcbn1cXG5cXG52b2lkIHZlYzRfZG90X2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGJbNF0sIG91dCB2ZWMyIG91dF92YWwpIHtcXG4gIHZlYzIgdls0XTtcXG5cXG4gIHZbMF0gPSBtdWxfZnA2NChhWzBdLCBiWzBdKTtcXG4gIHZbMV0gPSBtdWxfZnA2NChhWzFdLCBiWzFdKTtcXG4gIHZbMl0gPSBtdWxfZnA2NChhWzJdLCBiWzJdKTtcXG4gIHZbM10gPSBtdWxfZnA2NChhWzNdLCBiWzNdKTtcXG5cXG4gIG91dF92YWwgPSBzdW1fZnA2NChzdW1fZnA2NCh2WzBdLCB2WzFdKSwgc3VtX2ZwNjQodlsyXSwgdlszXSkpO1xcbn1cXG5cXG52b2lkIG1hdDRfdmVjNF9tdWxfZnA2NCh2ZWMyIGJbMTZdLCB2ZWMyIGFbNF0sIG91dCB2ZWMyIG91dF92YWxbNF0pIHtcXG4gIHZlYzIgdG1wWzRdO1xcblxcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspXFxuICB7XFxuICAgIGZvciAoaW50IGogPSAwOyBqIDwgNDsgaisrKVxcbiAgICB7XFxuICAgICAgdG1wW2pdID0gYltqICsgaSAqIDRdO1xcbiAgICB9XFxuICAgIHZlYzRfZG90X2ZwNjQoYSwgdG1wLCBvdXRfdmFsW2ldKTtcXG4gIH1cXG59XFxuJ1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NoYWRlcmxpYi9mcDY0L2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 61 */
/* exports provided: project */
/* exports used: project */
/*!****************************************!*\
  !*** ./src/shaderlib/project/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(exports, \"a\", function() { return project; });\n\n\nvar project = {\n  interface: 'project',\n  source: 'const float TILE_SIZE = 512.0;\\nconst float PI = 3.1415926536;\\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\\n\\nconst float PROJECT_LINEAR = 0.;\\nconst float PROJECT_MERCATOR = 1.;\\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\\n\\nuniform float projectionMode;\\nuniform float projectionScale;\\nuniform vec4 projectionCenter;\\nuniform vec3 projectionPixelsPerUnit;\\n\\nuniform mat4 projectionMatrix;\\nuniform mat4 projectionMatrixUncentered;\\n\\n#ifdef INTEL_TAN_WORKAROUND\\n\\n// All these functions are for substituting tan() function from Intel GPU only\\nconst float TWO_PI = 6.2831854820251465;\\nconst float PI_2 = 1.5707963705062866;\\nconst float PI_16 = 0.1963495463132858;\\n\\nconst float SIN_TABLE_0 = 0.19509032368659973;\\nconst float SIN_TABLE_1 = 0.3826834261417389;\\nconst float SIN_TABLE_2 = 0.5555702447891235;\\nconst float SIN_TABLE_3 = 0.7071067690849304;\\n\\nconst float COS_TABLE_0 = 0.9807852506637573;\\nconst float COS_TABLE_1 = 0.9238795042037964;\\nconst float COS_TABLE_2 = 0.8314695954322815;\\nconst float COS_TABLE_3 = 0.7071067690849304;\\n\\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\\n\\nfloat sin_taylor_fp32(float a) {\\n  float r, s, t, x;\\n\\n  if (a == 0.0) {\\n    return 0.0;\\n  }\\n\\n  x = -a * a;\\n  s = a;\\n  r = a;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_3;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_5;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_7;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_9;\\n  s = s + t;\\n\\n  return s;\\n}\\n\\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\\n  if (a == 0.0) {\\n    sin_t = 0.0;\\n    cos_t = 1.0;\\n  }\\n  sin_t = sin_taylor_fp32(a);\\n  cos_t = sqrt(1.0 - sin_t * sin_t);\\n}\\n\\nfloat tan_taylor_fp32(float a) {\\n    float sin_a;\\n    float cos_a;\\n\\n    if (a == 0.0) {\\n        return 0.0;\\n    }\\n\\n    // 2pi range reduction\\n    float z = floor(a / TWO_PI);\\n    float r = a - TWO_PI * z;\\n\\n    float t;\\n    float q = floor(r / PI_2 + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return 0.0 / 0.0;\\n    }\\n\\n    t = r - PI_2 * q;\\n\\n    q = floor(t / PI_16 + 0.5);\\n    int k = int(q);\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return 0.0 / 0.0;\\n    } else {\\n        t = t - PI_16 * q;\\n    }\\n\\n    float u = 0.0;\\n    float v = 0.0;\\n\\n    float sin_t, cos_t;\\n    float s, c;\\n    sincos_taylor_fp32(t, sin_t, cos_t);\\n\\n    if (k == 0) {\\n        s = sin_t;\\n        c = cos_t;\\n    } else {\\n        if (abs(float(abs_k) - 1.0) < 0.5) {\\n            u = COS_TABLE_0;\\n            v = SIN_TABLE_0;\\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n            u = COS_TABLE_1;\\n            v = SIN_TABLE_1;\\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n            u = COS_TABLE_2;\\n            v = SIN_TABLE_2;\\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n            u = COS_TABLE_3;\\n            v = SIN_TABLE_3;\\n        }\\n        if (k > 0) {\\n            s = u * sin_t + v * cos_t;\\n            c = u * cos_t - v * sin_t;\\n        } else {\\n            s = u * sin_t - v * cos_t;\\n            c = u * cos_t + v * sin_t;\\n        }\\n    }\\n\\n    if (j == 0) {\\n        sin_a = s;\\n        cos_a = c;\\n    } else if (j == 1) {\\n        sin_a = c;\\n        cos_a = -s;\\n    } else if (j == -1) {\\n        sin_a = -c;\\n        cos_a = s;\\n    } else {\\n        sin_a = -s;\\n        cos_a = -c;\\n    }\\n    return sin_a / cos_a;\\n}\\n#endif\\n\\nfloat tan_fp32(float a) {\\n#ifdef INTEL_TAN_WORKAROUND\\n  return tan_taylor_fp32(a);\\n#else\\n  return tan(a);\\n#endif\\n}\\n\\n//\\n// Scaling offsets\\n//\\n\\nfloat project_scale(float meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return meters * projectionPixelsPerUnit.x;\\n  }\\n}\\n\\nvec2 project_scale(vec2 meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return vec2(\\n      meters.x * projectionPixelsPerUnit.x,\\n      meters.y * projectionPixelsPerUnit.x\\n    );\\n  }\\n}\\n\\nvec3 project_scale(vec3 meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return vec3(\\n      meters.x * projectionPixelsPerUnit.x,\\n      meters.y * projectionPixelsPerUnit.x,\\n      meters.z * projectionPixelsPerUnit.x\\n    );\\n  }\\n}\\n\\nvec4 project_scale(vec4 meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return vec4(\\n      meters.x * projectionPixelsPerUnit.x,\\n      meters.y * projectionPixelsPerUnit.x,\\n      meters.z * projectionPixelsPerUnit.x,\\n      meters.w\\n    );\\n  }\\n}\\n\\n//\\n// Projecting positions\\n//\\n\\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\\nvec2 project_mercator_(vec2 lnglat) {\\n  return vec2(\\n    radians(lnglat.x) + PI,\\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\\n  );\\n}\\n\\nvec2 project_position(vec2 position) {\\n  // if (projectionMode == PROJECT_LINEAR) {\\n  //   return (position + vec2(TILE_SIZE / 2.0)) * projectionScale;\\n  // }\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return position;\\n    return project_scale(position);\\n  }\\n  // Covers projectionMode == PROJECT_MERCATOR\\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\\n}\\n\\nvec3 project_position(vec3 position) {\\n  return vec3(project_position(position.xy), project_scale(position.z));\\n}\\n\\nvec4 project_position(vec4 position) {\\n  return vec4(project_position(position.xyz), position.w);\\n}\\n\\n//\\n\\nvec4 project_to_clipspace(vec4 position) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    position = position * projectionPixelsPerUnit.x;\\n  }\\n  return projectionMatrix * position + projectionCenter;\\n}\\n\\n// Backwards compatibility\\n\\nfloat scale(float position) {\\n  return project_scale(position);\\n}\\n\\nvec2 scale(vec2 position) {\\n  return project_scale(position);\\n}\\n\\nvec3 scale(vec3 position) {\\n  return project_scale(position);\\n}\\n\\nvec4 scale(vec4 position) {\\n  return project_scale(position);\\n}\\n\\nvec2 preproject(vec2 position) {\\n  return project_position(position);\\n}\\n\\nvec3 preproject(vec3 position) {\\n  return project_position(position);\\n}\\n\\nvec4 preproject(vec4 position) {\\n  return project_position(position);\\n}\\n\\nvec4 project(vec4 position) {\\n  return project_to_clipspace(position);\\n}\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NoYWRlcmxpYi9wcm9qZWN0L2luZGV4LmpzP2ZjOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmV4cG9ydCBjb25zdCBwcm9qZWN0ID0ge1xuICBpbnRlcmZhY2U6ICdwcm9qZWN0JyxcbiAgc291cmNlOiAnY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzY7XFxuY29uc3QgZmxvYXQgV09STERfU0NBTEUgPSBUSUxFX1NJWkUgLyAoUEkgKiAyLjApO1xcblxcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTElORUFSID0gMC47XFxuY29uc3QgZmxvYXQgUFJPSkVDVF9NRVJDQVRPUiA9IDEuO1xcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUyA9IDIuO1xcblxcbnVuaWZvcm0gZmxvYXQgcHJvamVjdGlvbk1vZGU7XFxudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uU2NhbGU7XFxudW5pZm9ybSB2ZWM0IHByb2plY3Rpb25DZW50ZXI7XFxudW5pZm9ybSB2ZWMzIHByb2plY3Rpb25QaXhlbHNQZXJVbml0O1xcblxcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDtcXG5cXG4jaWZkZWYgSU5URUxfVEFOX1dPUktBUk9VTkRcXG5cXG4vLyBBbGwgdGhlc2UgZnVuY3Rpb25zIGFyZSBmb3Igc3Vic3RpdHV0aW5nIHRhbigpIGZ1bmN0aW9uIGZyb20gSW50ZWwgR1BVIG9ubHlcXG5jb25zdCBmbG9hdCBUV09fUEkgPSA2LjI4MzE4NTQ4MjAyNTE0NjU7XFxuY29uc3QgZmxvYXQgUElfMiA9IDEuNTcwNzk2MzcwNTA2Mjg2NjtcXG5jb25zdCBmbG9hdCBQSV8xNiA9IDAuMTk2MzQ5NTQ2MzEzMjg1ODtcXG5cXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMCA9IDAuMTk1MDkwMzIzNjg2NTk5NzM7XFxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzEgPSAwLjM4MjY4MzQyNjE0MTczODk7XFxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzIgPSAwLjU1NTU3MDI0NDc4OTEyMzU7XFxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XFxuXFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzAgPSAwLjk4MDc4NTI1MDY2Mzc1NzM7XFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzEgPSAwLjkyMzg3OTUwNDIwMzc5NjQ7XFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzIgPSAwLjgzMTQ2OTU5NTQzMjI4MTU7XFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XFxuXFxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfMyA9IDEuNjY2NjY2NzE2MzM3MjA0ZS0wMTsgLy8gMS8zIVxcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzUgPSA4LjMzMzMzMzc2Nzk1MDUzNWUtMDM7IC8vIDEvNSFcXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF83ID0gMS45ODQxMjcwMTEzODI5NTIzZS0wNDsgLy8gMS83IVxcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzkgPSAyLjc1NTczMTg4NDQ2Mjg3NTMzZS0wNjsgLy8gMS85IVxcblxcbmZsb2F0IHNpbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XFxuICBmbG9hdCByLCBzLCB0LCB4O1xcblxcbiAgaWYgKGEgPT0gMC4wKSB7XFxuICAgIHJldHVybiAwLjA7XFxuICB9XFxuXFxuICB4ID0gLWEgKiBhO1xcbiAgcyA9IGE7XFxuICByID0gYTtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfMztcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNTtcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNztcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfOTtcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHJldHVybiBzO1xcbn1cXG5cXG52b2lkIHNpbmNvc190YXlsb3JfZnAzMihmbG9hdCBhLCBvdXQgZmxvYXQgc2luX3QsIG91dCBmbG9hdCBjb3NfdCkge1xcbiAgaWYgKGEgPT0gMC4wKSB7XFxuICAgIHNpbl90ID0gMC4wO1xcbiAgICBjb3NfdCA9IDEuMDtcXG4gIH1cXG4gIHNpbl90ID0gc2luX3RheWxvcl9mcDMyKGEpO1xcbiAgY29zX3QgPSBzcXJ0KDEuMCAtIHNpbl90ICogc2luX3QpO1xcbn1cXG5cXG5mbG9hdCB0YW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xcbiAgICBmbG9hdCBzaW5fYTtcXG4gICAgZmxvYXQgY29zX2E7XFxuXFxuICAgIGlmIChhID09IDAuMCkge1xcbiAgICAgICAgcmV0dXJuIDAuMDtcXG4gICAgfVxcblxcbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXFxuICAgIGZsb2F0IHogPSBmbG9vcihhIC8gVFdPX1BJKTtcXG4gICAgZmxvYXQgciA9IGEgLSBUV09fUEkgKiB6O1xcblxcbiAgICBmbG9hdCB0O1xcbiAgICBmbG9hdCBxID0gZmxvb3IociAvIFBJXzIgKyAwLjUpO1xcbiAgICBpbnQgaiA9IGludChxKTtcXG5cXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcXG4gICAgfVxcblxcbiAgICB0ID0gciAtIFBJXzIgKiBxO1xcblxcbiAgICBxID0gZmxvb3IodCAvIFBJXzE2ICsgMC41KTtcXG4gICAgaW50IGsgPSBpbnQocSk7XFxuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcXG5cXG4gICAgaWYgKGFic19rID4gNCkge1xcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHQgPSB0IC0gUElfMTYgKiBxO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IHUgPSAwLjA7XFxuICAgIGZsb2F0IHYgPSAwLjA7XFxuXFxuICAgIGZsb2F0IHNpbl90LCBjb3NfdDtcXG4gICAgZmxvYXQgcywgYztcXG4gICAgc2luY29zX3RheWxvcl9mcDMyKHQsIHNpbl90LCBjb3NfdCk7XFxuXFxuICAgIGlmIChrID09IDApIHtcXG4gICAgICAgIHMgPSBzaW5fdDtcXG4gICAgICAgIGMgPSBjb3NfdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzA7XFxuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8xO1xcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMTtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzI7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yO1xcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMztcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzM7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICBzID0gdSAqIHNpbl90ICsgdiAqIGNvc190O1xcbiAgICAgICAgICAgIGMgPSB1ICogY29zX3QgLSB2ICogc2luX3Q7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHMgPSB1ICogc2luX3QgLSB2ICogY29zX3Q7XFxuICAgICAgICAgICAgYyA9IHUgKiBjb3NfdCArIHYgKiBzaW5fdDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoaiA9PSAwKSB7XFxuICAgICAgICBzaW5fYSA9IHM7XFxuICAgICAgICBjb3NfYSA9IGM7XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XFxuICAgICAgICBzaW5fYSA9IGM7XFxuICAgICAgICBjb3NfYSA9IC1zO1xcbiAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcXG4gICAgICAgIHNpbl9hID0gLWM7XFxuICAgICAgICBjb3NfYSA9IHM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBzaW5fYSA9IC1zO1xcbiAgICAgICAgY29zX2EgPSAtYztcXG4gICAgfVxcbiAgICByZXR1cm4gc2luX2EgLyBjb3NfYTtcXG59XFxuI2VuZGlmXFxuXFxuZmxvYXQgdGFuX2ZwMzIoZmxvYXQgYSkge1xcbiNpZmRlZiBJTlRFTF9UQU5fV09SS0FST1VORFxcbiAgcmV0dXJuIHRhbl90YXlsb3JfZnAzMihhKTtcXG4jZWxzZVxcbiAgcmV0dXJuIHRhbihhKTtcXG4jZW5kaWZcXG59XFxuXFxuLy9cXG4vLyBTY2FsaW5nIG9mZnNldHNcXG4vL1xcblxcbmZsb2F0IHByb2plY3Rfc2NhbGUoZmxvYXQgbWV0ZXJzKSB7XFxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBtZXRlcnM7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbWV0ZXJzICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueDtcXG4gIH1cXG59XFxuXFxudmVjMiBwcm9qZWN0X3NjYWxlKHZlYzIgbWV0ZXJzKSB7XFxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBtZXRlcnM7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdmVjMihcXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54XFxuICAgICk7XFxuICB9XFxufVxcblxcbnZlYzMgcHJvamVjdF9zY2FsZSh2ZWMzIG1ldGVycykge1xcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xcbiAgICByZXR1cm4gbWV0ZXJzO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHZlYzMoXFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcXG4gICAgICBtZXRlcnMueiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnhcXG4gICAgKTtcXG4gIH1cXG59XFxuXFxudmVjNCBwcm9qZWN0X3NjYWxlKHZlYzQgbWV0ZXJzKSB7XFxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBtZXRlcnM7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdmVjNChcXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxcbiAgICAgIG1ldGVycy56ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcXG4gICAgICBtZXRlcnMud1xcbiAgICApO1xcbiAgfVxcbn1cXG5cXG4vL1xcbi8vIFByb2plY3RpbmcgcG9zaXRpb25zXFxuLy9cXG5cXG4vLyBub24tbGluZWFyIHByb2plY3Rpb246IGxuZ2xhdHMgPT4gdW5pdCB0aWxlIFswLTEsIDAtMV1cXG52ZWMyIHByb2plY3RfbWVyY2F0b3JfKHZlYzIgbG5nbGF0KSB7XFxuICByZXR1cm4gdmVjMihcXG4gICAgcmFkaWFucyhsbmdsYXQueCkgKyBQSSxcXG4gICAgUEkgLSBsb2codGFuX2ZwMzIoUEkgKiAwLjI1ICsgcmFkaWFucyhsbmdsYXQueSkgKiAwLjUpKVxcbiAgKTtcXG59XFxuXFxudmVjMiBwcm9qZWN0X3Bvc2l0aW9uKHZlYzIgcG9zaXRpb24pIHtcXG4gIC8vIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX0xJTkVBUikge1xcbiAgLy8gICByZXR1cm4gKHBvc2l0aW9uICsgdmVjMihUSUxFX1NJWkUgLyAyLjApKSAqIHByb2plY3Rpb25TY2FsZTtcXG4gIC8vIH1cXG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xcbiAgICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XFxuICB9XFxuICAvLyBDb3ZlcnMgcHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUlxcbiAgcmV0dXJuIHByb2plY3RfbWVyY2F0b3JfKHBvc2l0aW9uKSAqIFdPUkxEX1NDQUxFICogcHJvamVjdGlvblNjYWxlO1xcbn1cXG5cXG52ZWMzIHByb2plY3RfcG9zaXRpb24odmVjMyBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHZlYzMocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbi54eSksIHByb2plY3Rfc2NhbGUocG9zaXRpb24ueikpO1xcbn1cXG5cXG52ZWM0IHByb2plY3RfcG9zaXRpb24odmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHZlYzQocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbi54eXopLCBwb3NpdGlvbi53KTtcXG59XFxuXFxuLy9cXG5cXG52ZWM0IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQgcG9zaXRpb24pIHtcXG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XFxuICB9XFxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeCAqIHBvc2l0aW9uICsgcHJvamVjdGlvbkNlbnRlcjtcXG59XFxuXFxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXG5mbG9hdCBzY2FsZShmbG9hdCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xcbn1cXG5cXG52ZWMyIHNjYWxlKHZlYzIgcG9zaXRpb24pIHtcXG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcXG59XFxuXFxudmVjMyBzY2FsZSh2ZWMzIHBvc2l0aW9uKSB7XFxuICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XFxufVxcblxcbnZlYzQgc2NhbGUodmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xcbn1cXG5cXG52ZWMyIHByZXByb2plY3QodmVjMiBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xcbn1cXG5cXG52ZWMzIHByZXByb2plY3QodmVjMyBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xcbn1cXG5cXG52ZWM0IHByZXByb2plY3QodmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xcbn1cXG5cXG52ZWM0IHByb2plY3QodmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uKTtcXG59XFxuJ1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3NoYWRlcmxpYi9wcm9qZWN0L2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 62 */
/* exports provided: project64 */
/* exports used: project64 */
/*!******************************************!*\
  !*** ./src/shaderlib/project64/index.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(exports, \"a\", function() { return project64; });\n\n\nvar project64 = {\n  interface: 'project64',\n  source: 'const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\\n\\nuniform vec2 projectionScaleFP64;\\nuniform vec2 projectionFP64[16];\\n\\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) { //longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\\n\\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\\n  out_val[1] = sub_fp64(PI_FP64, log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\\n  return;\\n}\\n\\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\\n\\n  vec2 pos_fp64[2];\\n  mercatorProject_fp64(position_fp64, pos_fp64);\\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], projectionScaleFP64);\\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], projectionScaleFP64);\\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\\n\\n  return;\\n}\\n\\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\\n  vec2 vertex_pos_clipspace[4];\\n  mat4_vec4_mul_fp64(projectionFP64, vertex_pos_modelspace, vertex_pos_clipspace);\\n  return vec4(\\n    vertex_pos_clipspace[0].x,\\n    vertex_pos_clipspace[1].x,\\n    vertex_pos_clipspace[2].x,\\n    vertex_pos_clipspace[3].x\\n    );\\n}\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3NoYWRlcmxpYi9wcm9qZWN0NjQvaW5kZXguanM/OWQwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuZXhwb3J0IGNvbnN0IHByb2plY3Q2NCA9IHtcbiAgaW50ZXJmYWNlOiAncHJvamVjdDY0JyxcbiAgc291cmNlOiAnY29uc3QgdmVjMiBXT1JMRF9TQ0FMRV9GUDY0ID0gdmVjMig4MS40ODczMjc1NzU2ODM2LCAwLjAwMDAwMzI4NzM2NjgyMzIwMTQwOTcpO1xcblxcbnVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uU2NhbGVGUDY0O1xcbnVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uRlA2NFsxNl07XFxuXFxudm9pZCBtZXJjYXRvclByb2plY3RfZnA2NCh2ZWM0IGxuZ2xhdF9mcDY0LCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7IC8vbG9uZ2l0dWRlOiBsbmdsYXRfZnA2NC54eTsgbGF0aXR1ZGU6IGxuZ2xhdF9mcDY0Lnp3XFxuXFxuICBvdXRfdmFsWzBdID0gc3VtX2ZwNjQocmFkaWFuc19mcDY0KGxuZ2xhdF9mcDY0Lnh5KSwgUElfRlA2NCk7XFxuICBvdXRfdmFsWzFdID0gc3ViX2ZwNjQoUElfRlA2NCwgbG9nX2ZwNjQodGFuX2ZwNjQoc3VtX2ZwNjQoUElfNF9GUDY0LCByYWRpYW5zX2ZwNjQobG5nbGF0X2ZwNjQuencpIC8gMi4wKSkpKTtcXG4gIHJldHVybjtcXG59XFxuXFxudm9pZCBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQodmVjNCBwb3NpdGlvbl9mcDY0LCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XFxuXFxuICB2ZWMyIHBvc19mcDY0WzJdO1xcbiAgbWVyY2F0b3JQcm9qZWN0X2ZwNjQocG9zaXRpb25fZnA2NCwgcG9zX2ZwNjQpO1xcbiAgdmVjMiB4X2ZwNjQgPSBtdWxfZnA2NChwb3NfZnA2NFswXSwgcHJvamVjdGlvblNjYWxlRlA2NCk7XFxuICB2ZWMyIHlfZnA2NCA9IG11bF9mcDY0KHBvc19mcDY0WzFdLCBwcm9qZWN0aW9uU2NhbGVGUDY0KTtcXG4gIG91dF92YWxbMF0gPSBtdWxfZnA2NCh4X2ZwNjQsIFdPUkxEX1NDQUxFX0ZQNjQpO1xcbiAgb3V0X3ZhbFsxXSA9IG11bF9mcDY0KHlfZnA2NCwgV09STERfU0NBTEVfRlA2NCk7XFxuXFxuICByZXR1cm47XFxufVxcblxcbnZlYzQgcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XSkge1xcbiAgdmVjMiB2ZXJ0ZXhfcG9zX2NsaXBzcGFjZVs0XTtcXG4gIG1hdDRfdmVjNF9tdWxfZnA2NChwcm9qZWN0aW9uRlA2NCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlLCB2ZXJ0ZXhfcG9zX2NsaXBzcGFjZSk7XFxuICByZXR1cm4gdmVjNChcXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbMF0ueCxcXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbMV0ueCxcXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbMl0ueCxcXG4gICAgdmVydGV4X3Bvc19jbGlwc3BhY2VbM10ueFxcbiAgICApO1xcbn1cXG4nXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc2hhZGVybGliL3Byb2plY3Q2NC9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 63 */
/* unknown exports provided */
/* exports used: version */
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ (function(module, exports) {

eval("module.exports = {\n\t\"name\": \"deck.gl\",\n\t\"description\": \"A suite of 3D-enabled data visualization overlays, suitable for react-map-gl\",\n\t\"license\": \"MIT\",\n\t\"version\": \"3.1.0-beta.10\",\n\t\"keywords\": [\n\t\t\"webgl\",\n\t\t\"visualization\",\n\t\t\"overlay\",\n\t\t\"layer\"\n\t],\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/uber/deck.gl.git\"\n\t},\n\t\"main\": \"dist/lib-bundle.js\",\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"src\"\n\t],\n\t\"scripts\": {\n\t\t\"start\": \"(cd examples/main && yarn && npm start)\",\n\t\t\"compile\": \"rm -fr dist && buble src -o dist --no modules --y dangerousForOf --objectAssign\",\n\t\t\"build\": \"rm -fr dist && buble src -o dist --no modules --y dangerousForOf --objectAssign && webpack -d --display-modules\",\n\t\t\"lint\": \"eslint src test exhibits/app.js examples\",\n\t\t\"publish-prod\": \"npm run build && npm run test-fast && npm publish\",\n\t\t\"publish-beta\": \"npm run build && npm run test-fast && npm publish --tag beta\",\n\t\t\"test\": \"npm run lint && npm run test-node\",\n\t\t\"test-fast\": \"npm run lint && node test/node.js | faucet\",\n\t\t\"test-node\": \"npm run build && node test/node.js\",\n\t\t\"test-browser\": \"webpack-dev-server --config webpack.config.test-browser.js --progress --hot --open\",\n\t\t\"test-fp64\": \"(cd test/fp64-test && webpack-dev-server --config webpack.config.test-fp64.js --progress --hot --open)\",\n\t\t\"test-rendering\": \"(cd test/rendering-test && webpack-dev-server --config webpack.config.test-rendering.js --progress --hot --open)\"\n\t},\n\t\"dependencies\": {\n\t\t\"earcut\": \"^2.0.6\",\n\t\t\"geojson-normalize\": \"0.0.1\",\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"lodash.flattendeep\": \"^4.4.0\",\n\t\t\"viewport-mercator-project\": \"3.0.0-beta4\"\n\t},\n\t\"devDependencies\": {\n\t\t\"babel-polyfill\": \"^6.20.0\",\n\t\t\"brfs-babel\": \"^1.0.0\",\n\t\t\"buble\": \"^0.15.1\",\n\t\t\"buble-loader\": \"^0.4.0\",\n\t\t\"eslint\": \"^3.0.0\",\n\t\t\"eslint-config-uber-es2015\": \"^3.0.0\",\n\t\t\"eslint-config-uber-jsx\": \"^3.0.0\",\n\t\t\"eslint-plugin-react\": \"~6.7.0\",\n\t\t\"faucet\": \"0.0.1\",\n\t\t\"gl\": \"^4.0.2\",\n\t\t\"immutable\": \"^3.7.5\",\n\t\t\"jsdom\": \"^9.9.1\",\n\t\t\"luma.gl\": \"3.0.0-alpha.3\",\n\t\t\"module-alias\": \"^2.0.0\",\n\t\t\"pre-commit\": \"^1.2.2\",\n\t\t\"raw-loader\": \"^0.5.1\",\n\t\t\"react\": \"^15.4.0\",\n\t\t\"react-addons-test-utils\": \"^15.4.2\",\n\t\t\"react-dom\": \"^15.4.0\",\n\t\t\"react-map-gl\": \"^1.7.2\",\n\t\t\"reify\": \"^0.4.4\",\n\t\t\"sinon\": \"^1.17.7\",\n\t\t\"tap-browser-color\": \"^0.1.2\",\n\t\t\"tape\": \"^4.5.1\",\n\t\t\"tape-catch\": \"^1.0.4\",\n\t\t\"transform-loader\": \"^0.2.3\",\n\t\t\"uglify-js\": \"^2.6.1\",\n\t\t\"webpack\": \"^2.2.0-rc.3\",\n\t\t\"webpack-dev-server\": \"^2.2.0-rc.0\"\n\t},\n\t\"peerDependencies\": {\n\t\t\"luma.gl\": \"^3.0.0-alpha.3\",\n\t\t\"react\": \"0.14.x - 15.x\",\n\t\t\"react-dom\": \"0.14.x - 15.x\"\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24/ZWQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwiZGVjay5nbFwiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiQSBzdWl0ZSBvZiAzRC1lbmFibGVkIGRhdGEgdmlzdWFsaXphdGlvbiBvdmVybGF5cywgc3VpdGFibGUgZm9yIHJlYWN0LW1hcC1nbFwiLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJ2ZXJzaW9uXCI6IFwiMy4xLjAtYmV0YS4xMFwiLFxuXHRcImtleXdvcmRzXCI6IFtcblx0XHRcIndlYmdsXCIsXG5cdFx0XCJ2aXN1YWxpemF0aW9uXCIsXG5cdFx0XCJvdmVybGF5XCIsXG5cdFx0XCJsYXllclwiXG5cdF0sXG5cdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XCJ0eXBlXCI6IFwiZ2l0XCIsXG5cdFx0XCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsLmdpdFwiXG5cdH0sXG5cdFwibWFpblwiOiBcImRpc3QvbGliLWJ1bmRsZS5qc1wiLFxuXHRcImZpbGVzXCI6IFtcblx0XHRcImRpc3RcIixcblx0XHRcInNyY1wiXG5cdF0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJzdGFydFwiOiBcIihjZCBleGFtcGxlcy9tYWluICYmIHlhcm4gJiYgbnBtIHN0YXJ0KVwiLFxuXHRcdFwiY29tcGlsZVwiOiBcInJtIC1mciBkaXN0ICYmIGJ1YmxlIHNyYyAtbyBkaXN0IC0tbm8gbW9kdWxlcyAtLXkgZGFuZ2Vyb3VzRm9yT2YgLS1vYmplY3RBc3NpZ25cIixcblx0XHRcImJ1aWxkXCI6IFwicm0gLWZyIGRpc3QgJiYgYnVibGUgc3JjIC1vIGRpc3QgLS1ubyBtb2R1bGVzIC0teSBkYW5nZXJvdXNGb3JPZiAtLW9iamVjdEFzc2lnbiAmJiB3ZWJwYWNrIC1kIC0tZGlzcGxheS1tb2R1bGVzXCIsXG5cdFx0XCJsaW50XCI6IFwiZXNsaW50IHNyYyB0ZXN0IGV4aGliaXRzL2FwcC5qcyBleGFtcGxlc1wiLFxuXHRcdFwicHVibGlzaC1wcm9kXCI6IFwibnBtIHJ1biBidWlsZCAmJiBucG0gcnVuIHRlc3QtZmFzdCAmJiBucG0gcHVibGlzaFwiLFxuXHRcdFwicHVibGlzaC1iZXRhXCI6IFwibnBtIHJ1biBidWlsZCAmJiBucG0gcnVuIHRlc3QtZmFzdCAmJiBucG0gcHVibGlzaCAtLXRhZyBiZXRhXCIsXG5cdFx0XCJ0ZXN0XCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gdGVzdC1ub2RlXCIsXG5cdFx0XCJ0ZXN0LWZhc3RcIjogXCJucG0gcnVuIGxpbnQgJiYgbm9kZSB0ZXN0L25vZGUuanMgfCBmYXVjZXRcIixcblx0XHRcInRlc3Qtbm9kZVwiOiBcIm5wbSBydW4gYnVpbGQgJiYgbm9kZSB0ZXN0L25vZGUuanNcIixcblx0XHRcInRlc3QtYnJvd3NlclwiOiBcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy50ZXN0LWJyb3dzZXIuanMgLS1wcm9ncmVzcyAtLWhvdCAtLW9wZW5cIixcblx0XHRcInRlc3QtZnA2NFwiOiBcIihjZCB0ZXN0L2ZwNjQtdGVzdCAmJiB3ZWJwYWNrLWRldi1zZXJ2ZXIgLS1jb25maWcgd2VicGFjay5jb25maWcudGVzdC1mcDY0LmpzIC0tcHJvZ3Jlc3MgLS1ob3QgLS1vcGVuKVwiLFxuXHRcdFwidGVzdC1yZW5kZXJpbmdcIjogXCIoY2QgdGVzdC9yZW5kZXJpbmctdGVzdCAmJiB3ZWJwYWNrLWRldi1zZXJ2ZXIgLS1jb25maWcgd2VicGFjay5jb25maWcudGVzdC1yZW5kZXJpbmcuanMgLS1wcm9ncmVzcyAtLWhvdCAtLW9wZW4pXCJcblx0fSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiZWFyY3V0XCI6IFwiXjIuMC42XCIsXG5cdFx0XCJnZW9qc29uLW5vcm1hbGl6ZVwiOiBcIjAuMC4xXCIsXG5cdFx0XCJnbC1tYXRyaXhcIjogXCJeMi4zLjJcIixcblx0XHRcImxvZGFzaC5mbGF0dGVuZGVlcFwiOiBcIl40LjQuMFwiLFxuXHRcdFwidmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdFwiOiBcIjMuMC4wLWJldGE0XCJcblx0fSxcblx0XCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiYmFiZWwtcG9seWZpbGxcIjogXCJeNi4yMC4wXCIsXG5cdFx0XCJicmZzLWJhYmVsXCI6IFwiXjEuMC4wXCIsXG5cdFx0XCJidWJsZVwiOiBcIl4wLjE1LjFcIixcblx0XHRcImJ1YmxlLWxvYWRlclwiOiBcIl4wLjQuMFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJlc2xpbnQtY29uZmlnLXViZXItZXMyMDE1XCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJlc2xpbnQtY29uZmlnLXViZXItanN4XCI6IFwiXjMuMC4wXCIsXG5cdFx0XCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwifjYuNy4wXCIsXG5cdFx0XCJmYXVjZXRcIjogXCIwLjAuMVwiLFxuXHRcdFwiZ2xcIjogXCJeNC4wLjJcIixcblx0XHRcImltbXV0YWJsZVwiOiBcIl4zLjcuNVwiLFxuXHRcdFwianNkb21cIjogXCJeOS45LjFcIixcblx0XHRcImx1bWEuZ2xcIjogXCIzLjAuMC1hbHBoYS4zXCIsXG5cdFx0XCJtb2R1bGUtYWxpYXNcIjogXCJeMi4wLjBcIixcblx0XHRcInByZS1jb21taXRcIjogXCJeMS4yLjJcIixcblx0XHRcInJhdy1sb2FkZXJcIjogXCJeMC41LjFcIixcblx0XHRcInJlYWN0XCI6IFwiXjE1LjQuMFwiLFxuXHRcdFwicmVhY3QtYWRkb25zLXRlc3QtdXRpbHNcIjogXCJeMTUuNC4yXCIsXG5cdFx0XCJyZWFjdC1kb21cIjogXCJeMTUuNC4wXCIsXG5cdFx0XCJyZWFjdC1tYXAtZ2xcIjogXCJeMS43LjJcIixcblx0XHRcInJlaWZ5XCI6IFwiXjAuNC40XCIsXG5cdFx0XCJzaW5vblwiOiBcIl4xLjE3LjdcIixcblx0XHRcInRhcC1icm93c2VyLWNvbG9yXCI6IFwiXjAuMS4yXCIsXG5cdFx0XCJ0YXBlXCI6IFwiXjQuNS4xXCIsXG5cdFx0XCJ0YXBlLWNhdGNoXCI6IFwiXjEuMC40XCIsXG5cdFx0XCJ0cmFuc2Zvcm0tbG9hZGVyXCI6IFwiXjAuMi4zXCIsXG5cdFx0XCJ1Z2xpZnktanNcIjogXCJeMi42LjFcIixcblx0XHRcIndlYnBhY2tcIjogXCJeMi4yLjAtcmMuM1wiLFxuXHRcdFwid2VicGFjay1kZXYtc2VydmVyXCI6IFwiXjIuMi4wLXJjLjBcIlxuXHR9LFxuXHRcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwibHVtYS5nbFwiOiBcIl4zLjAuMC1hbHBoYS4zXCIsXG5cdFx0XCJyZWFjdFwiOiBcIjAuMTQueCAtIDE1LnhcIixcblx0XHRcInJlYWN0LWRvbVwiOiBcIjAuMTQueCAtIDE1LnhcIlxuXHR9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcGFja2FnZS5qc29uXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 64 */
/* exports provided: ArcLayer, ChoroplethLayer, LineLayer, ScatterplotLayer, ScreenGridLayer, ScatterplotLayer64, ArcLayer64, ChoroplethLayer64, ExtrudedChoroplethLayer64, LineLayer64, autobind, DeckGL, default, EffectManager, Effect, ReflectionEffect, COORDINATE_SYSTEM, Layer, AttributeManager, LayerManager, isPlainObject, checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ./lib */ 2);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"COORDINATE_SYSTEM\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"Layer\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"b\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"AttributeManager\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"c\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"LayerManager\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"d\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"isPlainObject\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"e\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"checkRendererVendor\", function() { return __WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"getPlatformShaderDefines\", function() { return __WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"b\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(exports, \"assembleShaders\", function() { return __WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"c\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ./shader-utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layers_core_arc_layer__ = __webpack_require__(/*! ./layers/core/arc-layer */ 24);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ArcLayer\", function() { return __WEBPACK_IMPORTED_MODULE_2__layers_core_arc_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__layers_core_choropleth_layer__ = __webpack_require__(/*! ./layers/core/choropleth-layer */ 25);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ChoroplethLayer\", function() { return __WEBPACK_IMPORTED_MODULE_3__layers_core_choropleth_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__layers_core_line_layer__ = __webpack_require__(/*! ./layers/core/line-layer */ 26);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"LineLayer\", function() { return __WEBPACK_IMPORTED_MODULE_4__layers_core_line_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layers_core_scatterplot_layer__ = __webpack_require__(/*! ./layers/core/scatterplot-layer */ 17);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ScatterplotLayer\", function() { return __WEBPACK_IMPORTED_MODULE_5__layers_core_scatterplot_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__layers_core_screen_grid_layer__ = __webpack_require__(/*! ./layers/core/screen-grid-layer */ 27);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ScreenGridLayer\", function() { return __WEBPACK_IMPORTED_MODULE_6__layers_core_screen_grid_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__layers_fp64_scatterplot_layer__ = __webpack_require__(/*! ./layers/fp64/scatterplot-layer */ 32);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ScatterplotLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_7__layers_fp64_scatterplot_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__layers_fp64_arc_layer__ = __webpack_require__(/*! ./layers/fp64/arc-layer */ 28);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ArcLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_8__layers_fp64_arc_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__layers_fp64_choropleth_layer__ = __webpack_require__(/*! ./layers/fp64/choropleth-layer */ 29);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ChoroplethLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_9__layers_fp64_choropleth_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__layers_fp64_extruded_choropleth_layer__ = __webpack_require__(/*! ./layers/fp64/extruded-choropleth-layer */ 30);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ExtrudedChoroplethLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_10__layers_fp64_extruded_choropleth_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__layers_fp64_line_layer__ = __webpack_require__(/*! ./layers/fp64/line-layer */ 31);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"LineLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_11__layers_fp64_line_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__react_autobind__ = __webpack_require__(/*! ./react/autobind */ 10);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"autobind\", function() { return __WEBPACK_IMPORTED_MODULE_12__react_autobind__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__react_deckgl__ = __webpack_require__(/*! ./react/deckgl */ 11);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"DeckGL\", function() { return __WEBPACK_IMPORTED_MODULE_13__react_deckgl__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"default\", function() { return __WEBPACK_IMPORTED_MODULE_13__react_deckgl__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__experimental_lib__ = __webpack_require__(/*! ./experimental/lib */ 9);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"EffectManager\", function() { return __WEBPACK_IMPORTED_MODULE_14__experimental_lib__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"Effect\", function() { return __WEBPACK_IMPORTED_MODULE_14__experimental_lib__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__experimental_effects_reflection_effect__ = __webpack_require__(/*! ./experimental/effects/reflection-effect */ 16);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"ReflectionEffect\", function() { return __WEBPACK_IMPORTED_MODULE_15__experimental_effects_reflection_effect__[\"a\"]; });\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n// Core Layers\n\n\n\n\n\n\n// 64-bit Layers\n\n\n\n\n\n\n// React exports\n\n\n\n\n// Effects\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2luZGV4LmpzPzFmZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuZXhwb3J0ICogZnJvbSAnLi9saWInO1xuZXhwb3J0ICogZnJvbSAnLi9zaGFkZXItdXRpbHMnO1xuXG4vLyBDb3JlIExheWVyc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBcmNMYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvYXJjLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hvcm9wbGV0aExheWVyIH0gZnJvbSAnLi9sYXllcnMvY29yZS9jaG9yb3BsZXRoLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZUxheWVyIH0gZnJvbSAnLi9sYXllcnMvY29yZS9saW5lLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NhdHRlcnBsb3RMYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY3JlZW5HcmlkTGF5ZXIgfSBmcm9tICcuL2xheWVycy9jb3JlL3NjcmVlbi1ncmlkLWxheWVyJztcblxuLy8gNjQtYml0IExheWVyc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY2F0dGVycGxvdExheWVyNjQgfSBmcm9tICcuL2xheWVycy9mcDY0L3NjYXR0ZXJwbG90LWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXJjTGF5ZXI2NCB9IGZyb20gJy4vbGF5ZXJzL2ZwNjQvYXJjLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hvcm9wbGV0aExheWVyNjQgfSBmcm9tICcuL2xheWVycy9mcDY0L2Nob3JvcGxldGgtbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHRydWRlZENob3JvcGxldGhMYXllcjY0IH0gZnJvbSAnLi9sYXllcnMvZnA2NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZUxheWVyNjQgfSBmcm9tICcuL2xheWVycy9mcDY0L2xpbmUtbGF5ZXInO1xuXG4vLyBSZWFjdCBleHBvcnRzXG5leHBvcnQgeyBkZWZhdWx0IGFzIGF1dG9iaW5kIH0gZnJvbSAnLi9yZWFjdC9hdXRvYmluZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlY2tHTCB9IGZyb20gJy4vcmVhY3QvZGVja2dsJztcbmV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL3JlYWN0L2RlY2tnbCc7XG5cbi8vIEVmZmVjdHNcbmV4cG9ydCB7IEVmZmVjdE1hbmFnZXIsIEVmZmVjdCB9IGZyb20gJy4vZXhwZXJpbWVudGFsL2xpYic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlZmxlY3Rpb25FZmZlY3QgfSBmcm9tICcuL2V4cGVyaW1lbnRhbC9lZmZlY3RzL3JlZmxlY3Rpb24tZWZmZWN0JztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);
});